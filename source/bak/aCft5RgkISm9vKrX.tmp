##{0}F:\Projects\Cassiopei\Versie_2-Wifi\Software\CBM_software\Cassiopei_v2.0-Disk_Wizard\source\\00_Info_and_Computermodel.asm

;This program was written by Jan Derogee as a menu program for the Cassiopei
;The Cassiopei is a device that connects to the cassetteport of the CBM computer.
;The casetteport is the only interface that exists on all 8-bit CBM models, and
;is mostly supported by them all, although exceptions exist like the CBM600 series.
;
;If spread (and or modified) please always refer to the original designer/programmer.
;
;---------------------------------------------------------------------------------------------------------
;
; ATTENTION: This code has been developed to be used with the CBM Program Studio compiler V3.10.0
; ==========
; make sure that the build order is exactly according the numbers of the individual filenames
;(this can be set using: project -> properties)
;example:
; 00_......
; 01_0_....
; 01_1_....
; 01_2_....
; 01_3_....
; 02_0_....
; 02_1_....
; etc.
;---------------------------------------------------------------------------------------------------------

;When using CBM prog studio to compile this program, make sure that you
;compile the entire project (Build -> Project -> And Run (CTRL+F5) )

;All files in this program begin with a number, it is important that the files
;are build in the order as indicated by these numbers.
;The numbering consists of a 2 digit value followed by a third value.
;The first 2 digits indicate the type of file and it's intended function which
;is described by the name directly after the third number. The third number
;indicates a variation of the file caused by a different implementation of the
;code for certain computer model(s).


;regarding the CBM program studio assembler mind the following settings:
;disable the option : optimize absolute modes to zero page

;                           BUILD RELATED SETTINGS
;-------------------------------------------------------------------------------
;to compile this program for a specific computer model, just uncomment the
;model from the list below and compile the project. Make sure that only one
;of the items below is uncommented!

;COMMODOREPET20XX
;COMMODOREPET30XX = 1
;COMMODOREPET40XX
;COMMODOREPET80XX
COMMODOREVIC20 = 1
;COMMODORE64 = 1
;COMMODORE128 = 1
;COMMODORE16 = 1
;COMMODOREPLUS4 = 1

TYPE_D64 = 1
;TYPE_D81 = 1


VERSION_STRING_00 = 1 ;tens of year
VERSION_STRING_01 = 9 ;ones of year
VERSION_STRING_02 = 0 ;tens of month
VERSION_STRING_03 = 9 ;ones of month
VERSION_STRING_04 = 0 ;tens of day
VERSION_STRING_05 = 1 ;ones of day

;-------------------------------------------------------------------------------
;File name convention:
;=====================
;the files in this project are named in the following fashion:
;
;0X_0_name      <- this is the file that holds all generic functionality
;0X_1_name      <- this is the file holding the computer specific code (PET series)
;0X_2_name      <- this is the file holding the computer specific code (VIC20)
;0X_3_name      <- this is the file holding the computer specific code (C64)
;0X_4_name      <- this is the file holding the computer specific code (C128)
;0X_5_name      <- this is the file holding the computer specific code (C16/plus4)

;ATTENTION regarding screen editor:
;all screen are to be editted in the C64 mode (because allmost all screens are 40col)
;except the VIC20 screen must be done in VIC20 mode (because of the 20col)
;except the CBM/PET8000 screen must be done in PET 4000/9000 mode (because of the 80col)

;ATTENION regarding ifdef
;do not use nested ifdef constructions

##{0}F:\Projects\Cassiopei\Versie_2-Wifi\Software\CBM_software\Cassiopei_v2.0-Disk_Wizard\source\\01_0_Constants_and_BasicStart.asm

; CPIO related constants
;------------------------


CPIO_DATAFILE_OPEN      = %10000000     ;open file*/
CPIO_DATAFILE_SEEKPOS   = %10000001     ;set datapointer to new location in the file*/
CPIO_DATAFILE_READ      = %10000010     ;read from file*/
CPIO_DATAFILE_WRITE     = %10000011     ;write to file*/
CPIO_DATAFILE_CLOSE     = %10000100     ;close the file*/


CPIO_PARAMETER          = %11111111     ;a general purpose command to parse filename (and all sorts of parameters that might be required for the next following CPIO command)


CPIO_BROWSE             = %00000101     ;CPIO command 0x05:  all file selection related actions
CPIO_BROWSE_REFRESH     = $00           ;                    refresh (the menu itself is not altered, the menu screen data is returned)
CPIO_BROWSE_PREVIOUS    = $01           ;                    previous (navigate through the menu)
CPIO_BROWSE_SELECT      = $02           ;                    select (select current item from the menu)
CPIO_BROWSE_NEXT        = $03           ;                    next (navigate through the menu)
CPIO_BROWSE_RESET       = $FF           ;                    reset menu


; menu related constants (values parsed by the keyboard and joystick reading routines)
;-----------------------
USER_INPUT_IDLE         = 0
USER_INPUT_SELECT       = 1
USER_INPUT_PREVIOUS     = 2
USER_INPUT_NEXT         = 3
USER_INPUT_DIR          = 101
USER_INPUT_CREATE       = 102
USER_INPUT_EXIT         = 103
USER_INPUT_FILENAME     = 104
USER_INPUT_NO           = 105
USER_INPUT_YES          = 106

USER_INPUT_CHA          = 10
USER_INPUT_CHB          = 11

BROWSE_BUSY             = 0
BROWSE_EXIT             = 1

##{0}F:\Projects\Cassiopei\Versie_2-Wifi\Software\CBM_software\Cassiopei_v2.0-Disk_Wizard\source\\01_1_Constants_and_BasicStart.asm

;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ifdef COMMODOREPET20XX or COMMODOREPET30XX or COMMODOREPET40XX or COMMODOREPET80XX
;-------------------------------------------------------------------------------

*=$0401
        BYTE    $0E, $08, $0A, $00, $9E, $20, $28,  $31, $30, $37, $32, $29, $00, $00, $00      ;10 SYS (1072)


;-------------------------------------------------------------------------------
endif
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<





;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ifdef COMMODOREPET20XX OR COMMODOREPET30XX OR COMMODOREPET40XX
*=$0410
PRG_IDENTIFIER      ;'0123456789ABCDEF'
                TEXT 'petscii player for 40kol PET' ;this message could be valuable hint in solving a problem
                BYTE 0;end of table marker
endif
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ifdef COMMODOREPET80XX
*=$0410
PRG_IDENTIFIER      ;'0123456789ABCDEF'
                TEXT 'petscii player for 80kol PET' ;this message could be valuable hint in solving a problem
                BYTE 0;end of table marker
endif
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<








;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ifdef COMMODOREPET20XX or COMMODOREPET30XX or COMMODOREPET40XX or COMMODOREPET80XX
;-------------------------------------------------------------------------------

*=$0430
PRG_START       LDA #$0C        ;we must force the PET to display a charset that ALL systems can use (according: http://www.atarimagazines.com/compute/issue26/171_1_ALL_ABOUT_PET_CBM_CHARACTER_SETS.php)
                STA $E84C       ;the charset layout we are using now would be identical to the C64 charset layout. NOTE:the 2001's do not have the option of a configurable charset :-(
                JMP INIT        ;start the program

;;-- zeropage RAM registers --
CPIO_DATA       = $A2           ;this zeropage memory location is used to parse the CPIO data
CHAR_ADDR       = $54
;CHAR_ADDR+1    = $55
STR_ADDR        = $56  ;pointer to string
;STR_ADDR+1     = $57  ;           
ADDR_LAST_TILE  = $1F  ;pointer (used in NORMAL mode, for detection of the last tile,
;ADDR_LAST_TILE+1= $20  ;this way we don't have to keep a counter, we just compare two 16-bit values)
CNTR            = $21  ;pointer (used in DELTA mode, since the last tile is unpredictable, this counter just counts the number of tiles
;CNTR+1         = $22  ;until it matches the "changed tiles" value of the image)      
ADDR            = $23  ;pointer
;ADDR+1         = $24  ;     
 

;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ifdef COMMODOREPET20XX OR COMMODOREPET30XX OR COMMODOREPET40XX

;-- BUILD RELATED SETTINGS --

;-- build related settings --
WINDOW_X_POS    = 1             ;the X-distance from top-left
WINDOW_Y_POS    = 8             ;the Y-distance from top-left
WINDOW_X_SIZE   = 31            ;the X-size of the window to be scrolled
WINDOW_Y_SIZE   = 14            ;the Y-size of the window to be scrolled

SUPPORTED_X_SIZE = 40           ;screen width of a 40-kol PET is 40 columns
SUPPORTED_Y_SIZE = 25           ;screen width of a 40-kol PET is 25 rows
endif
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ifdef COMMODOREPET80XX

;-- BUILD RELATED SETTINGS --
WINDOW_X_POS    = ?             ;the X-distance from top-left
WINDOW_Y_POS    = ?             ;the Y-distance from top-left
WINDOW_X_SIZE   = ?            ;the X-size of the window to be scrolled
WINDOW_Y_SIZE   = ?            ;the Y-size of the window to be scrolled

SUPPORTED_X_SIZE = 80           ;screen width of a 80-kol PET is 80 columns
SUPPORTED_Y_SIZE = 25           ;screen width of a 80-kol PET is 25 rows
endif
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



;-------------------------------------------------------------------------------
endif   ;this endif belongs to "ifdef COMMODOREPET20XX or COMMODOREPET30XX or COMMODOREPET40XX or COMMODOREPET80XX"
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

##{0}F:\Projects\Cassiopei\Versie_2-Wifi\Software\CBM_software\Cassiopei_v2.0-Disk_Wizard\source\\01_2_Constants_and_BasicStart.asm

;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ifdef COMMODOREVIC20
;-------------------------------------------------------------------------------

*=$1201
        ;Start address $1201, end address $1214, size 20, on 27-9-2014 10:24:15, to file %file%
        BYTE $13,$10,$01,$00,$9e,$33,$32,$aa,$32,$35,$36,$ac,$c2,$28,$34,$34,$29,$00,$00,$00
        ;End address $1214

*=$1220
        
    ;The VIC-20 is a strange beast, because it will move basic start and charscreen depending on
    ;the memory expansion placed. Therefore because the program is loaded to an (during programming)
    ;unknown loaction and may require to be relocated to the intended memory locations.

    ;This routine is started with the basic stub:
    ; 1 SYS32+256*peek(44) (32=$20, meaning that our .asm must start from $xx20)
    ;
    ;First we must check if relocation is required! So where are we now?
    ;or actually where is basic start, because if it is $1201 we are ok.
    ;
    ;To make things a little more complicated, our source and destination
    ;might overlap! Therefore in order to copy it safely to the new location
    ;(which is in the always available $12XX region) we copy from end to start (backwards)
    ;
    ;ATTENTION PROGRAMMER: relocating code can not use absolute jumps or addressing!

RELOC           LDA $2C                 ;
                CMP #$12                ;$12XX (XX is always 01 unless somebody messed with it, which is highly unlikely)
                BEQ RELOC_DONE          ;code already at the correct location

                ;program_size = END_OF_PROGRAM - INIT
                ;first byte in memory = contents of $2C + low byte of label INIT
                ;last byte in memory = first byte in memory + program_size

RELOC_REQ       LDA #<END_OF_PROGRAM    ;store destination address in zero-page variable
                STA DEST_ADR            ;===============================================
                LDA #>END_OF_PROGRAM    ;  
                STA DEST_ADR+1          ;high byte

                LDA #<INIT              ;calculate first byte of code to be relocated in memory
                STA SOURCE_ADR          ;======================================================
                LDA $2C                 ;  
                STA SOURCE_ADR+1        ;high byte

        ;------------------------------------------------------------------------------
        ;ATTENTION: make sure that the option "calc address first then high/low byte"
        ;in CBM program studio is selected. Otherwise the lines below WILL fail!!!!!!!
        ;------------------------------------------------------------------------------
                
                CLC                     ;add program size to get to the last byte
                LDA SOURCE_ADR          ;========================================
                ADC #<PRGSIZE           ;this might cause a carry that we will use in the next addition
                STA SOURCE_ADR          ;
                LDA #>PRGSIZE           ;
                ADC SOURCE_ADR+1        ;add carry to high byte (if there was any)
                STA SOURCE_ADR+1        ;

                CLV                     ;the overflow flag is not affected by any of the opcodes below, so it does not change in our loop, clearing it here keeps the loop faster
                LDY #$00                ;the Y-reg is not affected by any of the opcodes below, so it does not change in our loop, clearing it here keeps the loop smaller
RELOC_LP        LDA (SOURCE_ADR),Y      ;the actual moving of the program (the copy loop)
                STA (DEST_ADR),Y        ;================================================
                ;STA $900F  ;!DEBUG ONLY!

                LDA DEST_ADR+1          ;check if we reached the last byte that must be relocated (which is actually the first byte of our program because we are relocating backwards)
                CMP #>INIT              ;==============================================================================================================================================
                BNE RELOC_00            ;
                LDA DEST_ADR            ;low byte of last written address
                CMP #<INIT              ;
                BEQ RELOC_DONE          ;
                                                
RELOC_00        DEC SOURCE_ADR          ;calculate next addresses
                LDA SOURCE_ADR          ;
                CMP #$FF                ;
                BNE RELOC_01            ;========================
                DEC SOURCE_ADR+1        ;overflow detected, so we must also decrement high-byte
RELOC_01        DEC DEST_ADR            ;decrement low-byte
                LDA DEST_ADR            ;
                CMP #$FF                ;
                BNE RELOC_02            ;check for overflow of low byte
                DEC DEST_ADR+1          ;overflow detected, so we must also decrement high-byte
RELOC_02        ;CLV                    ;force conditional branch, we must do this because we can't
                BVC RELOC_LP            ;use an absolute jump and conditinal branches are relative jumps

RELOC_DONE      ;relocate warm-start vector
                LDA #<INIT              ;to stop the animation, use runstop+restore
                STA $0328               ;however this requires us to re-route the vector
                LDA #>INIT              ;to our own program instead of the warm-start vector
                STA $0329               ;This is the only way because the keyboard IO could interfere with the Cassiopei CPIO communication

                JMP INIT                ;code is now at the correct location, so we may start it





;;-- zeropage RAM registers --
;we use only the 0-page locations that are marked as "unused" or "free 0-page space for user programs"
CPIO_DATA       = $02   ;this zeropage memory location is used to parse the CPIO data

ADDR            = $61  ;pointer
ADDR+1          = $62  ;     
 
ADDR_LAST_TILE  = $F7  ;pointer (used in NORMAL mode, for detection of the last tile,
;ADDR_LAST_TILE+1= $F8  ;this way we don't have to keep a counter, we just compare two 16-bit values)
CNTR            = $F9  ;pointer (used in DELTA mode, since the last tile is unpredictable, this counter just counts the number of tiles
;CNTR+1          = $FA  ;until it matches the "changed tiles" value of the image)      

STR_ADDR        = $6E  ;pointer to string
;STR_ADDR+1     = $6F  ;           

SOURCE_ADR      = $F7   ;for relocation we must have a pointer (of location of source data)
;SOURCE_ADR+1   = $F8   ;
DEST_ADR        = $F9   ;for relocation we must have a pointer (of destination location)
;DEST_ADR+1     = $FA   ;

CHAR_ADDR       = $FC
;CHAR_ADDR+1    = $FD



;-- build related settings --
WINDOW_X_POS    = 0             ;the X-distance from top-left
WINDOW_Y_POS    = 5             ;the Y-distance from top-left
WINDOW_X_SIZE   = 22            ;the X-size of the window to be scrolled
WINDOW_Y_SIZE   = 10            ;the Y-size of the window to be scrolled

SUPPORTED_X_SIZE = 22           ;screen width of a VIC20 is 22 columns
SUPPORTED_Y_SIZE = 23           ;screen width of a VIC20 is 23 rows

;-------------------------------------------------------------------------------
endif   ;this endif belongs to "ifdef COMMODOREVIC20"
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

##{0}F:\Projects\Cassiopei\Versie_2-Wifi\Software\CBM_software\Cassiopei_v2.0-Disk_Wizard\source\\01_3_Constants_and_BasicStart.asm

;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ifdef COMMODORE64
;-------------------------------------------------------------------------------
*=$0801
        BYTE    $0B, $08, $0A, $00, $9E, $32, $30, $39, $36, $00, $00, $00      ; 10 SYS2096


*=$0810
PRG_IDENTIFIER
            ;'0123456789ABCDEF'
        TEXT 'disk wizard c64 ' ;this message could be valuable hint in solving a problem
        BYTE 0;end of table marker
        ;also usefull for debugging on vice, then the screen is no longer completely empty and you know that something has happened

*=$0830
PRG_START       JMP INIT        ;start the program

;-- zeropage RAM registers--
CPIO_DATA       = $02  ;this zeropage memory location is used to parse the CPIO data

ADDR            = $61  ;pointer
;ADDR+1         = $62  ;     
 
ADDR_LAST_TILE  = $63  ;pointer (used in NORMAL mode, for detection of the last tile,
;ADDR_LAST_TILE+1= $64  ;this way we don't have to keep a counter, we just compare two 16-bit values)
CNTR            = $63  ;pointer (used in DELTA mode, since the last tile is unpredictable, this counter just counts the number of tiles
;CNTR+1         = $64  ;until it matches the "changed tiles" value of the image)      

STR_ADDR        = $6E  ;pointer to string
;STR_ADDR+1     = $6F  ;           
CHAR_ADDR       = $FA
;CHAR_ADDR+1    = $FB


;-- build related settings --
WINDOW_X_POS    = 1             ;the X-distance from top-left
WINDOW_Y_POS    = 4             ;the Y-distance from top-left
WINDOW_X_SIZE   = 28            ;the X-size of the window to be scrolled
WINDOW_Y_SIZE   = 16            ;the Y-size of the window to be scrolled

SUPPORTED_X_SIZE = 40           ;screen width of a C64 is 40 columns
SUPPORTED_Y_SIZE = 25           ;screen width of a C64 is 25 rows


;location of the status line
X_POS_STATUS    = 1
Y_POS_STATUS    = 23



DEVICE          = 8             ;the device number of the disk drive
DATA_AREA       = $06D0         ;store data here (when using $0400+ for a C64, it will be in the video memory and clearly visible, usefull for debugging)
PLOT            = $FFF0

SCR_POS         = $0681         ;the location on the screen where the string will be printed
STR_POS_MAX     = 37            ;the max size of the filename (the practical limit is determined by the screen size)
;-------------------------------------------------------------------------------
endif   ;this endif belongs to "ifdef COMMODORE64"
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

##{0}F:\Projects\Cassiopei\Versie_2-Wifi\Software\CBM_software\Cassiopei_v2.0-Disk_Wizard\source\\01_4_Constants_and_BasicStart.asm

;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ifdef COMMODORE128

;ATTENTION: in order to test this code in VICE (emulators are much more practical
;========== for a quick menu look-and-feel test. It is important that you
;           use the correct autostarting settings, otherwise it WILL crash!!
;           settings -> autostarting settings -> select inject to RAM
;-------------------------------------------------------------------------------

*=$1C01 
        BYTE    $0E, $08, $0A, $00, $9E, $20, $28,  $37, $32, $31, $36, $29, $00, $00, $00      ; 10 SYS (7216)


*=$1C10
PRG_IDENTIFIER
            ;'0123456789ABCDEF'
        TEXT 'petscii player:c128' ;if the wrong menu PRG is installed onto the cassiopei, this message could be valuable hint in solving the problem
        BYTE 0;end of table marker
        ;also usefull for debugging on vice, then the screen is no longer completely empty and you know that something has happened

*=$1C30
PRG_START       JMP INIT        ;start the program


;-- zeropage RAM registers--
CPIO_DATA       = $02  ;this zeropage memory location is used to parse the CPIO data

ADDR            = $61  ;pointer
;ADDR+1         = $62  ;     
 
ADDR_LAST_TILE  = $63  ;pointer (used in NORMAL mode, for detection of the last tile,
;ADDR_LAST_TILE+1= $64  ;this way we don't have to keep a counter, we just compare two 16-bit values)
CNTR            = $63  ;pointer (used in DELTA mode, since the last tile is unpredictable, this counter just counts the number of tiles
;CNTR+1         = $64  ;until it matches the "changed tiles" value of the image)      


;COL_PRINT       = $6B  ;holds the color of the charaters printed with the PRINT_CHAR routine
;COLOR_ADDR      = $6C  ;pointer to color memory
;COLOR_ADDR+1   = $6D

STR_ADDR        = $6E  ;pointer to string
;STR_ADDR+1     = $6F  ;           
;;ADDR          = $F8  ;pointer
;;;ADDR+1       = $F9  ;      
CHAR_ADDR       = $FA
;CHAR_ADDR+1    = $FB


;-- build related settings --
WINDOW_X_POS    = 1             ;the X-distance from top-left
WINDOW_Y_POS    = 8             ;the Y-distance from top-left
WINDOW_X_SIZE   = 31            ;the X-size of the window to be scrolled
WINDOW_Y_SIZE   = 14            ;the Y-size of the window to be scrolled

SUPPORTED_X_SIZE = 40           ;screen width of a C64 is 40 columns
SUPPORTED_Y_SIZE = 25           ;screen width of a C64 is 25 rows

;-------------------------------------------------------------------------------
endif   ;this endif belongs to "ifdef COMMODORE128"
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

##{0}F:\Projects\Cassiopei\Versie_2-Wifi\Software\CBM_software\Cassiopei_v2.0-Disk_Wizard\source\\01_5_Constants_and_BasicStart.asm

;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ifdef COMMODORE16PLUS4
;-------------------------------------------------------------------------------
; 10 SYS4128

*=$1001

        BYTE        $0B, $10, $0A, $00, $9E, $34, $31, $32, $38, $00, $00, $00


*=$1010
PRG_IDENTIFIER
            ;'0123456789ABCDEF'
        TEXT 'petscii c16/+4' ;if the wrong menu PRG is installed onto the cassiopei, this message could be valuable hint in solving the problem
        BYTE 0;end of table marker
        ;also usefull for debugging on vice, then the screen is no longer completely empty and you know that something has happened

*=$1020
PRG_START       JMP INIT        ;start the program


;-- zeropage RAM registers--
;-- zeropage RAM registers--
CPIO_DATA       = $D8  ;this zeropage memory location is used to parse the CPIO data
STR_ADDR        = $D9  ;pointer to string
;STR_ADDR+1     = $DA  ;           
CHAR_ADDR       = $DB
;CHAR_ADDR+1    = $DC
ADDR            = $DE
;ADDR+1         = $DF


ADDR_LAST_TILE  = $E0  ;pointer (used in NORMAL mode, for detection of the last tile,
;ADDR_LAST_TILE+1= $E1 ;this way we don't have to keep a counter, we just compare two 16-bit values)
CNTR            = $E2  ;pointer (used in DELTA mode, since the last tile is unpredictable, this counter just counts the number of tiles
;CNTR+1         = $E3  ;until it matches the "changed tiles" value of the image)      



;-- build related settings --
WINDOW_X_POS    = 1             ;the X-distance from top-left
WINDOW_Y_POS    = 8             ;the Y-distance from top-left
WINDOW_X_SIZE   = 31            ;the X-size of the window to be scrolled
WINDOW_Y_SIZE   = 14            ;the Y-size of the window to be scrolled

SUPPORTED_X_SIZE = 40           ;screen width of a C64 is 40 columns
SUPPORTED_Y_SIZE = 25           ;screen width of a C64 is 25 rows

;-------------------------------------------------------------------------------
endif   ;this endif belongs to "ifdef COMMODORE16PLUS4"
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

##{0}F:\Projects\Cassiopei\Versie_2-Wifi\Software\CBM_software\Cassiopei_v2.0-Disk_Wizard\source\\02_0_Main.asm


;===============================================================================
;                              MAIN PROGRAM
;===============================================================================

INIT            JSR PREVENT_CASE_CHANGE ;prevent the user from using shift+CBM to change the case into lower or upper case
                JSR CLEAR_SCREEN        ;


MAIN_MENU       LDX #0                  ;build the screen
                LDY #0                  ;
                JSR SET_CURSOR          ;

;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ifdef TYPE_D64
;-------------------------------------------------------------------------------
                LDA #<SCREEN_MAIN_D64   ;set pointer to the text that defines the main-screen
                LDY #>SCREEN_MAIN_D64   ;
;-------------------------------------------------------------------------------
endif
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ifdef TYPE_D81
;-------------------------------------------------------------------------------
                LDA #<SCREEN_MAIN_D81   ;set pointer to the text that defines the main-screen
                LDY #>SCREEN_MAIN_D81   ;
;-------------------------------------------------------------------------------
endif
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

                JSR PRINT_STRING        ;the print routine is called, so the pointed text is now printed to screen         
                JSR SHOW_VERSION        ;show version info

                JSR CHOOSE              ;
                CMP #USER_INPUT_CHA     ;
                BNE NOT_MAIN_CHA        ;
                JMP MAKE_DISK           ;
NOT_MAIN_CHA    CMP #USER_INPUT_CHB     ;
                BNE NOT_MAIN_CHB        ;
                JMP MAKE_IMAGE          ;
NOT_MAIN_CHB    JMP MAIN_MENU           ;if the user pressed an invalid value, do nothing, just keep waiting for the proper key to be pressed


;###############################################################################
;                  M A K E   D I S K   f r o m   a  f i l e 
;-------------------------------------------------------------------------------
MAKE_DISK       JSR CPIO_INIT           ;initialize IO for use of CPIO protocol on the CBM's cassetteport
                JSR BROWSE_RESET        ;force the cassiopei menu to a default state

MDSK_SCREEN     LDX #0                  ;build the screen
                LDY #0                  ;
                JSR SET_CURSOR          ;
                LDA #<SCREEN_MAKE_DISK  ;set pointer to the text that defines the main-screen
                LDY #>SCREEN_MAKE_DISK  ;
                JSR PRINT_STRING        ;the print routine is called, so the pointed text is now printed to screen         
                JSR BROWSE_REFRESH      ;get the current available menu screen and print it to the screen
                JSR ERROR_MESSAGE       ;get the drive status/error message, this is usefull as we read the code 73 when it has been reset, so the next read will be 00 if all is OK, thereforer we do not need to worry about 73, as it only shows after reset once.

                ;allow user to select a file
MDSK_MENU       LDA BROWSE_STATUS       ;check if we should exit
                CMP #BROWSE_EXIT        ;exit menu (meaning that a selection has been made)
                BNE MDSK_SCANKEY        ;
                JSR RESET_DISK          ;
                JSR CREATE_DISK         ;file was selected, now create the disk
                JMP MDSK_SCREEN         ;when finished, go back to the menu to allow user to select another file

MDSK_SCANKEY
MDSK_SCANKEY_01 JSR SCAN_INPUTS         ;check keyboard and/ joysticks (if applicable)
                CMP #USER_INPUT_SELECT  ;and jump to the requested action
                BNE MDSK_SCANKEY_02     ;
                JSR BROWSE_SELECT       ;select current file
                JMP MDSK_MENU           ;

MDSK_SCANKEY_02 CMP #USER_INPUT_PREVIOUS;
                BNE MDSK_SCANKEY_03     ;
                JSR BROWSE_PREVIOUS     ;go to previous file
                JMP MDSK_MENU           ;

MDSK_SCANKEY_03 CMP #USER_INPUT_NEXT    ;
                BNE MDSK_SCANKEY_04     ;
                JSR BROWSE_NEXT         ;go to next file
                JMP MDSK_MENU           ;

MDSK_SCANKEY_04 CMP #USER_INPUT_DIR     ;
                BNE MDSK_SCANKEY_05     ;
                JSR RESET_DISK          ;
                JSR DIRECTORY           ;show directory
                JSR WAIT_FOR_KEY        ;keep screen visible until user presses key
                JMP MDSK_SCREEN         ;redraw make-disk-screen

MDSK_SCANKEY_05 CMP #USER_INPUT_EXIT    ;
                BNE MDSK_SCANKEY_06     ;
                JMP MAIN_MENU           ;exit the current screen by returning to the main screen

MDSK_SCANKEY_06 JMP MDSK_SCANKEY        ;when the pressed key has no function then continue the key scanning

                ;.......................

CREATE_DISK     ;convert the selected file into a disk
CR_DISK_TRNSFR  LDA #0                  ;reset track sector
                STA TABLE_PNTR          ;
                LDA #1                  ;
                STA TRACK               ;
                LDA #0                  ;
                STA SECTOR              ;
                LDY TABLE_PNTR          ;
                LDA TABLE_MAXSEC,Y      ;
                STA SECTOR_MAX          ;
                LDA #$0                 ;reset byte counter
                STA CNT_BYTE            ;
                LDA #CPIO_DATAFILE_OPEN ;the mode we want to operate in
                JSR CPIO_START          ;send this command so the connected device knows we now start working in this mode
                LDA #0                  ;0=read from file
                JSR CPIO_SEND           ;
                JSR CPIO_RECIEVE        ;the cassiopei responds with a 0=file-not-found, 1=file-found, do not drop attention as we want to continue loading data
                STA FILE_OPEN_STATUS    ;
                JSR CPIO_RECIEVE        ;filesize (MSB) of the opened file
                STA FILE_SIZE_03        ;
                JSR CPIO_RECIEVE        ;filesize of the opened file    
                STA FILE_SIZE_02        ;
                JSR CPIO_RECIEVE        ;filesize of the opened file
                STA FILE_SIZE_01        ;
                JSR CPIO_REC_LAST       ;filesize (LSB) of the opened file
                STA FILE_SIZE_00        ;

                LDA FILE_OPEN_STATUS    ;
                BNE CR_DISK_TRN_00      ;0=file-not-found, 1=file found
                JMP CR_DISK_EXIT        ;no sense in carying on, exit                

CR_DISK_TRN_00  LDA FILE_SIZE_02        ;
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ifdef TYPE_D64
;-------------------------------------------------------------------------------
                CMP #$02                ;$02 for 35T disks without errors, $02 for 35T disks with errors
               ;CMP #$03                ;$03 for 40T disks                
;-------------------------------------------------------------------------------
endif
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ifdef TYPE_D81
;-------------------------------------------------------------------------------
                CMP #$0C                ;this value is $0C for 80T disks without errors, $0C for 80T disks with errors
;-------------------------------------------------------------------------------
endif
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                BEQ CONFIRM_YN          ;request if user is sure (because we are about to format a disk)
                LDX #X_POS_STATUS       ;when the disk wasn't a 35Track disk
                LDY #Y_POS_STATUS       ;the we must show an error message
                JSR SET_CURSOR          ;
                LDA #<TXT_NOTSUPP       ;
                LDY #>TXT_NOTSUPP       ;
                JSR PRINT_STRING        ;
                JSR WAIT_FOR_KEY        ;keep screen visible until user presses key
                JMP CR_DISK_EXIT        ;no sense in carying on, exit

CONFIRM_YN      LDX #X_POS_STATUS       ;write the text message
                LDY #Y_POS_STATUS       ;
                JSR SET_CURSOR          ;
                LDA #<TXT_CONFIRM_YN    ;
                LDY #>TXT_CONFIRM_YN    ;
                JSR PRINT_STRING        ;the print routine is called, so the pointed text is now printed to screen   
CONFIRM_YN_LP   JSR SCAN_INPUTS         ;check keyboard and/ joysticks (if applicable)
                CMP #USER_INPUT_NO      ;
                BNE CONFIRM_YN_01       ;
                JMP CR_DISK_EXIT        ;when No, so we exit
CONFIRM_YN_01   CMP #USER_INPUT_YES     ;
                BEQ CR_DISK_FORMAT      ;when Yes, we continue
                JMP CONFIRM_YN_LP       ;


CR_DISK_FORMAT  LDX #X_POS_STATUS       ;write the text message
                LDY #Y_POS_STATUS       ;
                JSR SET_CURSOR          ;
                LDA #<TXT_FORMATTING    ;
                LDY #>TXT_FORMATTING    ;
                JSR PRINT_STRING        ;the print routine is called, so the pointed text is now printed to screen  
                JSR SLOW_FORMAT_DISK    ;before doing anything, format the disk, because otherwise it might all fail!

                JSR ERROR_MESSAGE       ;get the error message, to determine if format has finished and if it was succesful
                LDA DRIVE_STATUS        ;
                BEQ CR_DISK_FRMT_OK     ;we expect the value to be 0 and nothing else!!
                LDX #X_POS_STATUS       ;write the text message
                LDY #Y_POS_STATUS       ;
                JSR SET_CURSOR          ;
                LDA #<TXT_FORMAT_ERR    ;
                LDY #>TXT_FORMAT_ERR    ;
                JSR PRINT_STRING        ;the print routine is called, so the pointed text is now printed to screen  
                JSR WAIT_FOR_KEY        ;allow message to remain visible until keypress
                JMP CR_DISK_EXIT        ;no sense in carying on, exit

CR_DISK_FRMT_OK LDX #0                  ;formatting went perfect, now
                LDY #0                  ;we change the screen to show the progress
                JSR SET_CURSOR          ;of the data transfer
                LDA #<SCREEN_DATA       ;
                LDY #>SCREEN_DATA       ;
                JSR PRINT_STRING        ;the print routine is called, so the pointed text is now printed to screen  

                LDA TABLE_PP_BLOCK  ;this value is the stepsize for the progressbar, it is increased by this amount each time we call UPDATE_PROGRBAR
                JSR INIT_PROGRBAR       ;reset and initialize the progressbar
          
CR_DISK_TRN_01  JSR CHECK_FOR_KEY       ;allow user to abort safely
                BNE CR_DISK_EXIT        ;key pressed? then exit

                LDA #$0                 ;reset byte counter
                STA CNT_BYTE            ;
                LDA #CPIO_DATAFILE_READ ;prepare for reading
                JSR CPIO_START          ;send this command so the connected device knows we now start working in this mode

                ;get data from Cassiopei
CR_DISK_TRN_02  JSR CPIO_RECIEVE        ;get byte from the selected file
CR_DISK_TRN_03  LDY CNT_BYTE            ;
                STA DATA_AREA,Y         ;read byte from memory
                INC CNT_BYTE            ;
                LDA CNT_BYTE            ;
                CMP #$FF                ;
                BNE CR_DISK_TRN_02      ;load next byte untill 255 bytes are read
                JSR CPIO_REC_LAST       ;read the 256th byte and end communication
                LDY CNT_BYTE            ;
                STA DATA_AREA,Y         ;read byte from memory

                ;send data to drive
CR_DISK_TRN_10  LDX TRACK               ;send track
                LDY SECTOR              ;and sector information
                JSR WRITE_BLOCK         ;write data to disk
                INC SECTOR              ;increment sector counter, so that we know what to do next

                JSR UPDATE_PROGRBAR     ;increment the progressbar by the appropriate amount

                LDA SECTOR              ;
                CMP SECTOR_MAX          ;
                BNE CR_DISK_TRN_01      ;process the next sector
                
                INC TABLE_PNTR          ;all sectors processed, continue with next track
                LDY TABLE_PNTR          ;
                LDA TABLE_MAXSEC,Y      ;get max number of sector for this track
                STA SECTOR_MAX          ;

                LDA #$00                ;reset sector
                STA SECTOR              ;
                INC TRACK               ;inc. track

                ;are we ready?
                LDA TRACK_MAX           ;
                CLC                     ;
                ADC #1                  ;
                CMP TRACK               ;check if last track is processed
                BNE CR_DISK_TRN_01      ;process the next sector


CR_DISK_EXIT    LDA #CPIO_DATAFILE_CLOSE;close the file, we are done using it
                JSR CPIO_START          ;send this command so the connected device knows we now start working in this mode
                LDA #0                  ;
                JSR CPIO_SEND_LAST      ;send a dummy to close CPIO communication in a normal manor
                CLI                     ;enable interrupts again (required for keyboard readout)
                RTS                     ;



TXT_CLEAR       TEXT '                                      ';
                BYTE 0

TXT_CONFIRM_YN  TEXT 'are you sure? y/n                     ';
                BYTE 0

TXT_NOTSUPP     TEXT 'error:file not supported              ';
                BYTE 0

TXT_FORMATTING  TEXT 'formatting...                         ';
                BYTE 0

TXT_FORMAT_ERR  TEXT 'error:format failed,check disk & drive';
                BYTE 0

;###############################################################################
;           M A K E   a  f i l e   f r o m   a  r e a l   d i s k
;-------------------------------------------------------------------------------
MAKE_IMAGE      JSR CPIO_INIT           ;initialize IO for use of CPIO protocol on the CBM's cassetteport

MIMG_SCREEN     LDX #0                  ;build the screen
                LDY #0                  ;
                JSR SET_CURSOR          ;
                LDA #<SCREEN_MAKE_IMAGE ;set pointer to the text that defines the main-screen
                LDY #>SCREEN_MAKE_IMAGE ;
                JSR PRINT_STRING        ;the print routine is called, so the pointed text is now printed to screen         
                JSR SHOW_FILENAME       ;allow user to enter a filename

MIMG_MENU       
MIMG_SCANKEY
MIMG_SCANKEY_01 JSR SCAN_INPUTS         ;check keyboard and/ joysticks (if applicable)
MIMG_SCANKEY_02 CMP #USER_INPUT_DIR     ;
                BNE MIMG_SCANKEY_03     ;
                JSR DIRECTORY           ;show directory
                JSR WAIT_FOR_KEY        ;keep screen visible until user presses key
                JMP MIMG_SCREEN         ;redraw make-image-screen

MIMG_SCANKEY_03 CMP #USER_INPUT_CREATE  ;
                BNE MIMG_SCANKEY_04     ;
                JSR CREATE_IMAGE        ;
                JSR DIRECTORY           ;show directory (just a command to check if the drive is still alive)
                JMP MIMG_SCREEN         ;redraw make-image-screen

MIMG_SCANKEY_04 CMP #USER_INPUT_EXIT    ;
                BNE MIMG_SCANKEY_05     ;
                JMP MAIN_MENU           ;exit the current screen by returning to the main screen

MIMG_SCANKEY_05 CMP #USER_INPUT_FILENAME;
                BNE MIMG_SCANKEY_06     ;
                JSR ENTER_FILENAME      ;allow user to enter a filename
                JMP MIMG_SCREEN         ;redraw make-image-screen

MIMG_SCANKEY_06 JMP MIMG_SCANKEY_01     ;when the pressed key has no function then continue the key scanning

                ;........................

CREATE_IMAGE    ;create a D64 image from a real disk
                LDA TABLE_PP_BLOCK  ;this value is the stepsize for the progressbar, it is increased by this amount each time we call UPDATE_PROGRBAR
                JSR INIT_PROGRBAR       ;reset and initialize the progressbar

                ;send the filename
                LDA #CPIO_PARAMETER     ;the mode we want to operate in
                JSR CPIO_START          ;send this command so the connected device knows we now start working in this mode
                LDA #0                  ;
                STA STR_POS             ;
CR_IMAGE_00     LDY STR_POS             ;
                LDA STR_MEM,Y           ;
                BEQ CR_IMAGE_02         ;end of string detected?
                JSR CPIO_SEND           ;
                INC STR_POS             ;
                LDY STR_POS             ;
                CPY #STR_POS_MAX        ;
                BEQ CR_IMAGE_02         ;max length of string reached?
                JMP CR_IMAGE_00         ;
CR_IMAGE_02     LDA #0                  ;send end of string terminator
                JSR CPIO_SEND_LAST      ;

CR_IMAGE_03     LDA #CPIO_DATAFILE_OPEN ;the mode we want to operate in
                JSR CPIO_START          ;send this command so the connected device knows we now start working in this mode
                LDA #1                  ;1=write to file
                JSR CPIO_SEND           ;
                JSR CPIO_RECIEVE        ;the cassiopei responds with a 0=file-not-found, 1=file-found, do not drop attention as we want to continue loading data
                STA FILE_OPEN_STATUS    ;
                JSR CPIO_RECIEVE        ;filesize (MSB) of the opened file (although we are not even using it, it doesn't hurt to read it)
                STA FILE_SIZE_03        ;
                JSR CPIO_RECIEVE        ;filesize of the opened file
                STA FILE_SIZE_02        ;
                JSR CPIO_RECIEVE        ;filesize of the opened file
                STA FILE_SIZE_01        ;
                JSR CPIO_REC_LAST       ;filesize (LSB) of the opened file
                STA FILE_SIZE_00        ;
                CLI                     ;enable interrupts again (required for keyboard readout) (this may come in handy when asking Y/N to overwrite)

                LDA FILE_OPEN_STATUS    ;
                CMP #1                  ;
                BEQ CR_IMAGE_07         ;1=file opened, ready for writing
                CMP #2                  ;
                BEQ CR_IMAGE_04         ;2=file opened, ready to overwrite existing file
               ;CMP #0                  ;when 0 (or anything else, there is a real problem)
               ;BNE ...                 ;0=could not open file for writing
                LDX #X_POS_STATUS       ;write the text message
                LDY #Y_POS_STATUS       ;
                JSR SET_CURSOR          ;
                LDA #<TXT_FOPEN_ERROR   ;
                LDY #>TXT_FOPEN_ERROR   ;
                JSR PRINT_STRING        ;the print routine is called, so the pointed text is now printed to screen   
                JSR WAIT_FOR_KEY        ;keep screen visible until user presses key
                JMP CR_IMAGE_EXIT       ;no sense in carying on, exit           

CR_IMAGE_04     LDX #X_POS_STATUS       ;write the text message
                LDY #Y_POS_STATUS       ;
                JSR SET_CURSOR          ;
                LDA #<TXT_OVERWRITE_YN  ;
                LDY #>TXT_OVERWRITE_YN  ;
                JSR PRINT_STRING        ;the print routine is called, so the pointed text is now printed to screen   

CR_IMAGE_05     JSR SCAN_INPUTS         ;check keyboard and/ joysticks (if applicable)
                CMP #USER_INPUT_YES     ;
                BEQ CR_IMAGE_07         ;when Yes, we continue
                CMP #USER_INPUT_NO      ;
                BNE CR_IMAGE_05         ;
                JMP CR_IMAGE_EXIT       ;no sense in carying on, exit 
                
CR_IMAGE_07     LDX #0                  ;
                LDY #0                  ;
                JSR SET_CURSOR          ;
                LDA #<SCREEN_DATA       ;
                LDY #>SCREEN_DATA       ;
                JSR PRINT_STRING        ;the print routine is called, so the pointed text is now printed to screen  

                LDA #0                  ;reset track sector
                STA TABLE_PNTR          ;
                LDA #1                  ;
                STA TRACK               ;
                LDA #0                  ;
                STA SECTOR              ;
                LDY TABLE_PNTR          ;
                LDA TABLE_MAXSEC,Y      ;
                STA SECTOR_MAX          ;             

                ;get data from the drive
CR_IMAGE_10     JSR CHECK_FOR_KEY       ;allow user to abort safely
                BNE CR_IMAGE_EXIT       ;key pressed? then exit

                LDX TRACK               ;send track
                LDY SECTOR              ;and sector information
                JSR READ_BLOCK          ;read data from disk

                ;send the data to the Cassiopei
CR_IMAGE_20     LDA #$0                 ;reset byte counter
                STA CNT_BYTE            ;
                LDA #CPIO_DATAFILE_WRITE;the mode we want to operate in
                JSR CPIO_START          ;send this command so the connected device knows we now start working in this mode
CR_IMAGE_21     LDY CNT_BYTE            ;
                LDA DATA_AREA,Y         ;read byte from memory
                JSR CPIO_SEND           ;send data to Cassiopei
                INC CNT_BYTE            ;
                LDA CNT_BYTE            ;
                CMP #$FF                ;
                BNE CR_IMAGE_21         ;       
                LDY CNT_BYTE            ;
                LDA DATA_AREA,Y         ;read byte from memory
                JSR CPIO_SEND_LAST      ;send last byte (of this data block) to the Cassiopei

                JSR UPDATE_PROGRBAR     ;increment the progressbar by the appropriate amount

                INC SECTOR              ;increment sector counter, so that we know what to do next
                LDA SECTOR              ;
                CMP SECTOR_MAX          ;
                BNE CR_IMAGE_10         ;process the next sector                
                INC TABLE_PNTR          ;all sectors processed, continue with next track
                LDY TABLE_PNTR          ;
                LDA TABLE_MAXSEC,Y      ;get max number of sector for this track
                STA SECTOR_MAX          ;

                LDA #$00                ;reset sector
                STA SECTOR              ;
                INC TRACK               ;inc. track

                LDA TRACK_MAX           ;
                CLC                     ;
                ADC #1                  ;
                CMP TRACK               ;check if last track is processed
                BNE CR_IMAGE_10         ;process the next sector

CR_IMAGE_EXIT
CR_IMAGE_30     LDA #CPIO_DATAFILE_CLOSE;close the file, we are done using it
                JSR CPIO_START          ;send this command so the connected device knows we now start working in this mode
                LDA #0                  ;
                JSR CPIO_SEND_LAST      ;send a dummy to close CPIO communication in a normal manor
                CLI                     ;enable interrupts again (required for keyboard readout)
                RTS                     ;



TXT_OVERWRITE_YN        TEXT 'file exists, overwrite file? y/n      ';
                        BYTE 0

TXT_FOPEN_ERROR         TEXT 'sd-error, could not create file       ';
                        BYTE 0

;===============================================================================
;                             - = SUBROUTINES = -
;===============================================================================

;this routine will print the current filename string to screen
SHOW_FILENAME   LDA #STR_POS_MAX                ;
                STA STR_POS                     ;
SHOW_FNAME_01   LDY STR_POS                     ;
                LDA STR_MEM,Y                   ;
                JSR CONVERT_TO_SCREENCODES      ;convert ASCII to screencodes otherwise it looks like #@#$@$#
                LDY STR_POS                     ;
                STA SCR_POS,Y                   ;print value to screen
                DEC STR_POS                     ;
                LDA STR_POS                     ;
                CMP #$FF                        ;
                BNE SHOW_FNAME_01               ;                
                RTS                             ;
                
;. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

;this routine allows the user to input a filename
;it is shows on screen (SCR_POS) using the screencodes but stored in memory (STR_MEM) as ASCII

ENTER_FILENAME  
                
STRING_SEEK_END LDY #$FF                ;position cursor at the end of the text
STRING_SEEK_01  INY                     ;the end of the string is value 0
                LDA STR_MEM,Y           ;so in a loop we scan through the
                BNE STRING_SEEK_01      ;string searching for value 0
                STY STR_POS             ;

;STRING_CLEAR    LDY #STR_POS_MAX        ;reset the string
;STRING_CLEAR_01 LDA #' '                ;
;                STA SCR_POS,Y           ;
;                LDA #0                  ;by filling the string with terminator characters we do no need to worry about it when we detect a <cr> on input
;                STA STR_MEM,Y           ;
;                DEY                     ;
;                CPY #$FF                ;
;                BNE STRING_CLEAR_01     ;                
;                LDA #0                  ;
;                STA STR_POS             ;

STRING_INPUT    LDY STR_POS             ;
                LDA #100                ;show a cursor like character on the screen
                STA SCR_POS,Y           ;
                JSR WAIT_KEY_RELEASE    ;prevent key repeat by waiting for release
                JSR WAIT_FOR_KEY        ;
                LDA KEYBUF              ;
                AND #%01111111          ;only use the lowest 7 bits (we must discard all possible inverted char shit)
                CMP #13                 ;check for cr (a.k.a. "enter", a.k.a. "return")
                BEQ STRING_INP_DONE     ;
                CMP #20                 ;check for delete (a.k.a. "backspace")
                BEQ STRING_INP_DEL      ;

                LDY STR_POS             ;
                STA STR_MEM,Y           ;

                JSR CONVERT_TO_SCREENCODES    ;convert ASCII to screencodes otherwise it looks like #@#$@$#
                LDY STR_POS             ;
                STA SCR_POS,Y           ;

                LDY STR_POS             ;
                CPY #STR_POS_MAX        ;
                BEQ STRING_INPUT        ;max position reached (so skip increment)
                INC STR_POS             ;MAX not reached, "cursor" to next char pos
                JMP STRING_INPUT        ;

STRING_INP_DEL  LDY STR_POS             ;
                LDA #' '                ;replace the cursor by a space, otherwise we leave a trail of cursors
                STA SCR_POS,Y           ;
                LDA STR_POS             ;
                BEQ STRING_INP_D02      ;string cannot be deleletd any further
STRING_INP_D01  DEC STR_POS             ;MAX not reached, "cursor" to next char pos
                LDY STR_POS             ;
                LDA #' '                ;remove character by printing a space
                STA SCR_POS,Y           ;
                LDA #0                  ;by filling the string with terminator characters we do no need to worry about it when we detect a <cr> on input
                STA STR_MEM,Y           ;                
STRING_INP_D02  JMP STRING_INPUT        ;

STRING_INP_DONE RTS                     ;return to caller

;-------------------------------------------------------------------------------
;Call the corresponding menu function below and it will be printed to the screen
;-------------------------------------------------------------------------------

BROWSE_REFRESH  LDA #CPIO_BROWSE_REFRESH;Refresh: will only get the menu information from the Cassiopei's screen buffer
                STA BROWSE_ACTION       ;store the menu action to memory
                JMP BROWSE_00           ;

BROWSE_PREVIOUS LDA #CPIO_BROWSE_PREVIOUS;Previous: will perform a previous action in the menu, scolling the items down (or moving the indicator up)
                STA BROWSE_ACTION       ;store the menu action to memory
                JMP BROWSE_00           ;

BROWSE_SELECT   LDA #CPIO_BROWSE_SELECT ;Select: will perform a selection of the currently selected menu item
                STA BROWSE_ACTION       ;store the menu action to memory
                JMP BROWSE_00           ;

BROWSE_NEXT     LDA #CPIO_BROWSE_NEXT   ;Next: will perform a next action in the menu, scolling the items up (or moving the indicator down)
                STA BROWSE_ACTION       ;store the menu action to memory
                JMP BROWSE_00           ;

BROWSE_RESET    LDA #CPIO_BROWSE_RESET  ;Reset the menu, forcing it to the beginning state
                STA BROWSE_ACTION       ;store the menu action to memory
                LDA #CPIO_BROWSE        ;send directory read command
                JSR CPIO_START          ;
                LDA BROWSE_ACTION       ;get the menu action from memory                
                JSR CPIO_SEND           ;send the menu action to the Cassiopei
                LDA #WINDOW_X_SIZE      ;send the size of the visble screen area
                JSR CPIO_SEND           ;on the CBM computer
                LDA #WINDOW_Y_SIZE      ;
                JSR CPIO_SEND           ;
                JSR CPIO_REC_LAST       ;get the menu status byte
                STA BROWSE_STATUS       ;the status byte indicates wheter or not the menu is still active, because the user might have select exit
                CLI                     ;allow interrupts (usefull for keyboard and other things)
                RTS                     ;

;...............................................................................

BROWSE_00       LDA #WINDOW_X_POS       ;the location of the first character of the info on the screen
                STA BROWSE_CURX         ;
                LDA #WINDOW_Y_POS       ;
                STA BROWSE_CURY         ;

                LDA #WINDOW_Y_SIZE      ;the number of characters we will (may) display on a single line
                STA BROWSE_MAXY         ;
                LDA #CPIO_BROWSE        ;send directory read command
                JSR CPIO_START          ;
                LDA BROWSE_ACTION       ;get the menu action from memory
                JSR CPIO_SEND           ;send the menu action to the Cassiopei
                LDA #WINDOW_X_SIZE      ;send the size of the visble screen area
                JSR CPIO_SEND           ;on the CBM computer
                LDA #WINDOW_Y_SIZE      ;
                JSR CPIO_SEND           ;
                JSR CPIO_RECIEVE        ;get the menu status byte
                STA BROWSE_STATUS       ;the status byte indicates whether or not the menu is still active, because the user might have select exit

BROWSE_03       LDA #WINDOW_X_SIZE      ;the max length of a file name
                STA BROWSE_MAXX         ;
                LDX BROWSE_CURX         ;
                LDY BROWSE_CURY         ;
                JSR SET_CURSOR          ;

BROWSE_04       LDA BROWSE_MAXX         ;check if this is the last byte that should be drawn on this line
                CMP #1                  ;
                BEQ BROWSE_05           ;
                JSR CPIO_RECIEVE        ;get byte from Cassiopei containing the screen data
                JMP BROWSE_07           ;
BROWSE_05       LDA BROWSE_MAXY         ;check if this REALLY is the last byte we will be reading (regarding this command)
                CMP #1                  ;
                BEQ BROWSE_06           ;
                JSR CPIO_RECIEVE        ;get byte from Cassiopei containing the screen data
                JMP BROWSE_07           ;
BROWSE_06       JSR CPIO_REC_LAST       ;last byte before communication stops

BROWSE_07       JSR PRINT_CHAR          ;character is printed to screen, cursor is incremented by one
                DEC BROWSE_MAXX         ;keep looping untill we have processed the full width of the text area
                BNE BROWSE_04           ;

BROWSE_08       INC BROWSE_CURY         ;the next entry will be written on the next line in the directory text area
                DEC BROWSE_MAXY         ;keep looping untill we have processed the full length of the text area
                BNE BROWSE_03           ;
                
BROWSE_END      CLI                     ;CPIO communication has disabled interrupts, so we must enable interrupts again. Otherwise the keyboard is not scanned etc.
                RTS                     ;

;===============================================================================

;;-------------------------------------------------------------------------------
;ERROR_FILENOTFOUND
;                LDX #$1                 ;chars from the top of the defined screen area
;                LDY #$1                 ;chars from the left of the defined screen area
;                JSR SET_CURSOR          ;
;                LDA #<TXT_NOTFOUND      ;set pointer to the text
;                LDY #>TXT_NOTFOUND      ;
;                JSR PRINT_STRING        ;the print routine is called, so the pointed text is now printed to screen
;                JMP ERROR_PRESSKEY      ;
;                RTS                     ;

;                    ;'--------------------'
;TXT_NOTFOUND    TEXT 'file not found      '
;                BYTE 0

;;...............................................................................
;ERROR_NOT_VIDEOFILE
;                LDX #$1                 ;chars from the top of the defined screen area
;                LDY #$1                 ;chars from the left of the defined screen area
;                JSR SET_CURSOR          ;
;                LDA #<TXT_NOTVIDEO      ;set pointer to the text
;                LDY #>TXT_NOTVIDEO      ;
;                JSR PRINT_STRING        ;the print routine is called, so the pointed text is now printed to screen
;                JMP ERROR_PRESSKEY      ;
;                RTS                     ;

;                    ;'--------------------'
;TXT_NOTVIDEO    TEXT 'file not video      '
;                BYTE 0

;;...............................................................................
;ERROR_NOTSUPPORTED
;                LDX #$1                 ;chars from the top of the defined screen area
;                LDY #$1                 ;chars from the left of the defined screen area
;                JSR SET_CURSOR          ;
;                LDA #<TXT_FILEVERSION   ;set pointer to the text
;                LDY #>TXT_FILEVERSION   ;
;                JSR PRINT_STRING        ;the print routine is called, so the pointed text is now printed to screen
;                LDA FILETYPE            ;
;                JSR PRINT_HEX           ;
;                JMP ERROR_PRESSKEY      ;
;                RTS                     ;
;                    ;'--------------------'
;TXT_FILEVERSION TEXT 'no supp. for vers:' ;string is 2 chars shorter because version value also takes 2 character position
;                BYTE 0

;;...............................................................................
;ERROR_WRONGSIZE
;                LDX #$1                 ;chars from the top of the defined screen area
;                LDY #$1                 ;chars from the left of the defined screen area
;                JSR SET_CURSOR          ;
;                LDA #<TXT_NOTSUPP       ;set pointer to the text
;                LDY #>TXT_NOTSUPP       ;
;                JSR PRINT_STRING        ;the print routine is called, so the pointed text is now printed to screen

;                LDA X_SIZE              ;
;                JSR PRINT_DEC           ;the print routine is called
;                LDA #<TXT_TIMES         ;set pointer to the text
;                LDY #>TXT_TIMES         ;
;                JSR PRINT_STRING        ;the print routine is called, so the pointed text is now printed to screen
;                LDA Y_SIZE              ;
;                JSR PRINT_DEC           ;the print routine is called
;                LDA #<TXT_FILL          ;set pointer to the text
;                LDY #>TXT_FILL          ;
;                JSR PRINT_STRING        ;the print routine is called, so the pointed text is now printed to screen
;                JMP ERROR_PRESSKEY      ;
;                RTS                     ;

;                    ;'can't show 000x000---'
;TXT_NOTSUPP     TEXT 'can't show '
;                BYTE 0

;TXT_TIMES       TEXT 'x'
;                BYTE 0

;TXT_FILL        TEXT '   '
;                BYTE 0

;;...............................................................................
;ERROR_PRESSKEY  LDX #$1                 ;chars from the top of the defined screen area
;                LDY #$2                 ;chars from the left of the defined screen area
;                JSR SET_CURSOR          ;
;                LDA #<TXT_PRESSANYKEY   ;set pointer to the text
;                LDY #>TXT_PRESSANYKEY   ;
;                JSR PRINT_STRING        ;the print routine is called, so the pointed text is now printed to screen
;                JSR WAIT_FOR_KEY        ;wait for user to confirm
;                RTS
;                    ;'--------------------'
;TXT_PRESSANYKEY TEXT 'press key to cont.  '
;                BYTE 0

;-------------------------------------------------------------------------------
;call this routine as described below:
;
;        LDA #<label                ;set pointer to the text that defines the main-screen
;        LDY #>label                ;
;        JSR PRINT_STRING        ;the print routine is called, so the pointed text is now printed to screen
;
; JSR PRINT_CUR_STR ;print the string as indicated by the current string pointer
;...............................................................................
PRINT_STRING    STA STR_ADDR            ;
                STY STR_ADDR+1          ;
PRINT_CUR_STR   LDY #$00                ;
                LDA (STR_ADDR),Y        ;read character from string
                BEQ PR_STR_END          ;when the character was 0, then the end of string marker was detected and we must exit
                JSR PRINT_CHAR          ;print char to screen
                                     
                CLC                     ;
                LDA #$01                ;add 1
                ADC STR_ADDR            ;
                STA STR_ADDR            ;string address pointer
                LDA #$00                ;
                ADC STR_ADDR+1          ;add carry...
                STA STR_ADDR+1          ;                            

                JMP PRINT_CUR_STR       ;repeat...

PR_STR_END      RTS                     ;


;-------------------------------------------------------------------------------
;call this routine as described below:
;
;       LDA #<label             ;set pointer to the first string in a table of strings
;       LDY #>label             ;set pointer to the first string in a table of strings
;       LDX #string_number      ;select the Xth string from the table of strings
;       JSR PRINT_XTH_STR       ;sets the address pointer to the adress of Xth string after the string as pointed to as indicated
;
;
;the table consists of string that all end with 0
;example:
;  BYTE 'MENU OPTION-A                 ',0      ;
;  BYTE 'MENU OPTION-B                 ',0      ;
;  BYTE 'MENU OPTION-C                 ',0      ;
;-------------------------------------------------------------------------------
PRINT_XTH_STR   STA STR_ADDR            ;
                STY STR_ADDR+1          ;
                TXA                     ;check if X=0
                BEQ SET_PR_STR_END      ;when X=0 then we've allready have the correct pointer value and we're done
SET_PR_STR_01   JSR PRINT_XTH_INCA      ;increment address by one
                LDY #$00                ;
                LDA (STR_ADDR),Y        ;read character from string
                BEQ SET_PR_STR_02       ;when the character was 0, then the end of string marker was detected          
                JMP SET_PR_STR_01       ;repeat until end of string reached
SET_PR_STR_02   DEX                     ;decrement string index counter
                BNE SET_PR_STR_01       ;keep looping until we reached the string we want
                JSR PRINT_XTH_INCA      ;increment address by one (we want to point to the first character of the next table entry, we are now pointing to the end of line marker)
SET_PR_STR_END  JMP PRINT_CUR_STR       ;print the string

PRINT_XTH_INCA  CLC                     ;
                LDA #$01                ;increment the pointer to the string by one in order to get the next char/value
                ADC STR_ADDR            ;add 1
                STA STR_ADDR            ;string address pointer
                LDA #$00                ;add 0 + carry of the previous result
                ADC STR_ADDR+1          ;meaning that if we have an overflow, the must increment the high byte
                STA STR_ADDR+1          ;  
                RTS

;-------------------------------------------------------------------------------
; this routine will print the value in A as a 2 digit hexadecimal value
;        LDA #value                      ;A-register must contain value to be printed
;        JSR PRINT_HEX     ;the print routine is called
;...............................................................................
PRINT_HEX       PHA                     ;save A to stack
                AND #$F0                ;mask out low nibble
                LSR A                   ;shift to the right
                LSR A                   ;
                LSR A                   ;
                LSR A                   ;
                TAX                     ;
                LDA HEXTABLE,X          ;convert using table                                 
                JSR PRINT_CHAR          ;print character to screen

                PLA                     ;retrieve A from stack
                AND #$0F                ;mask out high nibble
                TAX                     ;
                LDA HEXTABLE,X          ;convert using table                                 
                JSR PRINT_CHAR          ;print character to screen
 
                RTS                     ;

HEXTABLE        TEXT '0123456789abcdef'                 

;-------------------------------------------------------------------------------
; this routine will print the value in A as a 3 digit decimal value
;        LDA #value        ;Y-register must contain value to be printed
;        JSR PRINT_DEC     ;the print routine is called
;
;Converts .A to 3 ASCII/PETSCII digits: .Y = hundreds, .X = tens, .A = ones
;...............................................................................
PRINT_DEC       LDY #$2f                ;
                LDX #$3a                ;
                SEC                     ;
DEC_01          INY                     ;
                SBC #100                ;
                BCS DEC_01              ;

DEC_02          DEX                     ;
                ADC #10                 ;
                BMI DEC_02              ;
        
                ADC #$2f                ;
                PHA                     ;save A to stack

                TYA                     ;transfer value to A for printing
                JSR PRINT_CHAR          ;print 100's

                TXA                     ;transfer value to A for printing
                JSR PRINT_CHAR          ;print 10's

                PLA                     ;retrieve saved A from stack for printing
                JSR PRINT_CHAR          ;print 1's

                RTS                     ;


;===============================================================================
;Force to drive to reset the disk related info, because otherwise the old info
;from RAM is used, meaning we see the worng disk header after we written a new
;image to the disk. Or formatting will be skipped because the disk is already
;formated or whatever
;The BASIC equiv: OPEN15,8,15,"IO":CLOSE15
;-------------------------------------------------------------------------------
RESET_DISK      LDA #resetdisk_end-resetdisk
                LDX #<resetdisk
                LDY #>resetdisk
                JSR $FFBD               ;call SETNAM

                LDA #1                  ;filenumber
                LDX #DEVICE             ;the device number of the drive
                LDY #15                 ;secondary address 15 (required for formatting?)
                JSR $FFBA               ;call SETLFS

                JSR $FFC0               ;call OPEN
                BCS RESET_DISK_ERR      ;quit if OPEN failed
                JMP RESET_DISK_EXIT     ;


RESET_DISK_ERR  ; Akkumulator contains BASIC error code. Most likely error: A = $05 (DEVICE NOT PRESENT)
                ;add you error handling code here

RESET_DISK_EXIT LDA #1                  ;filenumber
                JSR $FFC3               ;call CLOSE
                JSR $FFCC               ;call CLRCHN
                RTS                     ;

resetdisk       BYTE $49,$30    ; "I0"
resetdisk_end   BYTE 0          ; end of table marker

;===============================================================================
;Format a disk using the standard Commodore routines, slow but effective
;and very likely to work on all the different kind of commodore drives
;The BASIC equiv: OPEN15,8,15,"N:EMPTY,00":CLOSE15
;-------------------------------------------------------------------------------
SLOW_FORMAT_DISK

;                LDX #$00                ;a small text printing loop to show what we are sending to the drive, for debugging purposes only
;FORMAT_DBG_LOOP LDA formatname,X        ;
;                BEQ FORMAT_DBG_EXIT     ;exit when end-of-table marker is found
;                JSR $FFD2               ;call CHROUT
;                INX                     ;
;                JMP FORMAT_DBG_LOOP     ;
;FORMAT_DBG_EXIT
 
                LDA #formatname_end-formatname
                LDX #<formatname
                LDY #>formatname
                JSR $FFBD               ;call SETNAM

                LDA #1                  ;filenumber
                LDX #DEVICE             ;the device number of the drive
                LDY #15                 ;secondary address 15 (required for formatting?)
                JSR $FFBA               ;call SETLFS

                JSR $FFC0               ;call OPEN
                BCS FORMAT_ERROR        ;quit if OPEN failed
                JMP FORMAT_EXIT         ;

FORMAT_ERROR    ; Akkumulator contains BASIC error code. Most likely error: A = $05 (DEVICE NOT PRESENT)
                ;add you error handling code here

FORMAT_EXIT     LDA #1          ;filenumber
                JSR $FFC3       ;call CLOSE
                JSR $FFCC       ;call CLRCHN
                RTS             ;

formatname      BYTE $4E,$30,$3A,$45,$4D,$50,$54,$59,$2C,$30,$30    ; "N0:EMPTY,00"
formatname_end  BYTE 0                                          ; end of table marker

;===============================================================================
;Read the directory (and print to screen)
;
;source: http://codebase64.org/doku.php?id=base:reading_the_directory
;-------------------------------------------------------------------------------
DIRECTORY       JSR CLEAR_SCREEN ;clear the screen so there is room for the directory

                LDX #0          ;
                LDY #0          ;
                CLC             ;set cursor position
                JSR PLOT        ;set the X and Y coordinate for CHROUT
                LDA #01         ;white
                STA $0286       ;Current Character Color Code
                LDA #00         ;black
                STA $0287       ;Background Color Under Cursor

                LDA #dirname_end-dirname
                LDX #<dirname
                LDY #>dirname
                JSR $FFBD       ;call SETNAM

                LDA #2          ;filenumber 2
                LDX #DEVICE     ;the device number of the drive
                LDY #0          ;secondary address 0 (required for dir reading!)
                JSR $FFBA       ;call SETLFS

                JSR $FFC0       ;call OPEN (open the directory)
                BCS DIR_ERROR   ;quit if OPEN failed

                LDX #2          ;filenumber 2
                JSR $FFC6       ;call CHKIN

                LDY #4          ;skip 4 bytes on the first dir line
                BNE DIR_SKIP    ;
DIR_NEXT        LDY #2          ;skip 2 bytes on all other lines
DIR_SKIP        JSR DIR_GETBYTE ;get a byte from dir and ignore it
                DEY             ;
                BNE DIR_SKIP    ;

                JSR DIR_GETBYTE ;get low byte of basic line number
                TAY             ;
                JSR DIR_GETBYTE ;get high byte of basic line number
                PHA             ;
                TYA             ;transfer Y to X without changing Akku
                TAX             ;
                PLA             ;
                JSR $BDCD       ;print basic line number
                LDA #$20        ;print a space first

DIR_GETCHAR     JSR $FFD2       ;call CHROUT (print character)
                JSR DIR_GETBYTE ;
                BNE DIR_GETCHAR ;continue until end of line

                LDA #$0D        ;
                JSR $FFD2       ;print RETURN
                JSR $FFE1       ;RUN/STOP pressed?
                BNE DIR_NEXT    ;no RUN/STOP -> continue

DIR_ERROR       ; Akkumulator contains BASIC error code. Most likely error: A = $05 (DEVICE NOT PRESENT)
DIR_EXIT        LDA #2          ;filenumber 2
                JSR $FFC3       ;call CLOSE
                JSR $FFCC       ;call CLRCHN
                RTS             ;

DIR_GETBYTE     JSR $FFB7       ;call READST (read status byte)
                BNE DIR_END     ;read error or end of file
                JMP $FFCF       ;call CHRIN (read byte from directory)
DIR_END         PLA             ;don't return to dir reading loop
                PLA             ;

                JMP DIR_EXIT    ;

dirname         BYTE $24                ; $24 = $ (filename used to access directory)
dirname_end     BYTE 0                  ; end of table marker

;===============================================================================
;Read the error code (and print message to screen)
;
;source: http://codebase64.org/doku.php?id=base:reading_the_error_channel_of_a_disk_drive
;-------------------------------------------------------------------------------
ERROR_MESSAGE   LDA #$FF         ;set drive status to failure value
                STA DRIVE_STATUS ;usefull in case we exit early because of, for example, drive not found       

                LDY #X_POS_STATUS       ;Y holds the column value
                LDX #Y_POS_STATUS       ;X holds the row value
                CLC                     ;set cursor position to row & columnm
                JSR PLOT        ;set the X and Y coordinate for CHROUT
                LDA #01         ;white
                STA $0286       ;Current Character Color Code
                LDA #00         ;black
                STA $0287       ;Background Color Under Cursor

                LDA #$00        ;
                STA $90         ;clear STATUS flags

                LDA #DEVICE     ;the device number of the drive
                JSR $FFB1       ;call LISTEN
                LDA #$6F        ;secondary address 15 (command channel) (Note:$6F is not a typo, this is correct)
                JSR $FF93       ;call SECLSN (SECOND)
                JSR $FFAE       ;call UNLSN
                LDA $90         ;get STATUS flags
                BNE ER_ERROR    ;device not present

                LDA #DEVICE     ;the device number of the drive
                JSR $FFB4       ;call TALK
                LDA #$6F        ;secondary address 15 (error channel) (Note:$6F is not a typo, this is correct)
                JSR $FF96       ;call SECTLK (TKSA)

ER_1ST_CHAR     LDA $90         ;get STATUS flags
                BNE ER_MSG_END  ;either EOF or error
                JSR $FFA5       ;call IECIN (get byte from IEC bus)
                PHA             ;save value
                JSR $FFD2       ;call CHROUT (print byte to screen)
                PLA             ;
                SEC             ;set carry for subtraction
                SBC #'0'        ;by removing the offset i the charset, we get the value of the character (though we must be sure we are working with a number)
                STA DRIVE_STATUS;
;                ASL DRIVE_STATUS;move the value to the left nibble
;                ASL DRIVE_STATUS;
;                ASL DRIVE_STATUS;
;                ASL DRIVE_STATUS;
;
;ER_2ND_CHAR     LDA $90         ;get STATUS flags
;                BNE ER_MSG_END  ;either EOF or error
;                JSR $FFA5       ;call IECIN (get byte from IEC bus)
;                JSR $FFD2       ;call CHROUT (print byte to screen)

ER_MSGLP        LDA $90         ;get STATUS flags
                BNE ER_MSG_END  ;either EOF or error
                JSR $FFA5       ;call IECIN (get byte from IEC bus)
                JSR $FFD2       ;call CHROUT (print byte to screen)
                JMP ER_MSGLP    ;next byte

ER_MSG_END      JSR $FFAB       ;call UNTLK
                RTS             ;

ER_ERROR        LDX #0          ;
ER_ERROR_LP     LDA TXT_DEV_NOT_PRESENT,X
                BEQ ER_ERROR_EXIT
                JSR $FFD2       ;call CHROUT (print byte to screen)                
                INX             ;
                JMP ER_ERROR_LP ;
ER_ERROR_EXIT   RTS             ;... device not present handling ...



TXT_DEV_NOT_PRESENT     TEXT "drive #8 not found" ;we use " because we are printing with CHROUT, if we'd use our own print routine we would be using ' to mark the text
                        BYTE 0

DRIVE_STATUS    BYTE $00        



;-------------------------------------------------------------------------------
;this routine will initialize the progressbar
;example:
;               LDA TABLE_PP_BLOCK      ;increment bar by the appropriate amount
;               JSR INIT_PROGRBAR       ;reset and initialize the progressbar
;...............................................................................

INIT_PROGRBAR   STA PRGBAR_STEP         ;
                LDA #0                  ;
                STA PRGBAR_L            ;reset progresbar to 0
                STA PRGBAR_H            ;

                RTS                     ;return to caller

;-------------------------------------------------------------------------------
;this routine will update the progressbar
;example:
;               JSR UPDATE_PROGRBAR     ;increment the progressbar by the appropriate amount
;...............................................................................

UPDATE_PROGRBAR STA PRGBAR_TMP          ;save requested bar value
                JSR SET_CURSOR          ;set cursor to first position of the bar (user has specified the position using X and Y registers)
                ;update progressbar
                CLC                     ;clear carry, so that we can use it later for the low-byte overflow
                LDA PRGBAR_STEP         ;increment bar by the appropriate amount
                ADC PRGBAR_L            ;
                STA PRGBAR_L            ;
                LDA #0                  ;add the carry caused by the overflow of the low byte
                ADC PRGBAR_H            ;
                STA PRGBAR_H            ;
                ;LDA PRGBAR_H           ;we send the value in the high byte
                LDX #5                  ;the first position of the bar on the screen (row)
                LDY #9                  ;the first position of the bar on the screen (column)
                ;from here we roll straight into DRAW_PROGRBAR

;-------------------------------------------------------------------------------
;this routine will draw a progressbar made up entirely from PETSCII characters
;example:
;               LDA PRGBAR              ;the value of the progressbar ($00=0%, $FF=100%)
;               LDX #5                  ;the first position of the bar on the screen (row)
;               LDY #9                  ;the first position of the bar on the screen (column)
;               JSR DRAW_PROGRBAR       ;
;...............................................................................

DRAW_PROGRBAR   STA PRGBAR_TMP          ;save requested bar value
                JSR SET_CURSOR          ;set cursor to first position of the bar (user has specified the position using X and Y registers)

;debug only (show the high and low byte before printing)
;        LDX #0                  ;build the screen
;        LDY #0                  ;
;        JSR SET_CURSOR          ;
;        LDA PRGBAR_H            ;
;        JSR PRINT_HEX           ;the print routine is called
;        LDA PRGBAR_L            ;
;        JSR PRINT_HEX           ;the print routine is called

;        LDX #6                  ;build the screen
;        LDY #0                  ;
;        JSR SET_CURSOR          ;
;        LDA PRGBAR_TMP          ;
;        JSR PRINT_HEX           ;the print routine is called


                LDA #31                 ;the bar consists of ..+1 chars
                STA PRGBAR_CLR          ;

        ;the we fill it with full chars
                LDA PRGBAR_TMP          ;calculate the number of chars that need to be completely filled
                LSR                     ;
                LSR                     ;
                LSR                     ;
                STA PRGBAR_FILL         ;
                BEQ DRAW_BAR_FILLED     ;

DRAW_BAR_FILL   LDY #7                  ;#7 is the "completely filled char", perfect for filling a progress bar
                LDA PRGBAR_CHARS,Y      ;get the appropriate char from the table
                JSR PRINT_CHAR          ;character is printed to screen, cursor is incremented by one
                DEC PRGBAR_CLR          ;decrement the number of CLR characters we need to draw afterwards
                DEC PRGBAR_FILL         ;
                BNE DRAW_BAR_FILL       ;

        ;then finally we fill it with the detailed char for the last 8 pixels of the bars position
DRAW_BAR_FILLED LDA PRGBAR_TMP          ;
                AND #$7                 ;
                TAY                     ;
                LDA PRGBAR_CHARS,Y      ;get the appropriate char from the table
                JSR PRINT_CHAR          ;character is printed to screen, cursor is incremented by one


         ;clear all the chars for the remaining part of the bar
                LDA PRGBAR_CLR          ;
                BEQ DRAW_BAR_CLRD       ;
DRAW_BAR_CLR    LDY #0                  ;#0 is the "completely cleared char", perfect for clearing a progress bar
                LDA PRGBAR_CHARS,Y      ;get the appropriate char from the table
                JSR PRINT_CHAR          ;character is printed to screen, cursor is incremented by one
                DEC PRGBAR_CLR          ;
                BNE DRAW_BAR_CLR        ;

DRAW_BAR_CLRD   RTS                     ;return to caller


PRGBAR_TMP      byte 0
PRGBAR_FILL     byte 0
PRGBAR_CLR      byte 0
PRGBAR_CHARS    ;text'01234567' ;useful for debug
                BYTE    $20,$74,$65,$75,$61,$F6,$EA,$E0 ;the definiton of the individual pixels of the bar

PRGBAR_STEP     byte 0  ;this value is added each time the update_progrbar is called
PRGBAR_L        byte 0
PRGBAR_H        byte 0

;===============================================================================
;Writing a sector to disk
;------------------------
;For writing a sector to disk, the Commodore DOS offers the block write command.
;Due to heavy bugs in the B-W command, Commodore has sacrificed one of the user
;commands as a bugfix replacement. So instead of B-W you simply use U2.
;The format of this DOS command is: U2 <channel> <drive> <track> <sector>
;The drive parameter is only used for dual disk drives, so for all common 
;C64/C128/C16 drives this parameter will always be 0.
;Parameters track and sector explain themselves. They are sent in PETSCII
;format, so in assembler often a binary to PETSCII conversion is needed.
;A speciality of this command is the channel parameter. Actually you can't
;simply send this command to the drive and then start to send sector bytes.
;For the sending of the bytes you have to open another file which is adressed
;by this parameter. Before you send bytes into the channel buffer, it is
;neccessary to set the buffer pointer to 0 via the B-P command. 
;
;source: http://codebase64.org/doku.php?id=base:writing_a_sector_to_disk
;
;BASIC code:
;-----------
;10 SA=8192
;20 OPEN 2,8,2,"#"
;30 OPEN 15,8,15,"B-P 2 0"
;40 FOR I=0 TO 255
;50 A=PEEK(SA):SA=SA+1
;60 PRINT#2,CHR$(A);
;70 NEXT I
;80 PRINT#15,"U2 2 0 18 0"
;90 CLOSE 15:CLOSE 2
;
;Call example:
;               LDX TRACK               ;
;               LDY SECTOR              ;
;               JSR WRITE_BLOCK         ;
;               data is stored in screen mem. so you see what is happening
;-------------------------------------------------------------------------------
WRITE_BLOCK     TYA                     ;save Y value to stack, because the next routine will destroy it
                PHA                     ;if we do not save it first

                TXA                     ;
                JSR W_TRACK             ;use sector value 
                PLA                     ;recall saved valeu from stack
                JSR W_SECTOR            ;use sector value 

        ;RTS

                ; open the channel file
                LDA #1                  ;length of the table (cname_end-cname)
                LDX #<cname             ;
                LDY #>cname             ;
                JSR $FFBD               ;call SETNAM
                LDA #2                  ;file number 2
                LDX #DEVICE     ;the device number of the drive
                LDY #2                  ;secondary address 2
                JSR $FFBA               ;call SETLFS
                JSR $FFC0               ;call OPEN
                BCS WB_ERROR            ;if carry set, the file could not be opened


                ; open the command channel
                LDA #7                  ;length of the table (bpcmd_end-bpcmd)
                LDX #<bpcmd             ;
                LDY #>bpcmd             ;
                JSR $FFBD               ;call SETNAM
                LDA #15                 ;file number 15
                LDX #DEVICE             ;the device number of the drive
                LDY #15                 ;secondary address 15
                JSR $FFBA               ;call SETLFS

                JSR $FFC0               ;call OPEN (open command channel and send B-P command)
                BCS WB_ERROR            ;if carry set, the file could not be opened

                ;check drive error channel here to test for
                ;FILE NOT FOUND error etc.
                LDX #2                  ;filenumber 2
                JSR $FFC9               ;call CHKOUT (file 2 now used as output)

                LDY #$00                ;
WB_LOOP1        LDA DATA_AREA,Y         ;read byte from memory
                JSR $FFD2               ;call CHROUT (write byte to channel buffer)
                INY                     ;
                BNE WB_LOOP1            ;next byte, end when 256 bytes are read

                LDX #15                 ;filenumber 15
                JSR $FFC9               ;call CHKOUT (file 15 now used as output)

                LDY #$00                ;
WB_LOOP2        LDA bwcmd,Y             ;read byte from command string
                BEQ WB_CLOSE            ;keep readingtable until end-of-table marker
                JSR $FFD2               ;call CHROUT (write byte to command channel)
               ;STA $0500,Y  ; for debug purposes only
                INY                     ;
                JMP WB_LOOP2            ;next byte, end when 256 bytes are read

WB_ERROR        ;Akkumulator contains BASIC error code
                ;most likely errors: A=5 (DEVICE NOT PRESENT)
                ;... error handling for open errors ...
                ;even if OPEN failed, the file has to be closed

WB_CLOSE        JSR $FFCC               ;call CLRCHN
                LDA #15                 ;filenumber 15
                JSR $FFC3               ;call CLOSE

                LDA #2                  ;filenumber 2
                JSR $FFC3               ;call CLOSE

                JSR $FFCC               ;call CLRCHN
                RTS                     ;

;===============================================================================
;Reading a sector from disk
;--------------------------
;For reading a sector from disk, the Commodore DOS offers the block read command.
;Due to heavy bugs in the B-R command, Commodore has sacrificed one of the user
;commands as a bugfix replacement. So instead of B-R you simply use U1.
;The format of this DOS command is: U1 <channel> <drive> <track> <sector>
;The drive parameter is only used for dual disk drives, so for all common C64/C128/C16
;drives this parameter will always be 0. Parameters track and sector explain themselves.
;They are sent in PETSCII format, so in assembler often a binary to PETSCII conversion is needed.
;A speciality of this command is the channel parameter. Actually you can't simply
;send this command to the drive and then start to receive sector bytes. For the
;receiving of the bytes you have to open another file which is adressed by this parameter.

;BASIC code:
;-----------
;10 SA=1024
;20 OPEN 2,8,2,"#"
;30 OPEN 15,8,15,"U1 2 0 18 0"
;40 FOR I=0 TO 255
;50 GET#2,A$:IF A$="" THEN A$=CHR$(0)
;60 POKE SA,ASC(A$):SA=SA+1
;70 NEXT I
;80 CLOSE 15:CLOSE 2
;
;source: http://codebase64.org/doku.php?id=base:reading_a_sector_from_disk
;
;
;Call example:
;               LDX TRACK               ;
;               LDY SECTOR              ;
;               JSR READ_BLOCK          ;
;               data is stored in screen mem. so you see what is happening
;===============================================================================

READ_BLOCK      TYA                     ;save Y value to stack, because the next routine will destroy it
                PHA                     ;if we do not save it first

                TXA                     ;
                JSR R_TRACK             ;use sector value 
                PLA                     ;recall saved value from stack
                JSR R_SECTOR            ;use sector value 

                ; open the channel file
                LDA #1                  ;length of the table (cname_end-cname)
                LDX #<cname             ;
                LDY #>cname             ;
                JSR $FFBD               ;call SETNAM
                LDA #2                  ;file number 2
                LDX #DEVICE             ;the device number of the drive
                LDY #2                  ;secondary address 2
                JSR $FFBA               ;call SETLFS
                JSR $FFC0               ;call OPEN
                BCS RB_ERROR            ;if carry set, the file could not be opened

                ;open the command channel
                LDA #12                 ;length of the table (brcmd_end-brcmd)
                LDX #<brcmd             ;
                LDY #>brcmd             ;
                JSR $FFBD               ;call SETNAM
                LDA #15                 ;file number 15
                LDX #DEVICE             ;the device number of the drive
                LDY #15                 ;secondary address 15
                JSR $FFBA               ;call SETLFS
                JSR $FFC0               ;call OPEN (open command channel and send U1 command)
                BCS RB_ERROR            ;if carry set, the file could not be opened

                ; check drive error channel here to test for
                ; FILE NOT FOUND error etc.
                LDX #2                  ;filenumber 2
                JSR $FFC6               ;call CHKIN (file 2 now used as input)

                LDY #$0                 ;set to FF for a speed test (this is useless (because it discards 254 bytes) but more fun to watch)
RB_LP           JSR $FFCF               ;call CHRIN (get a byte from file)
                STA DATA_AREA,Y         ;write byte to memory (which happens to be also screen memory,
                INY                     ;which is a good thing because we can see the data)
                BNE RB_LP               ;next byte, end when 256 bytes are read

RB_ERROR        ; Akkumulator contains BASIC error code
                ; most likely errors: A=5 (DEVICE NOT PRESENT)
                ;... error handling for open errors ...
                ;even if OPEN failed, the file has to be closed

RB_CLOSE        LDA #15                 ;filenumber 15
                JSR $FFC3               ;call CLOSE

                LDA #2                  ;filenumber 2
                JSR $FFC3               ;call CLOSE

                JSR $FFCC               ;call CLRCHN
                RTS                     ;

;===============================================================================
;R_TRACK, R_SECTOR, W_TRACK, W_SECTOR need to be cleaned up into a more
;memory efficient form...
;-------------------------------------------------------------------------------

R_TRACK         LDY #$2f                ;
                LDX #$3a                ;
                SEC                     ;
D_01            INY                     ;
                SBC #100                ;
                BCS D_01                ;

D_02            DEX                     ;
                ADC #10                 ;
                BMI D_02                ;
        
                ADC #$2f                ;
                PHA                     ;save A to stack

              TXA                       ;transfer value to A for printing
              LDY #00                   ;
              STA 1631,Y ;SECT,Y        ;character read from string (stored in A) is now written to screen memory (see C64 manual appendix E for screen display codes)
              STA R_TRCK,Y              ;

              PLA                       ;retrieve saved A from stack for printing
              INY
              STA 1631,Y ;SECT,Y        ;character read from string (stored in A) is now written to screen memory (see C64 manual appendix E for screen display codes)
              STA R_TRCK,Y              ;
                RTS                     ;



R_SECTOR        LDY #$2f                ;
                LDX #$3a                ;
                SEC                     ;
D_11            INY                     ;
                SBC #100                ;
                BCS D_11                ;

D_12            DEX                     ;
                ADC #10                 ;
                BMI D_12                ;
        
                ADC #$2f                ;
                PHA                     ;save A to stack

              TXA                       ;transfer value to A for printing
              LDY #00                   ;
              STA 1671,Y ;SECT,Y        ;character read from string (stored in A) is now written to screen memory (see C64 manual appendix E for screen display codes)
              STA R_SECT,Y              ;

              PLA                       ;retrieve saved A from stack for printing
              INY
              STA 1671,Y ;SECT,Y        ;character read from string (stored in A) is now written to screen memory (see C64 manual appendix E for screen display codes)
              STA R_SECT,Y              ;
                RTS                     ;

;-------------------------------------------------------------------------------
W_TRACK         LDY #$2f                ;
                LDX #$3a                ;
                SEC                     ;
W_01            INY                     ;
                SBC #100                ;
                BCS W_01                ;

W_02            DEX                     ;
                ADC #10                 ;
                BMI W_02                ;
        
                ADC #$2f                ;
                PHA                     ;save A to stack

              TXA                       ;transfer value to A for printing
              LDY #00                   ;
              STA 1631,Y ;SECT,Y        ;character read from string (stored in A) is now written to screen memory (see C64 manual appendix E for screen display codes)
              STA W_TRCK,Y              ;

              PLA                       ;retrieve saved A from stack for printing
              INY
              STA 1631,Y ;SECT,Y        ;character read from string (stored in A) is now written to screen memory (see C64 manual appendix E for screen display codes)
              STA W_TRCK,Y              ;
                RTS                     ;



W_SECTOR        LDY #$2f                ;
                LDX #$3a                ;
                SEC                     ;
W_11            INY                     ;
                SBC #100                ;
                BCS W_11                ;

W_12            DEX                     ;
                ADC #10                 ;
                BMI W_12                ;
        
                ADC #$2f                ;
                PHA                     ;save A to stack

              TXA                       ;transfer value to A for printing
              LDY #00                   ;
              STA 1671,Y ;SECT,Y        ;character read from string (stored in A) is now written to screen memory (see C64 manual appendix E for screen display codes)
              STA W_SECT,Y              ;

              PLA                       ;retrieve saved A from stack for printing
              INY
              STA 1671,Y ;SECT,Y        ;character read from string (stored in A) is now written to screen memory (see C64 manual appendix E for screen display codes)
              STA W_SECT,Y              ;
                RTS                     ;


;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ifdef TYPE_D64

;===============================================================================
;This table describes the number of sectors per track, please keep in mind that
;normal disks consist of only 35 tracks, therefore tracks 36-40 will only apply
;to 40-track images only.
;
; source: http://unusedino.de/ec64/technical/formats/d64.html
;-------------------------------------------------------------------------------
TABLE_MAXSEC
        ;      Track  #Sect  #Sec adr   D64 adr   
        ;      -----  -----  --------   -------   
        BYTE           21;       0       $00000    = track 1  
        BYTE           21;      21       $01500    = track 2  
        BYTE           21;      42       $02A00    = track 3     
        BYTE           21;      63       $03F00    = track 4  
        BYTE           21;      84       $05400    = track 5     
        BYTE           21;     105       $06900    = track 6  
        BYTE           21;     126       $07E00    = track 7     
        BYTE           21;     147       $09300    = track 8     
        BYTE           21;     168       $0A800    = track 9  
        BYTE           21;     189       $0BD00    = track 10     
        BYTE           21;     210       $0D200    = track 11    
        BYTE           21;     231       $0E700    = track 12     
        BYTE           21;     252       $0FC00    = track 13    
        BYTE           21;     273       $11100    = track 14      
        BYTE           21;     294       $12600    = track 15     
        BYTE           21;     315       $13B00    = track 16     
        BYTE           21;     336       $15000    = track 17     
        BYTE           19;     357       $16500    = track 18      
        BYTE           19;     376       $17800    = track 19      
        BYTE           19;     395       $18B00    = track 20      
        BYTE           19;     414       $19E00    = track 21  
        BYTE           19;     433       $1B100    = track 22  
        BYTE           19;     452       $1C400    = track 23  
        BYTE           19;     471       $1D700    = track 24  
        BYTE           18;     490       $1EA00    = track 25  
        BYTE           18;     508       $1FC00    = track 26  
        BYTE           18;     526       $20E00    = track 27  
        BYTE           18;     544       $22000    = track 28  
        BYTE           18;     562       $23200    = track 29  
        BYTE           18;     580       $24400    = track 30  
        BYTE           17;     598       $25600    = track 31  
        BYTE           17;     615       $26700    = track 32  
        BYTE           17;     632       $27800    = track 33  
        BYTE           17;     649       $28900    = track 34  
        BYTE           17;     666       $29A00    = track 35  
        BYTE           17;     683       $2AB00    = track 36  
        BYTE           17;     700       $2BC00    = track 37  
        BYTE           17;     717       $2CD00    = track 38  
        BYTE           17;     734       $2DE00    = track 39  
        BYTE           17;     751       $2EF00    = track 40  


;a 35track disc, has 683 blocks, the progressbar is 255=100%.
;To make fractional number possible, we firt multiply by 256 and then discard the least 8 bits afterwards.
;so (256*256)/683 = 95,953 (we round that down to 95) so each block (of a 35 track disc) should increase the counter by that value
TABLE_PP_BLOCK   byte    95
;so (256*256)/767 = 85,445 (we round that down to 85) so each block (of a 40 track disc) should increase the counter by that value
;TABLE_PP_BLOCK_40T   byte    85

;-------------------------------------------------------------------------------
endif
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ifdef TYPE_D81
;-------------------------------------------------------------------------------
;===============================================================================
;This table describes the number of sectors per track, please keep in mind that
;normal disks consist of only 35 tracks, therefore tracks 36-40 will only apply
;to 40-track images only.
;
; source: http://unusedino.de/ec64/technical/formats/d64.html
;-------------------------------------------------------------------------------
TABLE_MAXSEC
             ;Track #Sect #SectorsIn D81 Offset 
             ;----- ----- ---------- ---------- 
        BYTE          40;       0       $00000   = track 1
        BYTE          40;      40       $02800   = track 2
        BYTE          40;      80       $05000   = track 3
        BYTE          40;     120       $07800   = track 4
        BYTE          40;     160       $0A000   = track 5
        BYTE          40;     200       $0C800   = track 6
        BYTE          40;     240       $0F000   = track 7
        BYTE          40;     280       $11800   = track 8
        BYTE          40;     320       $14000   = track 9
        BYTE          40;     360       $16800   = track 10
        BYTE          40;     400       $19000   = track 11
        BYTE          40;     440       $1B800   = track 12
        BYTE          40;     480       $1E000   = track 13
        BYTE          40;     520       $20800   = track 14
        BYTE          40;     560       $23000   = track 15
        BYTE          40;     600       $25800   = track 16
        BYTE          40;     640       $28000   = track 17
        BYTE          40;     680       $2A800   = track 18
        BYTE          40;     720       $2D000   = track 19
        BYTE          40;     760       $2F800   = track 20
        BYTE          40;     800       $32000   = track 21
        BYTE          40;     840       $34800   = track 22
        BYTE          40;     880       $37000   = track 23
        BYTE          40;     920       $39800   = track 24
        BYTE          40;     960       $3C000   = track 25
        BYTE          40;    1000       $3E800   = track 26
        BYTE          40;    1040       $41000   = track 27
        BYTE          40;    1080       $43800   = track 28
        BYTE          40;    1120       $46000   = track 29
        BYTE          40;    1160       $48800   = track 30
        BYTE          40;    1200       $4B000   = track 31
        BYTE          40;    1240       $4D800   = track 32
        BYTE          40;    1280       $50000   = track 33
        BYTE          40;    1320       $52800   = track 34
        BYTE          40;    1360       $55000   = track 35
        BYTE          40;    1400       $57800   = track 36
        BYTE          40;    1440       $5A000   = track 37
        BYTE          40;    1480       $5C800   = track 38
        BYTE          40;    1520       $5F000   = track 39
        BYTE          40;    1560       $61800   = track 40
        BYTE          40;    1600       $64000   = track 41
        BYTE          40;    1640       $66800   = track 42
        BYTE          40;    1680       $69000   = track 43
        BYTE          40;    1720       $6B800   = track 44
        BYTE          40;    1760       $6E000   = track 45
        BYTE          40;    1800       $70800   = track 46
        BYTE          40;    1840       $73000   = track 47
        BYTE          40;    1880       $75800   = track 48
        BYTE          40;    1920       $78000   = track 49
        BYTE          40;    1960       $7A800   = track 50
        BYTE          40;    2000       $7D000   = track 51
        BYTE          40;    2040       $7F800   = track 52
        BYTE          40;    2080       $82000   = track 53
        BYTE          40;    2120       $84800   = track 54
        BYTE          40;    2160       $87000   = track 55
        BYTE          40;    2200       $89800   = track 56
        BYTE          40;    2240       $8C000   = track 57
        BYTE          40;    2280       $8E800   = track 58
        BYTE          40;    2320       $91000   = track 59
        BYTE          40;    2360       $93800   = track 60
        BYTE          40;    2400       $96000   = track 61
        BYTE          40;    2440       $98800   = track 62
        BYTE          40;    2480       $9B000   = track 63
        BYTE          40;    2520       $9D800   = track 64
        BYTE          40;    2560       $A0000   = track 65
        BYTE          40;    2600       $A2B00   = track 66
        BYTE          40;    2640       $A5000   = track 67
        BYTE          40;    2680       $A7800   = track 68
        BYTE          40;    2720       $AA000   = track 69
        BYTE          40;    2760       $AC800   = track 70
        BYTE          40;    2800       $AF000   = track 71
        BYTE          40;    2840       $B1800   = track 72
        BYTE          40;    2880       $B4000   = track 73
        BYTE          40;    2920       $B6800   = track 74
        BYTE          40;    2960       $B9000   = track 75
        BYTE          40;    3000       $BB800   = track 76
        BYTE          40;    3040       $BE000   = track 77
        BYTE          40;    3080       $C0800   = track 78
        BYTE          40;    3120       $C3000   = track 79
        BYTE          40;    3160       $C5800   = track 80

;an 80track disc, has 3200 blocks, the progressbar is 255=100%.
;To make fractional number possible, we firt multiply by 256 and then discard the least 8 bits afterwards.
;so (256*256)/3160 = 20,48 (we round that down to 20) so each block (of a 80 track disc) should increase the counter by that value
TABLE_PP_BLOCK   byte    20
;-------------------------------------------------------------------------------
endif
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


;Now there is one problem, due to the inaccuracy, the bar will never reach 100%, so it seems to finish early, but this will be too short to notice in most cases

;-------------------------------------------------------------------------------
;these tables are for the kernal routines to communicate with the drive

cname           BYTE $23                ; $23 = #
cname_end       BYTE 0                  ;end of table marker

brcmd           BYTE $55                ; $55 = U
                BYTE $31                ; $31 = 1
                BYTE $20                ; $20 = SPACE
                BYTE $32                ; $31 = 2
                BYTE $20                ; $20 = SPACE
                BYTE $30                ; $31 = 0
                BYTE $20                ; $20 = SPACE
R_TRCK          BYTE $31                ; $31 = 1
                BYTE $38                ; $31 = 8
                BYTE $20                ; $20 = SPACE
R_SECT          BYTE $30                ; $30 = 0
                BYTE $31                ; $31 = 1
brcmd_end       BYTE 0                  ;end of table marker

bpcmd           BYTE $42                ; $42 = B
                BYTE $2D                ; $45 = -
                BYTE $50                ; $50 = P
                BYTE $20                ; $20 = SPACE
                BYTE $32                ; $31 = 2
                BYTE $20                ; $20 = SPACE
                BYTE $30                ; $31 = 0
bpcmd_end       BYTE 0                  ;end of table marker

bwcmd           BYTE $55                ; $55 = U
                BYTE $32                ; $32 = 2
                BYTE $20                ; $20 = SPACE
                BYTE $32                ; $31 = 2
                BYTE $20                ; $20 = SPACE
                BYTE $30                ; $31 = 0
                BYTE $20                ; $20 = SPACE
W_TRCK          BYTE $31                ; $31 = 1
                BYTE $38                ; $31 = 8
                BYTE $20                ; $20 = SPACE
W_SECT          BYTE $30                ; $30 = 0
                BYTE $31                ; $31 = 1
                BYTE $0D                ;carriage return, required to start command
bwcmd_end       BYTE 0                  ;end of table marker


;-------------------------------------------------------------------------------
; convert ascii to petscii
;(the keyboard gives out ASCII but the screen can't print these directly)
;-------------------------------------------------------------------------------

CONVERT_TO_SCREENCODES
        AND #%01111111                          ;only use the lowest 7 bits
        TAY                                     ;copy value in ACCU to Y (we use it as the index in our conversion table)
        LDA ASCII_TO_SCREENDISPLAYCODE_SET1,Y   ;in order to get the smoothest bar
        RTS                                     ;return with the coneverted value

        ;the table below converts an ASCII value to the SCREEN DISPLAY CODE (Prog ref guide page 376)
        ;make sure that you are displaying in set-1 (you can toggle between set by pressing shift+commodore on your C64)
        ;we need this table in order to display the filenames which are in ASCII (otherwise the PC needs to convert to PETSCII, which makes no sense as ASCII is the one and only real standard)
ASCII_TO_SCREENDISPLAYCODE_SET1
        ;this table is most likely not perfect... under construction!!!         (this table uses the INDEX values of the charset)
    BYTE $20,$81,$82,$83,$84,$85,$86,$87,$88,$89,$8a,$8b,$8c,$8d,$8e,$8f
    BYTE $90,$91,$92,$93,$94,$95,$96,$97,$98,$99,$9a,$9b,$9c,$9d,$9e,$9f
    BYTE $20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$2a,$2b,$2c,$2d,$2e,$2f
    BYTE $30,$31,$32,$33,$34,$35,$36,$37,$38,$39,$3a,$3b,$3c,$3d,$3e,$3f
    BYTE $00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0a,$0b,$0c,$0d,$0e,$0f
    BYTE $10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$1a,$1b,$1c,$1d,$1e,$46
    BYTE $00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0a,$0b,$0c,$0d,$0e,$0f
    BYTE $10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$1a,$1b,$1c,$1d,$1e,$1f

;===============================================================================
;  
;                                V A R I A B L E S 
;
;===============================================================================
;a small list of variables that do not require storage in the zero-page

CNT_BYTE        BYTE $0         ;
TABLE_PNTR      BYTE $0         ;
TRACK           BYTE $0         ;
SECTOR          BYTE $0         ;


;base of path is determined by the computermodel
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ifdef COMMODOREPET20XX
STR_MEM         TEXT "PET20XX/" ;filename or to be more precise, the filepath for the image file as stored on the Cassiopei SD-card
endif
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ifdef COMMODOREPET30XX
STR_MEM         TEXT "PET30XX/" ;filename or to be more precise, the filepath for the image file as stored on the Cassiopei SD-card
endif
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ifdef COMMODOREPET40XX
STR_MEM         TEXT "PET40XX/" ;filename or to be more precise, the filepath for the image file as stored on the Cassiopei SD-card
endif
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ifdef COMMODOREPET80XX
STR_MEM         TEXT "PET80XX/" ;filename or to be more precise, the filepath for the image file as stored on the Cassiopei SD-card
endif
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ifdef COMMODOREVIC64
STR_MEM         TEXT "vic20/" ;filename or to be more precise, the filepath for the image file as stored on the Cassiopei SD-card
endif
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ifdef COMMODORE64
STR_MEM         TEXT "c64/"   ;filename or to be more precise, the filepath for the image file as stored on the Cassiopei SD-card
endif
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ifdef COMMODORE128
STR_MEM         TEXT "c128/"  ;filename or to be more precise, the filepath for the image file as stored on the Cassiopei SD-card
endif
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ifdef COMMODORE16
STR_MEM         TEXT "c16/"  ;filename or to be more precise, the filepath for the image file as stored on the Cassiopei SD-card
endif
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ifdef COMMODOREPLUS4
STR_MEM         TEXT "plus4/"  ;filename or to be more precise, the filepath for the image file as stored on the Cassiopei SD-card
endif
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


;file folder and file extension are determined by the image type
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
;-------------------------------------------------------------------------------
ifdef TYPE_D64
                TEXT "d64/disk-image-01.d64"   ;filename or to be more precise, the filepath for the image file as stored on the Cassiopei SD-card
                BYTE $0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0  ;some addtional bytes to allign it all properly in memory

TRACK_MAX       BYTE 35         ;
endif
;-------------------------------------------------------------------------------

;-------------------------------------------------------------------------------
ifdef TYPE_D81
                TEXT "d81/disk-image-01.d81"   ;filename or to be more precise, the filepath for the image file as stored on the Cassiopei SD-card
                BYTE $0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0  ;some addtional bytes to allign it all properly in memory

TRACK_MAX       BYTE 80         ;

endif
;-------------------------------------------------------------------------------
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



SECTOR_MAX      BYTE $0         ;

BROWSE_ACTION   BYTE $0         ;
BROWSE_STATUS   BYTE $0         ;
BROWSE_CURX     BYTE $0         ;
BROWSE_CURY     BYTE $0         ;
BROWSE_MAXX     BYTE $0         ;
BROWSE_MAXY     BYTE $0         ;

STR_POS         BYTE $0         ;the position in the string


FILE_OPEN_STATUS        BYTE $0 ;the response to the fileopen request
FILE_SIZE_03            BYTE $0 ;the MSB of the 4 byte filesize value
FILE_SIZE_02            BYTE $0
FILE_SIZE_01            BYTE $0
FILE_SIZE_00            BYTE $0

##{0}F:\Projects\Cassiopei\Versie_2-Wifi\Software\CBM_software\Cassiopei_v2.0-Disk_Wizard\source\\02_1_Main.asm

;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ifdef COMMODOREPET20XX or COMMODOREPET30XX or COMMODOREPET40XX
SCREENWIDTH = 40        ;width of the computer screen in characters, required for print function
endif

ifdef COMMODOREPET80XX
SCREENWIDTH = 80        ;width of the computer screen in characters, required for print function
endif

ifdef COMMODOREPET20XX or COMMODOREPET30XX or COMMODOREPET40XX or COMMODOREPET80XX
;-------------------------------------------------------------------------------
CHARSCREEN      = $8000         ;location of the character screen memory

;KEYCNT  = 525          ;the counter that keeps track of the number of key in the keyboard buffer       Original ROM PETs       
;KEYBUF  = 527          ;the first position of the keyboard buffer                                      Original ROM PETs  
KEYCNT          = 158           ;the counter that keeps track of the number of key in the keyboard buffer       PET/CBM (Upgrade and 4.0 BASIC)
KEYBUF          = 623           ;the first position of the keyboard buffer                                      PET/CBM (Upgrade and 4.0 BASIC)
CURSORPOS_X     = 198           ;Cursor Column on Current Line                                                  PET/CBM (Upgrade and 4.0 BASIC)
CURSORPOS_Y     = 216           ;Current Cursor Physical Line Number                                            PET/CBM (Upgrade and 4.0 BASIC)

;TODCLK         = $C8           ;Time-Of-Day clock register (MSB) BASIC 1 uses locations 200-202 ($C8-$CA)
;TODCLK+1       = $C9           ;Time-Of-Day clock register (.SB)
;TODCLK+2       = $CA           ;Time-Of-Day clock register (LSB)

TODCLK          = $8D           ;Time-Of-Day clock register (MSB) BASIC>1 uses locations 141-143 ($8D-$8F)
;TODCLK+1       = $8E           ;Time-Of-Day clock register (.SB)
;TODCLK+2       = $8F           ;Time-Of-Day clock register (LSB)

;###############################################################################

KEY_NOTHING     = 255           ;matrix value when no key is pressed

;-- PETSCII keycodes --
KEY_7           = $37           ;$37 = 7 
KEY_4           = $34           ;$34 = 4
KEY_1           = $31           ;$31 = 1 
KEY_0           = $30           ;$30 = 0
KEY_RETURN      = $0D           ;$0D = RETURN

;-------------------------------------------------------------------------------
;Read the keyboard, this routine converts the keycode to a control
;code that is easier to decode. This value is stored in A
;...............................................................................
SCAN_INPUTS     LDA #254                ;by setting the "currently detected value" to something different then the value that was detected the last time, we can achieve key-repeat
                STA $97                 ;because the CBM will wait for the "currently detected value" to change before it will accept the same again.
                LDA ALLOW_KEYREPEAT     ;some functions/keys have keyrepeat, this makes it easier to scroll
                BNE SCAN_KEYPRESS       ;through a long list of filenames

SCAN_KEYRELEASE LDA $97                 ;
                CMP #KEY_NOTHING        ;check for the "no key pressed" situation
                BNE SCAN_KEYRELEASE     ;when the keyboard isn't released, we may asume that the user is still pressing the same key, perhaps so we repeat the input (and by that we create key repeat functionality)

SCAN_KEYPRESS   LDA #$00                ;clear keyboard buffer
                STA KEYCNT              ;
SCAN_KEYPR_00   LDA KEYCNT              ;check number of chars in keyboard buffer
                BEQ SCAN_KEYPR_00       ;

                LDA KEYBUF              ;use the value as found in the keyboard buffer, the only way to be independend of the keyboard matrix!!!
                CMP #KEY_7              ;and jump to the requested action
                BEQ SCAN_VAL_PREV       ;
                CMP #KEY_4              ;
                BEQ SCAN_VAL_SELECT     ;
                CMP #KEY_1              ;
                BEQ SCAN_VAL_NEXT       ; 


SCAN_VAL_IDLE   LDA #0                  ;do not allow keyrepeat on this button
                STA ALLOW_KEYREPEAT     ;
                LDA #USER_INPUT_IDLE    ;nothing happened, send idle value
                RTS

SCAN_VAL_SELECT LDA #0                  ;do not allow keyrepeat on this button
                STA ALLOW_KEYREPEAT     ;
                LDA #USER_INPUT_SELECT  ;
                RTS

SCAN_VAL_PREV   LDA #1                  ;keyrepeat on this button
                STA ALLOW_KEYREPEAT     ;
                LDA #USER_INPUT_PREVIOUS;
                RTS

SCAN_VAL_NEXT   LDA #1                  ;keyrepeat on this button
                STA ALLOW_KEYREPEAT     ;
                LDA #USER_INPUT_NEXT    ;
                RTS

ALLOW_KEYREPEAT BYTE $0 ;this is a flag that indicates if keyrepeat is allowed (0=key repeat not alowed, 1=key repeat alowed)


;-------------------------------------------------------------------------------
;This routine will wait until the user presses a key
;call example   JSR WAIT_FOR_KEY
;...............................................................................
WAIT_FOR_KEY    LDA #$00                ;clear keyboard buffer
                STA KEYCNT              ;
WAIT_FOR_KEY_01 LDA KEYCNT              ;check number of chars in keyboard buffer
                BEQ WAIT_FOR_KEY_01     ;
                RTS                     ;

;-------------------------------------------------------------------------------
;Prevent the use of shift+CBM to change the case of the screen.
;This must be prevented when screen are build with special characters.
;Example:       JSR PREVENT_CASE_CHANGE
;...............................................................................                
PREVENT_CASE_CHANGE
                RTS                     ;

;HOW DO I ACCESS UPPER/LOWER CASE OR GRAPHICS CHARACTER SETS?

;  In order to have graphic symbols to to draw simple charts and for games
;  as well as upper and lower case characters for word processing Commodore
;  gave the PET two 256 character sets, one with upper and lower case
;  characters for word processing and business applications and one with
;  upper case and graphics characters for charts, games, etc.  In order to
;  change the 'mode' of the PET you must direct the computer to 'look' at
;  one of two character sets via a POKE command. 

;  The PETs start up in one of two modes, upper case characters (pressing
;  shift types graphics symbols) or lower case characters (pressing shift
;  shift types upper case characters).

;  To direct the computer to uppercase/grpahics mode:
;    POKE 59468,12

;  To direct the computer to lower/uppercase mode:
;    POKE 59468,14

;   Note that when you change sets the characters on the screen change
;   immediately to the new image, you cannot hve characters from both
;   set on the screen at the same time without some specially timed
;   program to perform it.

;  Original ROM PET have reversed reversed upper/lower case characters:

;  Commodore had the upper/lower case characters reversed in the original
;  ROM models where both modes started with upper case characters and you
;  pressed SHIFT for lower case or graphics.  This is the reason for some
;  older software having reversed case text.  There are utilities available
;  that will adjust all your PRINT statements to the proper case for the
;  newer or older ROM machines.

;  12" 4000/8000 series:

;  The 12" 4000/8000 series PETs allow you to change case by printing
;  a control character:  CHR$(14) - Text Mode   CHR$(142)-Graphics Mode

;  When you issue a CHR$(14) on a 4000/800 series PET the newer display
;  controller will be adjusted so there is a pixel or two gap between
;  screen lines.  If you do not wish this gap in text mode just
;  POKE 59468,14 instead of printing CHR$(14)
;  (if you want the gap in character mode you can issue a ? CHR$(14)
;  and then POKE 59468,12 to produce the desired effect.)

;  Unlike the later Commmodore 8-Bits there is no way to edit the
;  characters on the screen in software alone.

;-------------------------------------------------------------------------------
;Allow the use of shift+CBM to change the case of the screen.
;Example:       JSR ALLOW_CASE_CHANGE
;...............................................................................                
ALLOW_CASE_CHANGE
                RTS


;-------------------------------------------------------------------------------
;Clear screen (no color memory needs to be set on a b/w or green-screen PET)
;Example:       JSR CLEAR_SCREEN
;...............................................................................
CLEAR_SCREEN    LDY #0 
                LDA #$20                ;fill the screen with spaces
SETCHARACTER    STA CHARSCREEN+0,y      ;
                STA CHARSCREEN+256,y    ;
                STA CHARSCREEN+512,y    ;
                STA CHARSCREEN+745,y    ;            
                INY                     ;
                BNE SETCHARACTER        ;

                RTS                     ;

;-------------------------------------------------------------------------------
;This routine will print extra computer specific information
;Example:       JSR SHOW_VERSION
;...............................................................................
SHOW_VERSION    LDX #1                  ;set cursor to top,left
                LDY #1                  ;
                JSR SET_CURSOR          ;
                LDA #<PRG_IDENTIFIER    ;set pointer to the text that defines the main-screen
                LDY #>PRG_IDENTIFIER    ;        
                JSR PRINT_STRING        ;the print routine is called, so the pointed text is now printed to screen     
               
                LDX #1                  ;set cursor to top,left
                LDY #2                  ;
                JSR SET_CURSOR          ;
                LDA #<VERSION_INFO      ;set pointer to the text that defines the main-screen
                LDY #>VERSION_INFO      ;        
                JSR PRINT_STRING        ;the print routine is called, so the pointed text is now printed to screen     

                RTS

;-------------------------------------------------------------------------------
; The first location of the charsecreen (topleft) is defined as coordinate 0,0
; Use this routine before calling a PRINT related routine
;               LDX CURSOR_Y;.. chars from the top of the defined screen area
;               LDY CURSOR_X;.. chars from the left of the defined screen area
;               JSR SET_CURSOR
;...............................................................................

SET_CURSOR      LDA #<CHARSCREEN        ;
                STA CHAR_ADDR           ;store base address (low byte)
                LDA #>CHARSCREEN        ;
                STA CHAR_ADDR+1         ;store base address (high byte)

                ;calculate exact value based on the requested X and Y coordinate
                CLC                     ;
                TXA                     ;add  value in X register (to calculate the new X position of cursor)
                ADC CHAR_ADDR           ;                        
                STA CHAR_ADDR           ;
                LDA #$00                ;
                ADC CHAR_ADDR+1         ;add carry
                STA CHAR_ADDR+1         ;

SET_CURS_CHR_LP CPY #00                 ;
                BEQ SET_CURS_END        ;when Y is zero, calculation is done
                CLC                     ;clear carry for the upcoming "ADC CHAR_ADDR"

                LDA #SCREENWIDTH        ;add  40 or 80 to calculate the new Y position of cursor
                ADC CHAR_ADDR           ;                        
                STA CHAR_ADDR           ;
                LDA #$00                ;
                ADC CHAR_ADDR+1         ;add carry... and viola, we have a new cursor position (memory location where next character will be printed)
                STA CHAR_ADDR+1         ;
                DEY                     ;
                JMP SET_CURS_CHR_LP     ;

SET_CURS_END    RTS                     ;

;-------------------------------------------------------------------------------
;call this routine as described below:
;
;               LDA #character          ;character is stored in Accumulator
;               JSR PRINT_CHAR          ;character is printed to screen, cursor is incremented by one
; also affects Y
; note: when the character value is 0 there is nothing printed but we do increment the cursor by one
;...............................................................................
PRINT_CHAR      BEQ PRINT_NOTHING       ;when the value = 0, we print nothing but we do increment the cursor by one
                ;CLC
                ;ADC CHAR_INVERT         ;invert character depending on the status of the  CHAR_INVERT-flag
                LDY #00                 ;
                STA (CHAR_ADDR),Y       ;character read from string (stored in A) is now written to screen memory (see C64 manual appendix E for screen display codes)

                ;increment character pointer
PRINT_NOTHING   CLC                     ;
                LDA #$01                ;add 1
                ADC CHAR_ADDR           ;                        
                STA CHAR_ADDR           ;
                LDA #$00                ;
                ADC CHAR_ADDR+1         ;add carry... and viola, we have a new cursor position (memory location where next character will be printed)
                STA CHAR_ADDR+1         ;

                RTS                     ;

;CHAR_INVERT     BYTE $0        ;flag to indicate whether or not the printed character should be inverted

;-------------------------------------------------------------------------------
endif   ;this endif belongs to "ifdef COMMODOREPET20XX or COMMODOREPET30XX or COMMODOREPET40XX or COMMODOREPET80XX"
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

##{0}F:\Projects\Cassiopei\Versie_2-Wifi\Software\CBM_software\Cassiopei_v2.0-Disk_Wizard\source\\02_2_Main.asm

;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ifdef COMMODOREVIC20
;-------------------------------------------------------------------------------

SCAN_KEYBOARD   = $FF9F ;scans the keyboard and puts the matrix value in $C5
CHROUT          = $FFD2 ;

KEYCNT          = 198           ;the counter that keeps track of the number of key in the keyboard buffer       VIC-20
KEYBUF          = 631           ;the first position of the keyboard buffer                                      VIC-20
CURSORPOS_X     = 198           ;Cursor Column on Current Line                                                  PET/CBM (Upgrade and 4.0 BASIC)
CURSORPOS_Y     = 216           ;Current Cursor Physical Line Number                                            PET/CBM (Upgrade and 4.0 BASIC)

TODCLK          = $8D           ;Time-Of-Day clock register (MSB) BASIC>1 uses locations 141-143 ($8D-$8F)
;TODCLK+1       = $8E           ;Time-Of-Day clock register (.SB)
;TODCLK+2       = $8F           ;Time-Of-Day clock register (LSB)


;###############################################################################

;-- keycodes -- (VIC20 keyboard scanning values)

KEY_NOTHING     = $40           ;matrix value when no key is pressed

KEY_F3          = $2F
KEY_F5          = $37
KEY_F7          = $3F
;-------------------------------------------------------------------------------
;Read the keyboard and joystick, this routine converts the keycode to a control
;code that is easier to decode. This value is stored in A

;unfortunately the VIC20 keyboard does not always produce reliable results,
;therefore the matrix value is used with a simple consistency check algorithm
;that will filter out erronous values.
;...............................................................................
SCAN_INPUTS     LDA ALLOW_KEYREPEAT     ;some functions/keys have keyrepeat, this makes it easier to scroll
                BNE SCAN_KEYPRESS       ;through a long list of filenames

SCAN_KEYRELEASE JSR $EB1E               ;use kernal routine to scan VIC20 keyboard
                LDA $CB                 ;
                CMP #KEY_NOTHING        ;check for the "no key pressed" situation
                BNE SCAN_KEYRELEASE     ;when the keyboard isn't released, we may asume that the user is still pressing the same key, perhaps so we repeat the input (and by that we create key repeat functionality)

SCAN_KEYPRESS   LDA #8                  ;number of times the matrix value should be the same in order to detect a key as valid
                STA DEBOUNCE_CNT        ;
                JSR $EB1E               ;use kernal routine to scan VIC20 keyboard
                LDA $CB                 ;current matrix value
                STA DEBOUNCE_CURRENT    ;save current value
                CMP #KEY_NOTHING        ;check for the "no key pressed" situation
                BEQ SCAN_JOYSTICK       ;no keyboard action, check joystick

SCAN_KEY_LP     JSR $EB1E               ;use kernal routine to scan VIC20 keyboard
                LDA $CB                 ;current matrix value, compare this to the previous
                CMP DEBOUNCE_CURRENT    ;value, if this value stays the same for .. time in a row
                BNE SCAN_JOYSTICK       ;then it must be correct and we may process that value
                DEC DEBOUNCE_CNT        ;
                LDA DEBOUNCE_CNT        ;
                BNE SCAN_KEY_LP         ;keep looping until counter reaches 0

                LDA DEBOUNCE_CURRENT    ;
                CMP #KEY_F3             ;
                BEQ SCAN_VAL_PREV       ;
                CMP #KEY_F5             ;
                BEQ SCAN_VAL_SELECT     ;
                CMP #KEY_F7             ;
                BEQ SCAN_VAL_NEXT       ; 

SCAN_JOYSTICK   ;LDA #$00                ;make sure that inputs are set as inputs
                LDA #$80                ;ATN (bit-7) is output, the rest is input
                STA $9113               ;

                LDA $9111               ;joy#1
                AND #%00101100          ;mask out joystick signals before checking
                CMP #%00101100          ;is in a position other then the center position
                BEQ SCAN_EXIT           ;if not then we exit immediately

                LDA #160                ;
                STA DEBOUNCE_CNT        ;
                LDA $9111               ;joy#1
                AND #%00101100          ;mask out joystick signals
                STA DEBOUNCE_CURRENT    ;
SCAN_JOY_LP     LDA $9111               ;joy#1
                AND #%00101100          ;mask out joystick signals
                CMP DEBOUNCE_CURRENT    ;
                BNE SCAN_EXIT           ;
                DEC DEBOUNCE_CNT        ;
                BEQ SCAN_JOY_LP         ;keep looping (until we reach the thresshold) if the joystick stays the same...

                LDA #%00100000          ;fire
                BIT $9111               ;joy#1
                BEQ SCAN_VAL_SELECT     ;

                LDA #%00000100          ;up
                BIT $9111               ;joy#1
                BEQ SCAN_VAL_PREV       ;

                LDA #%00001000          ;down
                BIT $9111               ;joy#1
                BEQ SCAN_VAL_NEXT       ;

SCAN_EXIT       LDA #1                  ;allow keyrepeat in order to react better to keypresses (because there is no check for releasing screwing things up)
                STA ALLOW_KEYREPEAT     ;
                LDA #USER_INPUT_IDLE    ;nothing happened, send idle value
                RTS

SCAN_VAL_SELECT LDA #0                  ;do not allow keyrepeat on this button
                STA ALLOW_KEYREPEAT     ;
                LDA #USER_INPUT_SELECT  ;
                RTS

SCAN_VAL_PREV   LDA #1                  ;allow keyrepeat on this button
                STA ALLOW_KEYREPEAT     ;
                LDA #USER_INPUT_PREVIOUS;
                RTS

SCAN_VAL_NEXT   LDA #1                  ;allow keyrepeat on this button
                STA ALLOW_KEYREPEAT     ;
                LDA #USER_INPUT_NEXT    ;
                RTS

ALLOW_KEYREPEAT         BYTE $0 ;this is a flag that indicates if keyrepeat is allowed (0=key repeat not alowed, 1=key repeat alowed)
DEBOUNCE_CNT            BYTE $0 ;use for debouncing
DEBOUNCE_CURRENT        BYTE $0 ;use for debouncing


;-------------------------------------------------------------------------------
;This routine will wait until the user presses a key
;call example   JSR WAIT_FOR_KEY
;...............................................................................
WAIT_FOR_KEY    JSR $EB1E               ;use kernal routine to scan VIC20 keyboard
                LDA $CB                 ;
                CMP #KEY_NOTHING        ;check for the "no key pressed" situation
                BEQ WAIT_FOR_KEY        ;continue loop when no key is detected
                RTS                     ;

;-------------------------------------------------------------------------------
;Clear screen and set the color of the colorscreen
;Example:       JSR CLEAR_SCREEN
;...............................................................................
CLEAR_SCREEN    LDA #$08                ;make the screen and border black
                STA $900F               ;

                LDA #5                  ;PRINT CHR$(5) TO SET PRINTING COLOUR TO WHITE (this is the colour used with the KERNAL printing routine)
                JSR CHROUT              ;SCREEN
                LDA #147                ;PRINT CHR$(147) TO CLEAR
                JSR CHROUT              ;SCREEN
                RTS                     ;

;-------------------------------------------------------------------------------
; The first location of the charsecreen (topleft) is defined as coordinate 0,0
; Use this routine before calling a PRINT related routine
;               LDX CURSOR_Y;.. chars from the top of the defined screen area
;               LDY CURSOR_X;.. chars from the left of the defined screen area
;               JSR SET_CURSOR
;...............................................................................

SET_CURSOR      LDA #00                 ;
                STA CHAR_ADDR           ;store base address (low byte)
                LDA $0288               ;the location (high byte) of the screen as determined by the kernal
                STA CHAR_ADDR+1         ;store base address (high byte)
 
                ;calculate exact value based on the requested X and Y coordinate
                CLC                     ;
                TXA                     ;add  value in X register (to calculate the new X position of cursor)
                ADC CHAR_ADDR           ;                        
                STA CHAR_ADDR           ;
                LDA #$00                ;
                ADC CHAR_ADDR+1         ;add carry
                STA CHAR_ADDR+1         ;

SET_CURS_CHR_LP CPY #00                 ;
                BEQ SET_CURS_END        ;when Y is zero, calculation is done
                CLC                     ;clear carry for the upcoming "ADC CHAR_ADDR"

                LDA #22                 ;add  22 (which is the number of characters per line for a VIC20) to calculate the new Y position of cursor
                ADC CHAR_ADDR           ;                        
                STA CHAR_ADDR           ;
                LDA #$00                ;
                ADC CHAR_ADDR+1         ;add carry... and viola, we have a new cursor position (memory location where next character will be printed)
                STA CHAR_ADDR+1         ;
                DEY                     ;
                JMP SET_CURS_CHR_LP     ;

SET_CURS_END    RTS                     ;

;-------------------------------------------------------------------------------
;call this routine as described below:
;
;               LDA #character          ;character is stored in Accumulator
;               JSR PRINT_CHAR          ;character is printed to screen, cursor is incremented by one
; also affects Y
; note: when the character value is 0 there is nothing printed but we do increment the cursor by one
;...............................................................................
PRINT_CHAR      BEQ PRINT_NOTHING       ;when the value = 0, we print nothing but we do increment the cursor by one
                ;CLC
                ;ADC CHAR_INVERT         ;invert character depending on the status of the  CHAR_INVERT-flag
                LDY #00                 ;
                STA (CHAR_ADDR),Y       ;character read from string (stored in A) is now written to screen memory (see C64 manual appendix E for screen display codes)

                ;increment character pointer
PRINT_NOTHING   CLC                     ;
                LDA #$01                ;add 1
                ADC CHAR_ADDR           ;                        
                STA CHAR_ADDR           ;
                LDA #$00                ;
                ADC CHAR_ADDR+1         ;add carry... and viola, we have a new cursor position (memory location where next character will be printed)
                STA CHAR_ADDR+1         ;

                RTS                     ;

;CHAR_INVERT     BYTE $0        ;flag to indicate whether or not the printed character should be inverted

;-------------------------------------------------------------------------------
;Prevent the use of shift+CBM to change the case of the screen.
;This must be prevented when screen are build with special characters.
;Example:       JSR PREVENT_CASE_CHANGE
;...............................................................................                
PREVENT_CASE_CHANGE
                LDA #128                ;disable shift+CBM
                STA $0291               ;

                RTS                     ;

;-------------------------------------------------------------------------------
;Allow the use of shift+CBM to change the case of the screen.
;Example:       JSR ALLOW_CASE_CHANGE
;...............................................................................                
ALLOW_CASE_CHANGE
                LDA #0                  ;enable shift+CBM
                STA $0291               ;
              
                RTS


;-------------------------------------------------------------------------------
;This routine will print extra computer specific information
;Example:       JSR SHOW_VERSION
;...............................................................................
SHOW_VERSION    LDX #1                  ;set cursor to top,left
                LDY #1                  ;
                JSR SET_CURSOR          ;
                LDA #<PRG_IDENTIFIER    ;set pointer to the text that defines the main-screen
                LDY #>PRG_IDENTIFIER    ;        
                JSR PRINT_STRING        ;the print routine is called, so the pointed text is now printed to screen     
               
                LDX #1                  ;set cursor to top,left
                LDY #2                  ;
                JSR SET_CURSOR          ;
                LDA #<VERSION_INFO      ;set pointer to the text that defines the main-screen
                LDY #>VERSION_INFO      ;        
                JSR PRINT_STRING        ;the print routine is called, so the pointed text is now printed to screen     

                RTS

;-------------------------------------------------------------------------------
PRG_IDENTIFIER      ;'0123456789ABCDEF'
                TEXT 'petscii player:vic20' ;if the wrong menu PRG is installed onto the cassiopei, this message could be valuable hint in solving the problem also usefull for debugging on vice, then the screen is no longer completely empty and you know that something has happened
                BYTE 0;end of table marker


;-------------------------------------------------------------------------------
endif   ;this endif belongs to "ifdef COMMODOREVIC20"
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

##{0}F:\Projects\Cassiopei\Versie_2-Wifi\Software\CBM_software\Cassiopei_v2.0-Disk_Wizard\source\\02_3_Main.asm

;bug in menu code? or perhaps a C64 feature?: the joystick in PORT-1 might
;trigger a selection when moving wildly with the joystick AND when the last
;item in the list has been selected, the list of items does not need to be
;long, a 4 item list in de TAP file section is enough

;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ifdef COMMODORE64
;-------------------------------------------------------------------------------
BORDER          = $D020         ;bordercolour
BACKGROUND      = $D021         ;background-0
COLORSCREEN     = $D800         ;location of the color screen memory (this value is fixed)
CHARSCREEN      = $0400         ;location of the character screen memory
SCAN_KEYBOARD   = $FF9F         ;scans the keyboard and puts the matrix value in $C5

KEYCNT          = 198           ;the counter that keeps track of the number of key in the keyboard buffer
KEYBUF          = 631           ;the first position of the keyboard buffer
CURSORPOS_X     = 211           ;Cursor Column on Current Line (be aware that on a C64, position the cursor does not take effect immediately, only when a CR on the keyboard is send it will go there)
CURSORPOS_Y     = 214           ;Current Cursor Physical Line Number

TODCLK          = $A0           ;Time-Of-Day clock register (MSB)
;TODCLK+1       = $A1           ;Time-Of-Day clock register (.SB)
;TODCLK+2       = $A2           ;Time-Of-Day clock register (LSB)

;###############################################################################

;-- keycodes --
KEY_NOTHING     = $40           ;when no key is pressed
KEY_F1          = $04           ;$04 = F1 
KEY_F3          = $05           ;$05 = F3
KEY_F5          = $06           ;$06 = F5 
KEY_F7          = $03           ;$03 = F7
KEY_RETURN      = $01           ;$01 = RETURN
KEY_1           = $38           ;$38 = 1 
KEY_2           = $3B           ;$3B = 2
KEY_C           = $14           ;$14 = C
KEY_D           = $12           ;$12 = D
KEY_E           = $0E           ;$0E = E
KEY_F           = $15           ;$15 = F
KEY_N           = $27           ;$27 = N
KEY_T           = $16           ;$16 = T
KEY_V           = $1F           ;$1F = V
KEY_Y           = $19           ;$19 = Y
KEY_ESC         = $39           ;$39 = <-- (the key that is on the top left of the C64 keyboard (next to the '1'-key and above the 'control'-key))

;-------------------------------------------------------------------------------
;Read the keyboard and joystick, this routine converts the keycode to a control
;code that is easier to decode. This value is stored in A
;...............................................................................
SCAN_INPUTS     LDA ALLOW_KEYREPEAT     ;some functions/keys have keyrepeat, this makes it easier to scroll
                BNE SCAN_KEYPRESS       ;through a long list of filenames

SCAN_KEYRELEASE ;JSR SCAN_KEYBOARD       ;this line is only required when the interrups are switched off
                LDA $C5                 ;matrix value of last Key pressed
                CMP #KEY_NOTHING        ;check for key
                BNE SCAN_KEYRELEASE     ;continue loop when no key is detected
SCAN_KEYPRESS   JSR SCAN_KEYBOARD       ;because the interrupts are disabled during communication with the Cassiopei, the keyboard might not be updated and therefore the buffer value remains the same, which in real life is not correct, so we execute a manual keyboard scan
                LDA $C5                 ;matrix value of last Key pressed
                CMP #KEY_F3             ;and jump to the requested action
                BEQ SCAN_VAL_PREV       ;
                CMP #KEY_F5             ;
                BEQ SCAN_VAL_SELECT     ;
                CMP #KEY_F7             ;
                BEQ SCAN_VAL_NEXT       ; 
                CMP #KEY_D              ;
                BEQ SCAN_VAL_DIR        ;
                CMP #KEY_C              ;
                BEQ SCAN_VAL_CREATE
                CMP #KEY_ESC            ;
                BEQ SCAN_VAL_EXIT       ;
                CMP #KEY_F              ;
                BEQ SCAN_VAL_FNAME      ;
                CMP #KEY_N              ;
                BEQ SCAN_VAL_NO         ;
                CMP #KEY_Y              ;
                BEQ SCAN_VAL_YES        ;
SCAN_VAL_IDLE   LDA #1                  ;do not allow keyrepeat on this button
                STA ALLOW_KEYREPEAT     ;
                LDA #USER_INPUT_IDLE    ;nothing happened, send idle value
                RTS

SCAN_VAL_SELECT LDA #0                  ;do not allow keyrepeat on this button
                STA ALLOW_KEYREPEAT     ;
                LDA #USER_INPUT_SELECT  ;
                RTS

SCAN_VAL_PREV   LDA #1                  ;allow keyrepeat on this button
                STA ALLOW_KEYREPEAT     ;
                LDA #USER_INPUT_PREVIOUS;
                RTS

SCAN_VAL_NEXT   LDA #1                  ;allow keyrepeat on this button
                STA ALLOW_KEYREPEAT     ;
                LDA #USER_INPUT_NEXT    ;
                RTS

SCAN_VAL_CREATE LDA #0                  ;do not allow keyrepeat on this button
                STA ALLOW_KEYREPEAT     ;
                LDA #USER_INPUT_CREATE  ;
                RTS

SCAN_VAL_DIR    LDA #0                  ;do not allow keyrepeat on this button
                STA ALLOW_KEYREPEAT     ;
                LDA #USER_INPUT_DIR     ;
                RTS

SCAN_VAL_EXIT   LDA #0                  ;do not allow keyrepeat on this button
                STA ALLOW_KEYREPEAT     ;
                LDA #USER_INPUT_EXIT    ;
                RTS

SCAN_VAL_FNAME  LDA #0                  ;do not allow keyrepeat on this button
                STA ALLOW_KEYREPEAT     ;
                LDA #USER_INPUT_FILENAME;
                RTS

SCAN_VAL_NO     LDA #0                  ;do not allow keyrepeat on this button
                STA ALLOW_KEYREPEAT     ;
                LDA #USER_INPUT_NO      ;
                RTS

SCAN_VAL_YES    LDA #0                  ;do not allow keyrepeat on this button
                STA ALLOW_KEYREPEAT     ;
                LDA #USER_INPUT_YES     ;
                RTS


ALLOW_KEYREPEAT BYTE $0 ;this is a flag that indicates if keyrepeat is allowed (0=key repeat not alowed, 1=key repeat alowed)


;-------------------------------------------------------------------------------
;This routine will have the Z-flag set when no key is pressed
;call example   JSR CHECK_FOR_KEY
;               BNE <jump to wherever because a key was pressed>
;...............................................................................
CHECK_FOR_KEY   JSR SCAN_KEYBOARD       ;scan keyboard
                LDA $C5                 ;matrix value of last Key pressed
                CMP #KEY_NOTHING        ;check for key
                RTS                     ;

;-------------------------------------------------------------------------------
;This routine will wait until the user presses a key
;call example   JSR WAIT_FOR_KEY
;...............................................................................
WAIT_FOR_KEY    LDA #0                  ;clear keyboard buffer
                STA KEYCNT              ;
WAIT_FOR_KEY_01 JSR SCAN_KEYBOARD       ;because the interrupts are disabled during communication with the Cassiopei, the keyboard might not be updated and therefore the buffer value remains the same, which in real life is not correct, so we execute a manual keyboard scan
                LDA $C5                 ;matrix value of last Key pressed
                CMP #KEY_NOTHING        ;check for key
                BEQ WAIT_FOR_KEY_01     ;continue loop when no key is detected
                RTS                     ;

;-------------------------------------------------------------------------------
;This routine will wait until the user releases the keyboard
;call example   WAIT_KEY_RELEASE
;...............................................................................
WAIT_KEY_RELEASE
                LDA #0                  ;clear keyboard buffer
                STA KEYCNT              ;
WAIT_KEY_REL_01 JSR SCAN_KEYBOARD       ;because the interrupts are disabled during communication with the Cassiopei, the keyboard might not be updated and therefore the buffer value remains the same, which in real life is not correct, so we execute a manual keyboard scan
                LDA $C5                 ;matrix value of last Key pressed
                CMP #KEY_NOTHING        ;check for key
                BNE WAIT_KEY_REL_01     ;continue loop when no key is detected
                RTS                     ;


;-------------------------------------------------------------------------------
;This routine will wait until the user presses a key (which must be one of the possible choices)
;...............................................................................
CHOOSE
CHOOSE_RELEASE  LDA $C5                 ;matrix value of last Key pressed
                CMP #KEY_NOTHING        ;check for key
                BNE CHOOSE_RELEASE      ;continue loop when no key is detected

CHOOSE_LP       JSR SCAN_KEYBOARD       ;because the interrupts are disabled during communication with the Cassiopei, the keyboard might not be updated and therefore the buffer value remains the same, which in real life is not correct, so we execute a manual keyboard scan
                LDA $C5                 ;matrix value of last Key pressed
                CMP #KEY_NOTHING        ;check for key
                BEQ CHOOSE_LP           ;continue loop when no key is detected

                CMP #KEY_F1             ;and jump to the requested action
                BEQ SCAN_VAL_CHA        ;
                CMP #KEY_F3             ;
                BEQ SCAN_VAL_CHB        ;                
                JMP CHOOSE_LP           ;not a valid key, keep scanning

SCAN_VAL_CHA    LDA #USER_INPUT_CHA     ;
                RTS

SCAN_VAL_CHB    LDA #USER_INPUT_CHB     ;
                RTS

;-------------------------------------------------------------------------------
;Clear screen and set the color of the colorscreen
;Example:       JSR CLEAR_SCREEN
;...............................................................................
CLEAR_SCREEN    LDA #0                  ;make the screen and border black
                STA BORDER              ;
                STA BACKGROUND          ;

                LDY #0 
                LDA #$20                ;fill the screen with spaces
SETCHARACTER    STA CHARSCREEN+0,y      ;
                STA CHARSCREEN+256,y    ;
                STA CHARSCREEN+512,y    ;
                STA CHARSCREEN+745,y    ;            
                INY                     ;
                BNE SETCHARACTER        ;

                LDY #0                  ;
                LDA #1                  ;make all the characterpositions white
SETTEXTCOLOR    STA COLORSCREEN+0,y     ;
                STA COLORSCREEN+256,y   ;
                STA COLORSCREEN+512,y   ;
                STA COLORSCREEN+745,y   ;            
                INY                     ;
                BNE SETTEXTCOLOR        ;
                RTS                     ;

;-------------------------------------------------------------------------------
; The first location of the charsecreen (topleft) is defined as coordinate 0,0
; Use this routine before calling a PRINT related routine
;               LDX CURSOR_Y;.. chars from the top of the defined screen area
;               LDY CURSOR_X;.. chars from the left of the defined screen area
;               JSR SET_CURSOR
;...............................................................................

SET_CURSOR      LDA #<CHARSCREEN        ;
                STA CHAR_ADDR           ;store base address (low byte)
                LDA #>CHARSCREEN        ;
                STA CHAR_ADDR+1         ;store base address (high byte)

                ;calculate exact value based on the requested X and Y coordinate
                CLC                     ;
                TXA                     ;add  value in X register (to calculate the new X position of cursor)
                ADC CHAR_ADDR           ;                        
                STA CHAR_ADDR           ;
                LDA #$00                ;
                ADC CHAR_ADDR+1         ;add carry
                STA CHAR_ADDR+1         ;

SET_CURS_CHR_LP CPY #00                 ;
                BEQ SET_CURS_END        ;when Y is zero, calculation is done
                CLC                     ;clear carry for the upcoming "ADC CHAR_ADDR"

                LDA #40                 ;add  40 (which is the number of characters per line for most commodore computers) to calculate the new Y position of cursor
                ADC CHAR_ADDR           ;                        
                STA CHAR_ADDR           ;
                LDA #$00                ;
                ADC CHAR_ADDR+1         ;add carry... and viola, we have a new cursor position (memory location where next character will be printed)
                STA CHAR_ADDR+1         ;
                DEY                     ;
                JMP SET_CURS_CHR_LP     ;

SET_CURS_END    RTS                     ;


;-------------------------------------------------------------------------------
;call this routine as described below:
;
;               LDA #character          ;character is stored in Accumulator
;               JSR PRINT_CHAR          ;character is printed to screen, cursor is incremented by one
; also affects Y
; note: when the character value is 0 there is nothing printed but we do increment the cursor by one
;...............................................................................
PRINT_CHAR      BEQ PRINT_NOTHING       ;when the value = 0, we print nothing but we do increment the cursor by one
                ;CLC
                ;ADC CHAR_INVERT         ;invert character depending on the status of the  CHAR_INVERT-flag
                LDY #00                 ;
                STA (CHAR_ADDR),Y       ;character read from string (stored in A) is now written to screen memory (see C64 manual appendix E for screen display codes)

                ;increment character pointer
PRINT_NOTHING   CLC                     ;
                LDA #$01                ;add 1
                ADC CHAR_ADDR           ;                        
                STA CHAR_ADDR           ;
                LDA #$00                ;
                ADC CHAR_ADDR+1         ;add carry... and viola, we have a new cursor position (memory location where next character will be printed)
                STA CHAR_ADDR+1         ;

                RTS                     ;

;CHAR_INVERT     BYTE $0        ;flag to indicate whether or not the printed character should be inverted

;-------------------------------------------------------------------------------
;Prevent the use of shift+CBM to change the case of the screen.
;This must be prevented when screen are build with special characters.
;Example:       JSR PREVENT_CASE_CHANGE
;...............................................................................                
PREVENT_CASE_CHANGE
                LDA #128                ;disable shift+CBM
                STA $0291               ;

                RTS                     ;

;-------------------------------------------------------------------------------
;Allow the use of shift+CBM to change the case of the screen.
;Example:       JSR ALLOW_CASE_CHANGE
;...............................................................................                
ALLOW_CASE_CHANGE
                LDA #0                  ;enable shift+CBM
                STA $0291               ;
              
                RTS

;-------------------------------------------------------------------------------
;This routine will print extra computer specific information
;Example:       JSR SHOW_VERSION
;...............................................................................
SHOW_VERSION    LDX #1                  ;set cursor to top,left
                LDY #1                  ;
                JSR SET_CURSOR          ;
                LDA #<PRG_IDENTIFIER    ;set pointer to the text that defines the main-screen
                LDY #>PRG_IDENTIFIER    ;        
                JSR PRINT_STRING        ;the print routine is called, so the pointed text is now printed to screen     
               
                LDX #1                  ;set cursor to top,left
                LDY #2                  ;
                JSR SET_CURSOR          ;
                LDA #<VERSION_INFO      ;set pointer to the text that defines the main-screen
                LDY #>VERSION_INFO      ;        
                JSR PRINT_STRING        ;the print routine is called, so the pointed text is now printed to screen     

                RTS


;-------------------------------------------------------------------------------
endif   ;this endif belongs to "ifdef COMMODORE64"
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

##{0}F:\Projects\Cassiopei\Versie_2-Wifi\Software\CBM_software\Cassiopei_v2.0-Disk_Wizard\source\\02_4_Main.asm

;bug in menu code? or perhaps a C64 feature?: the joystick in PORT-1 might
;trigger a selection when moving wildly with the joystick AND when the last
;item in the list has been selected, the list of items does not need to be
;long, a 4 item list in de TAP file section is enough

;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ifdef COMMODORE128
;-------------------------------------------------------------------------------
BORDER          = $D020         ;bordercolour
BACKGROUND      = $D021         ;background-0
COLORSCREEN     = $D800         ;location of the color screen memory (this value is fixed)
CHARSCREEN      = $0400         ;location of the character screen memory
CHROUT          = $FFD2         ;
SCAN_KEYBOARD   = $FF9F         ;scans the keyboard and puts the matrix value in $C5

KEYCNT          = $D0           ;the counter that keeps track of the number of key in the keyboard buffer
KEYBUF          = $034A         ;the first position of the keyboard buffer
FKEYBUF         = $D1           ;buffer for the function key
KEYMATRIX       = $D5           ;the current keyboard matrix value
CURSORPOS_X     = 211           ;Cursor Column on Current Line (be aware that on a C64, position the cursor does not take effect immediately, only when a CR on the keyboard is send it will go there)
CURSORPOS_Y     = 214           ;Current Cursor Physical Line Number

TODCLK          = $A0           ;Time-Of-Day clock register (MSB)
;TODCLK+1       = $A1           ;Time-Of-Day clock register (.SB)
;TODCLK+2       = $A2           ;Time-Of-Day clock register (LSB)

;###############################################################################

;C128 keyboard scanning values (called by routine SCAN_KEYBOARD=$FF9F  key matrix value is available $D5)
;Do not rely on VICE only in testing these values, because the keyboard layout might be different then you would expect
KEY_NOTHING     = $58           ;when no key is pressed
KEY_F1          = $04           ;= F1
KEY_F3          = $05           ;= F3
KEY_F5          = $06           ;= F5
KEY_F7          = $03           ;= F7

;-------------------------------------------------------------------------------
;Read the keyboard and joystick, this routine converts the keycode to a control
;code that is easier to decode. This value is stored in A
;...............................................................................
SCAN_INPUTS     LDA ALLOW_KEYREPEAT     ;some functions/keys have keyrepeat, this makes it easier to scroll
                BNE SCAN_KEYPRESS       ;through a long list of filenames

SCAN_JOYRELEASE LDA #%00010000          ;fire
                BIT $DC01               ;joy#1
                BEQ SCAN_JOYRELEASE     ;
                BIT $DC00               ;joy#2
                BEQ SCAN_JOYRELEASE     ;

SCAN_KEYRELEASE LDA KEYMATRIX           ;matrix value of last Key pressed
                CMP #KEY_NOTHING        ;check for key
                BNE SCAN_KEYRELEASE     ;continue loop when no key is detected
SCAN_KEYPRESS   JSR SCAN_KEYBOARD       ;because the interrupts are disabled during communication with the Cassiopei, the keyboard might not be updated and therefore the buffer value remains the same, which in real life is not correct, so we execute a manual keyboard scan
                LDA KEYMATRIX           ;matrix value of last Key pressed
                CMP #KEY_F3             ;and jump to the requested action
                BEQ SCAN_VAL_PREV       ;
                CMP #KEY_F5             ;
                BEQ SCAN_VAL_SELECT     ;
                CMP #KEY_F7             ;
                BEQ SCAN_VAL_NEXT       ; 

SCAN_JOYSTICK   LDA #%00010000          ;fire
                BIT $DC01               ;joy#1
                BEQ SCAN_VAL_SELECT     ;
                BIT $DC00               ;joy#2
                BEQ SCAN_VAL_SELECT     ;

                LDA #%00000001          ;up
                BIT $DC01               ;joy#1
                BEQ SCAN_VAL_PREV       ;
                BIT $DC00               ;joy#2
                BEQ SCAN_VAL_PREV       ;

                LDA #%00000010          ;down
                BIT $DC01               ;joy#1
                BEQ SCAN_VAL_NEXT       ;
                BIT $DC00               ;joy#2
                BEQ SCAN_VAL_NEXT       ;

SCAN_VAL_IDLE   LDA #0                  ;do not allow keyrepeat on this button
                STA ALLOW_KEYREPEAT     ;
                LDA #USER_INPUT_IDLE    ;nothing happened, send idle value
                RTS                     ;

SCAN_VAL_SELECT LDA #0                  ;do not allow keyrepeat on this button
                STA ALLOW_KEYREPEAT     ;
                LDA #USER_INPUT_SELECT  ;
                RTS                     ;

SCAN_VAL_PREV   LDA #1                  ;do not allow keyrepeat on this button
                STA ALLOW_KEYREPEAT     ;
                LDA #USER_INPUT_PREVIOUS;
                RTS                     ;

SCAN_VAL_NEXT   LDA #1                  ;do not allow keyrepeat on this button
                STA ALLOW_KEYREPEAT     ;
                LDA #USER_INPUT_NEXT    ;
                RTS                     ;

ALLOW_KEYREPEAT BYTE $0 ;this is a flag that indicates if keyrepeat is allowed (0=key repeat not alowed, 1=key repeat alowed)


;-------------------------------------------------------------------------------
;This routine will wait until the user presses a key
;call example   JSR WAIT_FOR_KEY
;...............................................................................
WAIT_FOR_KEY    JSR SCAN_KEYBOARD       ;execute keyboard scan
                LDA KEYMATRIX           ;matrix value of last Key pressed
                CMP #KEY_NOTHING        ;check for key
                BEQ WAIT_FOR_KEY        ;continue loop when no key is detected
                RTS                     ;

;-------------------------------------------------------------------------------
;Clear screen and set the color of the colorscreen
;Example:       JSR CLEAR_SCREEN
;...............................................................................
CLEAR_SCREEN    LDA #0                  ;make the screen and border black
                STA BORDER              ;
                STA BACKGROUND          ;

                LDY #0 
                LDA #$20                ;fill the screen with spaces
SETCHARACTER    STA CHARSCREEN+0,y      ;
                STA CHARSCREEN+256,y    ;
                STA CHARSCREEN+512,y    ;
                STA CHARSCREEN+745,y    ;            
                INY                     ;
                BNE SETCHARACTER        ;

                LDY #0                  ;
                LDA #1                  ;make all the characterpositions white
SETTEXTCOLOR    STA COLORSCREEN+0,y     ;
                STA COLORSCREEN+256,y   ;
                STA COLORSCREEN+512,y   ;
                STA COLORSCREEN+745,y   ;            
                INY                     ;
                BNE SETTEXTCOLOR        ;
                RTS                     ;

;-------------------------------------------------------------------------------
; The first location of the charsecreen (topleft) is defined as coordinate 0,0
; Use this routine before calling a PRINT related routine
;               LDX CURSOR_Y;.. chars from the top of the defined screen area
;               LDY CURSOR_X;.. chars from the left of the defined screen area
;               JSR SET_CURSOR
;...............................................................................

SET_CURSOR      LDA #<CHARSCREEN        ;
                STA CHAR_ADDR           ;store base address (low byte)
                LDA #>CHARSCREEN        ;
                STA CHAR_ADDR+1         ;store base address (high byte)

                ;calculate exact value based on the requested X and Y coordinate
                CLC                     ;
                TXA                     ;add  value in X register (to calculate the new X position of cursor)
                ADC CHAR_ADDR           ;                        
                STA CHAR_ADDR           ;
                LDA #$00                ;
                ADC CHAR_ADDR+1         ;add carry
                STA CHAR_ADDR+1         ;

SET_CURS_CHR_LP CPY #00                 ;
                BEQ SET_CURS_END        ;when Y is zero, calculation is done
                CLC                     ;clear carry for the upcoming "ADC CHAR_ADDR"

                LDA #40                 ;add  40 (which is the number of characters per line for most commodore computers) to calculate the new Y position of cursor
                ADC CHAR_ADDR           ;                        
                STA CHAR_ADDR           ;
                LDA #$00                ;
                ADC CHAR_ADDR+1         ;add carry... and viola, we have a new cursor position (memory location where next character will be printed)
                STA CHAR_ADDR+1         ;
                DEY                     ;
                JMP SET_CURS_CHR_LP     ;

SET_CURS_END    RTS                     ;

;-------------------------------------------------------------------------------
;call this routine as described below:
;
;               LDA #character          ;character is stored in Accumulator
;               JSR PRINT_CHAR          ;character is printed to screen, cursor is incremented by one
; also affects Y
; note: when the character value is 0 there is nothing printed but we do increment the cursor by one
;...............................................................................
PRINT_CHAR      BEQ PRINT_NOTHING       ;when the value = 0, we print nothing but we do increment the cursor by one
                ;CLC
                ;ADC CHAR_INVERT         ;invert character depending on the status of the  CHAR_INVERT-flag
                LDY #00                 ;
                STA (CHAR_ADDR),Y       ;character read from string (stored in A) is now written to screen memory (see C64 manual appendix E for screen display codes)

                ;increment character pointer
PRINT_NOTHING   CLC                     ;
                LDA #$01                ;add 1
                ADC CHAR_ADDR           ;                        
                STA CHAR_ADDR           ;
                LDA #$00                ;
                ADC CHAR_ADDR+1         ;add carry... and viola, we have a new cursor position (memory location where next character will be printed)
                STA CHAR_ADDR+1         ;

                RTS                     ;

;CHAR_INVERT     BYTE $0        ;flag to indicate whether or not the printed character should be inverted


;-------------------------------------------------------------------------------
;Prevent the use of shift+CBM to change the case of the screen.
;This must be prevented when screen are build with special characters.
;Example:       JSR PREVENT_CASE_CHANGE
;...............................................................................                
PREVENT_CASE_CHANGE
                ;$C8A6 : Handles case switching disable character, CHR$(11) (mapping128.pdf on page:680)
                JSR $C8A6               ;DISABLE case changes caused by pressing CBM+shift
                RTS                     ;

;-------------------------------------------------------------------------------
;Allow the use of shift+CBM to change the case of the screen.
;Example:       JSR ALLOW_CASE_CHANGE
;...............................................................................                
ALLOW_CASE_CHANGE
                ;$C8AC : Handles case switching enable character, CHR$(12) (mapping128.pdf on page:680)
                JSR $C8AC               ;DISABLE case changes caused by pressing CBM+shift
                RTS

;-------------------------------------------------------------------------------
;This routine will print extra computer specific information
;Example:       JSR SHOW_VERSION
;...............................................................................
SHOW_VERSION    LDX #1                  ;set cursor to top,left
                LDY #1                  ;
                JSR SET_CURSOR          ;
                LDA #<PRG_IDENTIFIER    ;set pointer to the text that defines the main-screen
                LDY #>PRG_IDENTIFIER    ;        
                JSR PRINT_STRING        ;the print routine is called, so the pointed text is now printed to screen     
               
                LDX #1                  ;set cursor to top,left
                LDY #2                  ;
                JSR SET_CURSOR          ;
                LDA #<VERSION_INFO      ;set pointer to the text that defines the main-screen
                LDY #>VERSION_INFO      ;        
                JSR PRINT_STRING        ;the print routine is called, so the pointed text is now printed to screen     

                RTS

;-------------------------------------------------------------------------------
endif   ;this endif belongs to "ifdef COMMODORE128"
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

##{0}F:\Projects\Cassiopei\Versie_2-Wifi\Software\CBM_software\Cassiopei_v2.0-Disk_Wizard\source\\02_5_Main.asm

;bug in menu code? or perhaps a C64 feature?: the joystick in PORT-1 might
;trigger a selection when moving wildly with the joystick AND when the last
;item in the list has been selected, the list of items does not need to be
;long, a 4 item list in de TAP file section is enough

;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ifdef COMMODORE16PLUS4

SCANKEY         = $FF9F         ;scankey, value is in A (no key pressed is 0xFF)
GETKEY          = $FFE4         ;Put relevant value into A


CHROUT          = $FFD2         ;

BORDER          = $FF19         ;bordercolour
BACKGROUND      = $FF15         ;background-0
CHARSCREEN      = $0C00         ;location of the character screen memory
COLORSCREEN     = $0800         ;location of the color screen memory (this value cannot change)

KEYCNT          = $EF           ;the counter that keeps track of the number of key in the keyboard buffer
KEYBUF          = $0527         ;the first position of the keyboard buffer

CURSORPOS_X     = 202           ;Cursor Column on Current Line (be aware that on some computers i.e. the C64, position the cursor does not take effect immediately, only when a CR on the keyboard is send it will go there)
CURSORPOS_Y     = 205           ;Current Cursor Physical Line Number

TODCLK          = $A3           ;Time-Of-Day clock register (MSB) (TIME:$00A3-00A5, Real-time jiffy clock (approx) 1/60 sec)
;TODCLK+1       = $A1           ;Time-Of-Day clock register (.SB)
;TODCLK+2       = $A2           ;Time-Of-Day clock register (LSB)

;###############################################################################

;-- keycodes --
KEY_NOTHING     = $FF           ;when no key is pressed
KEY_F1          = $05
KEY_F2          = $09
KEY_F3          = $06
;KEY_RETURN      = $0D

;-------------------------------------------------------------------------------
;Read the keyboard and joystick, this routine converts the keycode to a control
;code that is easier to decode. This value is stored in A
;...............................................................................
SCAN_INPUTS     LDA ALLOW_KEYREPEAT     ;some functions/keys have keyrepeat, this makes it easier to scroll
                BNE SCAN_KEYPRESS       ;through a long list of filenames

SCAN_JOYRELEASE SEI                     ;disable interrupts, otherwise the keyboard scanning routine will screw things up
SCAN_JOYREL_LP1 LDA #$FF                ;this is crucial! because if we don't write $FF to $FD30 then
                STA $FD30               ;the F3 button would suddenly trigger the EXIT function (like presing fire or the escape button in the menu)
                LDA #$FA                ;$FA selects joy-1
                STA $FF08               ;write value to register to enable the joystick
                LDA $FF08               ;get the value of the selected joystick
                AND #%01000000          ;
                BEQ SCAN_JOYREL_LP1     ;keep looping until fire button is released                
                CLI                     ;enable interrupts again 

                SEI                     ;disable interrupts, otherwise the keyboard scanning routine will screw things up
SCAN_JOYREL_LP2 LDA #$FF                ;this is crucial! because if we don't write $FF to $FD30 then
                STA $FD30               ;the F3 button would suddenly trigger the EXIT function (like presing fire or the escape button in the menu)
                LDA #$FD                ;$FD selects joy-2
                STA $FF08               ;write value to register to enable the joystick
                LDA $FF08               ;get the value of the selected joystick
                CLI                     ;enable interrupts again 
                AND #%10000000          ;
                BEQ SCAN_JOYREL_LP2     ;keep looping until fire button is released                

SCAN_KEYRELEASE JSR SCANKEY             ;scankey, value is in A (no key pressed is 0xFF)
                CMP #KEY_NOTHING        ;check for "no key"
                BNE SCAN_KEYRELEASE     ;continue loop when key is still pressed
SCAN_KEYPRESS   JSR SCANKEY             ;scankey, value is in A (no key pressed is 0xFF)
                CMP #KEY_F1             ;
                BEQ SCAN_VAL_PREV       ;
                CMP #KEY_F2             ;
                BEQ SCAN_VAL_SELECT     ;
                CMP #KEY_F3             ;
                BEQ SCAN_VAL_NEXT       ;

SCAN_JOYSTICK   SEI                     ;disable interrupts, otherwise the keyboard scanning routine will screw things up
                LDA #$FF                ;this is crucial! because if we don't write $FF to $FD30 then
                STA $FD30               ;the F3 button would suddenly trigger the EXIT function (like presing fire or the escape button in the menu)
                LDA #$FA                ;$FA selects joy-1
                STA $FF08               ;write value to register to enable the joystick
                LDA $FF08               ;get the value of the selected joystick
                CLI                     ;enable interrupts again 
                CMP #%11111110          ;up of joy#1
                BEQ SCAN_VAL_PREV       ;
                CMP #%10111111          ;fire of joy#1
                BEQ SCAN_VAL_SELECT     ;
                CMP #%11111101          ;down of joy#1
                BEQ SCAN_VAL_NEXT       ;

                SEI                     ;disable interrupts, otherwise the keyboard scanning routine will screw things up
                LDA #$FF                ;this is crucial! because if we don't write $FF to $FD30 then
                STA $FD30               ;the F3 button would suddenly trigger the EXIT function (like presing fire or the escape button in the menu)
                LDA #$FD                ;$FD selects joy-2
                STA $FF08               ;write value to register to enable the joystick
                LDA $FF08               ;get the value of the selected joystick
                CLI                     ;enable interrupts again 
                CMP #%11111110          ;up of joy#2
                BEQ SCAN_VAL_PREV       ;
                CMP #%01111111          ;fire of joy#2
                BEQ SCAN_VAL_SELECT     ;
                CMP #%11111101          ;down of joy#2
                BEQ SCAN_VAL_NEXT       ;

SCAN_VAL_IDLE   LDA #1                  ;allow keyrepeat on this button
                STA ALLOW_KEYREPEAT     ;
                LDA #USER_INPUT_IDLE    ;nothing happened, send idle value
                RTS                     ;

SCAN_VAL_SELECT LDA #0                  ;do not allow keyrepeat on this button
                STA ALLOW_KEYREPEAT     ;
                LDA #USER_INPUT_SELECT  ;
                RTS                     ;

SCAN_VAL_PREV   LDA #1                  ;allow keyrepeat on this button
                STA ALLOW_KEYREPEAT     ;
                LDA #USER_INPUT_PREVIOUS;
                RTS                     ;

SCAN_VAL_NEXT   LDA #1                  ;allow keyrepeat on this button
                STA ALLOW_KEYREPEAT     ;
                LDA #USER_INPUT_NEXT    ;
                RTS                     ;

ALLOW_KEYREPEAT BYTE $0 ;this is a flag that indicates if keyrepeat is allowed (0=key repeat not alowed, 1=key repeat alowed)


;-------------------------------------------------------------------------------
;This routine will wait until the user presses a key
;call example   JSR WAIT_FOR_KEY
;...............................................................................
WAIT_FOR_KEY    JSR SCANKEY             ;scankey, value is in A (no key pressed is 0xFF)
                CMP #KEY_NOTHING        ;check for "no key"
                BNE WAIT_FOR_KEY        ;continue loop when key is still pressed

;-------------------------------------------------------------------------------
;Clear screen and set the color of the colorscreen
;Example:       JSR CLEAR_SCREEN
;...............................................................................
;-------------------------------------------------------------------------------
;clear screen and "paint it black" (just like the stones did)

CLEAR_SCREEN    LDA #0                  ;make the screen and border black
                STA BORDER              ;
                STA BACKGROUND          ;

                LDY #0 
                LDA #$20                ;fill the screen with spaces
SETCHARACTER    STA CHARSCREEN+0,y      ;
                STA CHARSCREEN+256,y    ;
                STA CHARSCREEN+512,y    ;
                STA CHARSCREEN+745,y    ;            
                INY                     ;
                BNE SETCHARACTER        ;

                LDY #0                  ;
                LDA #$71                ;make all the characterpositions white
SETTEXTCOLOR    STA COLORSCREEN+0,y     ;
                STA COLORSCREEN+256,y   ;
                STA COLORSCREEN+512,y   ;
                STA COLORSCREEN+745,y   ;            
                INY                     ;
                BNE SETTEXTCOLOR        ;


SET_CHARACT_SET LDA $FF07               ;
                ORA #%10000000          ;force to 256 characters charset, this also DISABLEs case changes caused by pressing CBM+shift
                STA $FF07               ;(by forcing to a 256 chars charset we set the font to the default case)

                LDA $FF12               ;First we have to tell that the characters should be fetched from RAM.
                AND #%11111011          ;
                STA $FF12               ;

                LDA $FF13               ;then we must tell the TED where the charset is located
                AND #%00000011          ;Bits 2-7 (of $FF13) determine, which page should be used
                ORA #%00100000          ;charset located at mem loc. $2000
                STA $FF13               ;

                RTS                     ;

;-------------------------------------------------------------------------------
; The first location of the charsecreen (topleft) is defined as coordinate 0,0
; Use this routine before calling a PRINT related routine
;               LDX CURSOR_Y;.. chars from the top of the defined screen area
;               LDY CURSOR_X;.. chars from the left of the defined screen area
;               JSR SET_CURSOR
;...............................................................................

SET_CURSOR      LDA #<CHARSCREEN        ;
                STA CHAR_ADDR           ;store base address (low byte)
                LDA #>CHARSCREEN        ;
                STA CHAR_ADDR+1         ;store base address (high byte)

                ;calculate exact value based on the requested X and Y coordinate
                CLC                     ;
                TXA                     ;add  value in X register (to calculate the new X position of cursor)
                ADC CHAR_ADDR           ;                        
                STA CHAR_ADDR           ;
                LDA #$00                ;
                ADC CHAR_ADDR+1         ;add carry
                STA CHAR_ADDR+1         ;

SET_CURS_CHR_LP CPY #00                 ;
                BEQ SET_CURS_END        ;when Y is zero, calculation is done
                CLC                     ;clear carry for the upcoming "ADC CHAR_ADDR"

                LDA #40                 ;add  40 (which is the number of characters per line for most commodore computers) to calculate the new Y position of cursor
                ADC CHAR_ADDR           ;                        
                STA CHAR_ADDR           ;
                LDA #$00                ;
                ADC CHAR_ADDR+1         ;add carry... and viola, we have a new cursor position (memory location where next character will be printed)
                STA CHAR_ADDR+1         ;
                DEY                     ;
                JMP SET_CURS_CHR_LP     ;

SET_CURS_END    RTS                     ;


;-------------------------------------------------------------------------------
;call this routine as described below:
;
;               LDA #character          ;character is stored in Accumulator
;               JSR PRINT_CHAR          ;character is printed to screen, cursor is incremented by one
; also affects Y
; note: when the character value is 0 there is nothing printed but we do increment the cursor by one
;...............................................................................
PRINT_CHAR      BEQ PRINT_NOTHING       ;when the value = 0, we print nothing but we do increment the cursor by one
                ;CLC
                ;ADC CHAR_INVERT         ;invert character depending on the status of the  CHAR_INVERT-flag
                LDY #00                 ;
                STA (CHAR_ADDR),Y       ;

                ;increment character pointer
PRINT_NOTHING   CLC                     ;
                LDA #$01                ;add 1
                ADC CHAR_ADDR           ;                        
                STA CHAR_ADDR           ;
                LDA #$00                ;
                ADC CHAR_ADDR+1         ;add carry... and viola, we have a new cursor position (memory location where next character will be printed)
                STA CHAR_ADDR+1         ;

                RTS                     ;

;CHAR_INVERT     BYTE $0        ;flag to indicate whether or not the printed character should be inverted

;-------------------------------------------------------------------------------
;Prevent the use of shift+CBM to change the case of the screen.
;This must be prevented when screen are build with special characters.
;Example:       JSR PREVENT_CASE_CHANGE
;...............................................................................                
PREVENT_CASE_CHANGE
                LDA $FF07               ;
                ORA #%10000000          ;force to 256 characters charset, this also DISABLEs case changes caused by pressing CBM+shift
                STA $FF07               ;(by forcing to a 256 chars charset we set the font to the default case)

                ;charset settings
         ;       LDA $FF12               ;First we have to tell that the characters should be fetched from RAM.
         ;       AND #%11111011          ;
         ;       STA $FF12               ;

         ;       LDA $FF13               ;then we must tell the TED where the charset is located
         ;       AND #%00000011          ;Bits 2-7 (of $FF13) determine, which page should be used
         ;       ORA #%00100000          ;charset located at mem loc. $2000
         ;       STA $FF13               

                RTS                     ;

;-------------------------------------------------------------------------------
;Allow the use of shift+CBM to change the case of the screen.
;Example:       JSR ALLOW_CASE_CHANGE
;...............................................................................                
ALLOW_CASE_CHANGE
                LDA #$08                ;default value
                STA $FF07               ;charset details

                ;charset settings
          ;      LDA #$C4                ;default value
          ;      STA $FF12               ;charset location
                
          ;      LDA #$D0                ;default value
          ;      STA $FF13               ;then we must tell the TED where the charset is located


                LDA #$71                ;set chracter color ($70=brightest luminance, $01=white) because the screen is black and C16 default charcolor is also black
                STA $053B               ;COLOR ($053B) Active attribute byte
              
                RTS


;-------------------------------------------------------------------------------
;This routine will print extra computer specific information
;Example:       JSR SHOW_VERSION
;...............................................................................
SHOW_VERSION    LDX #1                  ;set cursor to top,left
                LDY #1                  ;
                JSR SET_CURSOR          ;
                LDA #<PRG_IDENTIFIER    ;set pointer to the text that defines the main-screen
                LDY #>PRG_IDENTIFIER    ;        
                JSR PRINT_STRING        ;the print routine is called, so the pointed text is now printed to screen     
               
                LDX #1                  ;set cursor to top,left
                LDY #2                  ;
                JSR SET_CURSOR          ;
                LDA #<VERSION_INFO      ;set pointer to the text that defines the main-screen
                LDY #>VERSION_INFO      ;        
                JSR PRINT_STRING        ;the print routine is called, so the pointed text is now printed to screen     

                RTS



;-------------------------------------------------------------------------------
endif   ;this endif belongs to "ifdef COMMODORE16PLUS4"
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

##{0}F:\Projects\Cassiopei\Versie_2-Wifi\Software\CBM_software\Cassiopei_v2.0-Disk_Wizard\source\\03_0_CPIO_routines.asm

;When the ATN signal goes down (end of attention) but the rises again very shortly
;afterwards it could be missed by the Cassiopei. Because the Cassiopei cannot
;confirm that ATN has been dropped. To make sure that the Cassiopei will not miss
;a falling attention signal a safe backoff time must be created. This routine will
;wait for 100ms. which is enough for he Cassiopei to detect.
;
;Although this routine is to be called after atn has been dropped, it would make
;programming more difficult because the read and write routines are generic and
;cannot really see if it is the last byte transmitted/received. Therefore the
;best place to call this routine is before start (or from within start).
;Because then it is always present and cannot be forgotten.

CPIO_BACKOFF    
                LDY #100                
BCKOFF_01       LDX #65         ;this loop will run for 1 ms (with screen=enabled, interrupts=enabled)

BCKOFF_02       PHA             ;3 cycles (1 cycle is 1,0149729 us (PAL))
                PLA             ;4 cycles
                DEX             ;2 cycles
                BNE BCKOFF_02   ;2 cycles

                DEY             ;2 cycles
                BNE BCKOFF_01   ;2 cycles

                RTS


##{0}F:\Projects\Cassiopei\Versie_2-Wifi\Software\CBM_software\Cassiopei_v2.0-Disk_Wizard\source\\03_1_CPIO_routines.asm

;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ifdef COMMODOREPET20XX or COMMODOREPET30XX or COMMODOREPET40XX or COMMODOREPET80XX
;-------------------------------------------------------------------------------

;///////////////////////////////////////////////////////////////////////////////
;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
;
;            C P I O   r o u t i n  e s   ( 30XX series (i.e. the PET-3032 ))
;
;///////////////////////////////////////////////////////////////////////////////
;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

;*******************************************************************************
; Cassette Port Input Output protocol initialisation
;******************************************************************************* 
CPIO_INIT       ;lower ATTENTION-line (cassette motor line)
                LDA $E813               ;peripheral control register of 6520 (PIA) (IC7 as indicated on 320349)
                ORA #%00001000          ;CB2 high (motor=OFF) Attention signal = NO ATTENTION (cassette motor line)
                STA $E813               ;

                ;raise CLOCK-line (cassette write-line)
                LDA $E842               ;data direction register of 6520 (PIA) (IC5 as indicated on 320349)
                ORA #%00001000          ;define PB3 as an output (make the DDR bit high)
                STA $E842               ;

                LDA $E840               ;data register of 6520 (PIA) (IC5 as indicated on 320349)
                ORA #%00001000          ;make PB3 high, raises CLOCK-line (cassette write-line)
                STA $E840               ;

                                        ;set the READ-line properties (CA1 interrupt settings to falling edge)
                                        ;Peripheral control register of 6520(IC7 as indicated on 320349), we need to trigger on falling edges
                LDA #%00111100          ;CA1 triggers on negative edge
                STA $E811               ;set PIA 1 CRA

                
                ;DATA-line (cassette button sense-line) must be set to an input (it is also pulled high by a resistor)
DATALINE_2INPUT JSR USE_PIA_DIR         ;select writing to the data-direction register (to define input and output) PIA1
                LDA $E810               ;data direction register of 6520 (PIA) (IC5 as indicated on 320349)
                AND #%11101111          ;define PA4, DATA-line (cassette sense-line), as an input (make the DDR bit low)
                STA $E810               ;
                ;JSR USE_PIA_DATA       ;select writing to the data-register (to define the states of the output(s) or read the input(s)) PIA1
                ;RTS                    ;

                ;select writing to the data-direction register (to define input and output) PIA1
USE_PIA_DATA    LDA $E811               ;Auxilary control register of 6520 (PIA) (IC5 as indicated on 320349)
                ORA #%00000100          ;set bit-2 to use the data-register (which is very important if we want to read or write data to the IO-port)
                STA $E811               ;
                RTS                     ;return to caller

                ;select writing to the data-register (to define the states of the output(s) or read the input(s)) PIA1
USE_PIA_DIR     LDA $E811               ;Auxilary control register of 6520 (PIA) (IC5 as indicated on 320349)
                AND #%11111011          ;clear bit-2 to use the data-direction-register (which is very important if we want to set the port pins to input or output)
                STA $E811               ;
                RTS                     ;return to caller

;*******************************************************************************
; JSR CPIO_WAIT4RDY     ;wait untill the slave signals that it is ready
;
        ;this routine just keeps polling the 6520(IC7 as indicated on 340349)

CPIO_WAIT4RDY   LDA $E811               ;get the interrupt flags of 6520 (reading port A of the 6520 clears the int flags, so there is no need for a clearing action)
                AND #%10000000          ;mask out bit CA1
                BEQ CPIO_WAIT4RDY       ;keep looping until the flag is set
                RTS                     ;return to caller


;*******************************************************************************
;LDA <data>     ;data is the requested operating mode of the slave
;JSR CPIO_START  ;raise attention signal, now communication is set up, we can read or write data from this point
CPIO_START      STA CPIO_DATA           ;store value in A (which holds the mode-byte) to working register
                JSR CPIO_BACKOFF    ;make sure that the attention low signal is long enough low to be detected by the Cassiopei (placing it here ensures that 2 sequential but different data transfers are separated by a long enough low state of the ATN signal)
                SEI                     ;disable interrupts
                LDA $E813               ;peripheral control register of 6520 (PIA) (IC7 as indicated on 320349)
                AND #%11110111          ;CB2 low (motor=ON) Attention signal = ATTENTION (cassette motor line)
                STA $E813               ;
                JMP SEND_DATA           ;send the mode byte to the slave

;*******************************************************************************
;this routine will lower the attention to indicate that the current is the last byte
CPIO_SEND_LAST  STA CPIO_DATA           ;safe the data (stored in the accu) to a working register

                JSR CPIO_WAIT4RDY       ;wait untill the slave signals that it is ready (we must check it now, otherwise the information about the edge will be lost, because the next routines will read and alter E811 and therefore destroy the possible detected edge)

                LDA $E813               ;peripheral control register of 6522 (VIA) (IC7 as indicated on 320349)
                ORA #%00001000          ;CB2 high (motor=OFF) Attention signal = NO ATTENTION (cassette motor line)
                STA $E813               ;with the attention signal being low (motor-off) the slave has been notified that communication has come to an end and that the current byte is the last byte within this session

                LDY #$08                ;every byte consists of 8 bits, this will be use in the CPIO_send and CPIO_recieve routine which are calling this routine
                JMP SEND_DATA_00        ;
;...............................................................................
;this routine will send a byte to the slave
;LDA <data>
;JSR CPIO_SEND

CPIO_SEND       STA CPIO_DATA           ;safe the data (stored in the accu) to a working register
SEND_DATA       LDY #$08                ;every byte consists of 8 bits, this will be use in the CPIO_send and CPIO_recieve routine which are calling this routine

                JSR CPIO_WAIT4RDY       ;wait untill the slave signals that it is ready (we must check it now, otherwise the information about the edge will be lost, because the next routines will read and alter E811 and therefore destroy the possible detected edge)

SEND_DATA_00    JSR USE_PIA_DIR         ;select writing to the data-direction register
                LDA $E810               ;data direction register of 6520 (PIA) (IC5 as indicated on 320349)
                ORA #%00010000          ;define PA4, DATA-line (cassette sense-line), as an output (make the DDR bit high)
                STA $E810               ;

                JSR USE_PIA_DATA        ;in order to write data to the IO-lines we must make this possible by selecting the data-register
                LDA $E810               ;data register of 6520 (PIA) (IC5 as indicated on 320349)
                ORA #%00010000          ;make PA4 high, DATA-line (cassette sense-line)
                STA $E810               ;
                
SEND_DATA_LP
SEND_CLOCK_0    LDA $E840               ;data register of 6522 (VIA) (IC5 as indicated on 320349)
                AND #%11110111          ;make PB3 low, lowers CLOCK-line (cassette write-line)
                STA $E840               ;

                BIT CPIO_DATA           ;bit moves bit-7 of CPIO_DATA into the N-flag of the status register
                BPL SEND_ZERO           ;BPL tests the N-flag, when it is 0 the branch to SEND_ZERO is executed (using the BIT instruction instead of conventional masking, we save 2 cycles, and 2 bytes)
SEND_ONE        LDA $E810               ;data register of 6520 (PIA) (IC5 as indicated on 320349)
                ORA #%00010000          ;make PA4 high, DATA-line (cassette sense-line)
                JMP SEND_BIT            ;
SEND_ZERO       LDA $E810               ;data register of 6520 (PIA) (B3)
                AND #%11101111          ;make PA4 low, DATA-line (cassette sense-line)

SEND_BIT        STA $E810               ;

SEND_CLOCK_1    LDA $E840               ;data register of 6522 (VIA) (IC5 as indicated on 320349)
                ORA #%00001000          ;make PB3 high, raises CLOCK-line (cassette write-line)
                STA $E840               ;

                ASL CPIO_DATA           ;rotate data in order to send each individual bit, we do it here so that we save time, we have to wait for the clock pulse high-time anyway

                DEY                     ;decrement the Y value
                BNE SEND_DATA_LP        ;exit loop after the eight bit


                ;make clock line low, the slave now reads the last bit of the data
                LDA $E840               ;data register of 6522 (VIA) (IC5 as indicated on 320349)
                AND #%11110111          ;make PB3 low, lowers CLOCK-line (cassette write-line)
                STA $E840               ;
                ;make clock line high, to indicate that the byte has come to an end
                ORA #%00001000          ;make PB3 high, raises CLOCK-line (cassette write-line)
                STA $E840               ;
                
                JSR DATALINE_2INPUT     ;DATA-line (cassette button sense-line), this is an input that is pulled up (so there is no need for us to make it high)

                RTS                     ;end of subroutine

;*******************************************************************************
;this routine will lower the attention to indicate that the current is the last byte
CPIO_REC_LAST   JSR CPIO_WAIT4RDY       ;wait untill the slave signals that it is ready                

                LDA $E813               ;peripheral control register of 6520 (PIA) (IC7 as indicated on 320349)
                ORA #%00001000          ;CB2 high (motor=OFF) Attention signal = NO ATTENTION (cassette motor line)
                STA $E813               ;with the attention signal being low (motor-off) the slave has been notified that communication has come to an end and that the current byte is the last byte within this session

                LDY #$08                ;every byte consists of 8 bits, this will be use in the CPIO_send and CPIO_recieve routine which are calling this routine
                JMP REC_DATA_LP         ;
;...............................................................................

;this routine will recieve a byte to the slave
;JSR CPIO_RECIEVE
;data is in Accu

CPIO_RECIEVE    LDY #$08                ;every byte consists of 8 bits, this will be use in the CPIO_send and CPIO_recieve routine which are calling this routine
                JSR CPIO_WAIT4RDY       ;wait untill the slave signals that it is ready

REC_DATA_LP
REC_CLOCK_0     LDA $E840               ;data register of 6522 (VIA) (IC5 as indicated on 320349)
                AND #%11110111          ;make PB3 low, lowers CLOCK-line (cassette write-line)
                STA $E840               ;make clock line low, the slave now prepares the data to be send


                CLC                     ;clear the carry, which is usefull for the ADC later, we clear it here in order to make the clock=0 time 2 cycles longer (keeps our clock duty cycle closer to 50% (which is allways nice))
REC_CLOCK_1     LDA $E840               ;data register of 6522 (VIA) (IC5 as indicated on 320349)
                ORA #%00001000          ;make PB3 high, raises CLOCK-line (cassette write-line)
                STA $E840               ;

                LDA $E810               ;data register of 6522 (VIA) (IC5 as indicated on 320349) (this register holds the DATA-line PA4)
                AND #%00010000          ;test input signal for '0' or '1'
                ADC #%11111111          ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA           ;shift all the bits one position to the right and add the LSB which is located in the carry

                DEY                     ;decrement the Y value
                BNE REC_DATA_LP         ;exit loop after the eight bit

                LDA $E840               ;data register of 6522 (VIA) (IC5 as indicated on 320349)
                AND #%11110111          ;make PB3 low, lowers CLOCK-line (cassette write-line)
                STA $E840               ;
                ;make clock line high, this indicates to the slave that the master has read the data
                ORA #%00001000          ;make PB3 high, raises CLOCK-line (cassette write-line)
                STA $E840               ;
                
                LDA CPIO_DATA           ;move data to accu
                RTS                     ;end of subroutine

;-------------------------------------------------------------------------------
endif   ;this endif belongs to "ifdef COMMODOREPET20XX or COMMODOREPET30XX or COMMODOREPET40XX or COMMODOREPET80XX"
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


##{0}F:\Projects\Cassiopei\Versie_2-Wifi\Software\CBM_software\Cassiopei_v2.0-Disk_Wizard\source\\03_2_CPIO_routines.asm

;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ifdef COMMODOREVIC20
;-------------------------------------------------------------------------------

DATA_DIR_6510   = $00   ;the MOS6510 data direction register of the peripheral IO pins (P7-0)
DATA_BIT_6510   = $01   ;the MOS6510 value f the bits of the peripheral IO pins (P7-0)

;###############################################################################


;///////////////////////////////////////////////////////////////////////////////
;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
;
;            C P I O   r o u t i n  e s   ( f o r   t h e   V I C - 2 0 )
;
;///////////////////////////////////////////////////////////////////////////////
;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

;let op: omdat de write lijn van de cassettepoort aan de keyboard matrix vastzit
;moeten we er rekening mee houden dat CPIO en keyboard niet samen gaan
;dus interrupts uit of zo

;               ;lower ATTENTION-line (this signal is inverted therefore we need to write a '1' into the reg.)
;               LDA $911C               ;Attention signal = NO ATTENTION
;               ORA #%00001110          ;CA2 high (motor=OFF)
;               STA $911C               ;

;               ;raise ATTENTION-line (this signal is inverted therefore we need to write a '0' into the reg.)
;               LDA $911C               ;Attention signal = ATTENTION
;               ORA #%00001100          ;define IO CA to proper mode
;               AND #%11111101          ;CA2 low (motor=ON)
;               STA $911C               ;


;*******************************************************************************
; Cassette Port Input Output protocol initialisation
;******************************************************************************* 
CPIO_INIT       ;lower ATTENTION-line (cassette motor line)
                LDA $911C               ;peripheral control register of 6522(B3)
                ORA #%00001110          ;CA2 high (motor=OFF) Attention signal = NO ATTENTION
                STA $911C               ;

                ;raise CLOCK-line (cassette write-line)
                LDA $9122               ;data direction register of 6522(B1)
                ORA #%00001000          ;define PB3 as an output (make the DDR bit high)
                STA $9122               ;

                LDA $9120               ;data register of 6522(B1)
                ORA #%00001000          ;make PB3 high
                STA $9120               ;

                ;raise DATA-line (cassette button sense-line)
                LDA $911B               ;Auxilary control register of 6522(B3)
                AND #%11111110          ;clear bit 0 to disable latch on port A
                STA $911B               ;this setting is required further on in the code when we will use this pin as an INPUT

                LDA $9113               ;data direction register of 6522(B3)
                ORA #%01000000          ;define PA6 as an output
                STA $9113               ;

                LDA $911F               ;data register of 6522(B3)
                ORA #%01000000          ;make PA6 high
                STA $911F               ;


                ;set the READ-line properties (CA1 interrupt settings to falling edge)
                                        ;Peripheral control register of 6522(B1), we need to trigger on falling edges
                LDA #$DE                ;CB2 low, serial data out high, CB1 +ve edge, CA2 high, serial clock out low, CA1 -ve edge
                STA $912C               ;set VIA 2 PCR
        
                LDA #$82                ;enable CA1 interrupt
                STA $912E               ;set VIA 2 IER, enable interrupts

                RTS                     ;return to caller

;*******************************************************************************
; JSR CPIO_WAIT4RDY     ;wait untill the slave signals that it is ready
;
        ;this routine just keeps polling the 6522(B1)

CPIO_WAIT4RDY   LDA $912D               ;get the interrupt flags of 6522(B1)
                AND #%00000010          ;mask out bit CA1
                BEQ CPIO_WAIT4RDY       ;keep looping until the flag is set
                
                LDA $9121               ;reading port A of the 6522 clears the int flags
                RTS                     ;return to caller


;*******************************************************************************
;LDA <data>     ;data is the requested operating mode of the slave
;JSR CPIO_START  ;raise attention signal, now communication is set up, we can read or write data from this point
CPIO_START      STA CPIO_DATA       ;store value in A (which holds the mode-byte) to working register

                JSR CPIO_BACKOFF    ;make sure that the attention low signal is long enough low to be detected by the Cassiopei (placing it here ensures that 2 sequential but different data transfers are separated by a long enough low state of the ATN signal)

                SEI                 ;disable interrupts
  ;--this is a C64 line--;   LDA $DC0D           ;reading clears all flags, so when we do a Read here we clear the old interrupts so that our routines will trigger on the correct event (instead of an old unhandled event)
               
                LDA $911C           ;Attention signal = ATTENTION
                ORA #%00001100      ;define IO CA to proper mode
                AND #%11111101      ;CA2 low (motor=ON)
                STA $911C           ;

                JMP SEND_DATA       ;send the mode byte to the slave


;*******************************************************************************
;this routine will lower the attention to indicate that the current is the last byte
CPIO_SEND_LAST  STA CPIO_DATA       ;safe the data (stored in the accu) to a working register
                LDY #$08            ;every byte consists of 8 bits, this will be use in the CPIO_send and CPIO_recieve routine which are calling this routine

                JSR CPIO_WAIT4RDY   ;wait untill the slave signals that it is ready

                LDA $911C           ;Attention signal = NO ATTENTION
                ORA #%00001110      ;CA2 high (motor=OFF)
                STA $911C           ;with the attention signal being low (motor-off) the slave has been notified that communication has come to an end and that the current byte is the last byte within this session

                LDA $9113           ;data direction register of 6522(B3)
                ORA #%01000000      ;define PA6 (data line) as an output
                STA $9113           ;

                JMP SEND_DATA_LP
;...............................................................................
;this routine will send a byte to the slave
;LDA <data>
;JSR CPIO_SEND

CPIO_SEND       STA CPIO_DATA       ;safe the data (stored in the accu) to a working register
SEND_DATA       LDY #$08            ;every byte consists of 8 bits, this will be use in the CPIO_send and CPIO_recieve routine which are calling this routine

                LDA $9113           ;data direction register of 6522(B3)
                ORA #%01000000      ;define PA6 (data line) as an output
                STA $9113           ;

                JSR CPIO_WAIT4RDY   ;wait untill the slave signals that it is ready
                
SEND_DATA_LP
SEND_CLOCK_0    LDA $9120           ;data register of 6522(B1)
                AND #%11110111      ;make clock line low              
                STA $9120           ;

                BIT CPIO_DATA       ;bit moves bit-7 of CPIO_DATA into the N-flag of the status register
                BPL SEND_ZERO       ;BPL tests the N-flag, when it is 0 the branch to SEND_ZERO is executed (using the BIT instruction instead of conventional masking, we save 2 cycles, and 2 bytes)
SEND_ONE        LDA $911F           ;data register of 6522(B3)
                ORA #%01000000      ;make PA6 high
                JMP SEND_BIT        ;
SEND_ZERO       LDA $911F           ;data register of 6522(B3)
                AND #%10111111      ;make PA6 low

SEND_BIT        STA $911F           ;
SEND_CLOCK_1    LDA $9120           ;data register of 6522(B1)
                ORA #%00001000      ;make clock line high
                STA $9120           ;

                ASL CPIO_DATA       ;rotate data in order to send each individual bit, we do it here so that we save time, we have to wait for the clock pulse high-time anyway

                DEY                 ;decrement the Y value
                BNE SEND_DATA_LP    ;exit loop after the eight bit

                LDA $9120           ;data register of 6522(B1)
                AND #%11110111      ;make clock line low, the slave now reads the last bit of the data
                STA $9120           ;
                ORA #%00001000      ;make clock line high, to indicate that the byte has come to an end
                STA $9120           ;

                LDA $9113           ;data direction register of 6522(B3)
                AND #%10111111      ;define PA6 (data line) as an input
                STA $9113           ;

                RTS                 ;end of subroutine

;*******************************************************************************
;This routine will lower the attention to indicate that the current is the last byte
;
;example:       JSR CPIO_REC_LAST
;               data is in Accu
;...............................................................................
CPIO_REC_LAST   JSR CPIO_WAIT4RDY   ;wait untill the slave signals that it is ready

                LDA $911C           ;Attention signal = NO ATTENTION
                ORA #%00001110      ;CA2 high (motor=OFF)
                STA $911C           ;with the attention signal being low (motor-off) the slave has been notified that communication has come to an end and that the current byte is the last byte within this session

                LDY #$08            ;every byte consists of 8 bits, this will be use in the CPIO_send and CPIO_recieve routine which are calling this routine

REC_DATA_LP
REC_CLOCK_0     LDA $9120           ;data register of 6522(B1)
                AND #%11110111      ;make clock line low, the slave now prepares the data to be send
                STA $9120           ;

                LDA #$0             ;clear CPIO_DATA because it's value will eventually end up in the carry (because of ROL) and might screw up the ADC calculation
                STA CPIO_DATA       ;
                CLC                 ;clear the carry, which is usefull for the ADC later, we clear it here in order to make the clock=0 time 2 cycles longer (keeps our clock duty cycle closer to 50% (which is allways nice))
REC_CLOCK_1     LDA $9120           ;
                ORA #%00001000      ;make clock line high
                STA $9120           ;

                LDA $911F           ;read data line
                AND #%01000000      ;test input signal for '0' or '1'
                ADC #%11111111      ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA       ;shift all the bits one position to the right and add the LSB which is located in the carry

                DEY                 ;decrement the Y value
                BNE REC_DATA_LP     ;exit loop after the eight bit

                LDA $9120           ;data register of 6522(B1)
                AND #%11110111      ;make clock line low, the slave now prepares the data to be send
                STA $9120           ;(this indicates to the slave that the master has read the data)
                ORA #%00001000      ;make clock line high to return to the default state
                STA $9120           ;
                
                LDA CPIO_DATA       ;move data to accu
                RTS                 ;end of subroutine


;*******************************************************************************
;this is an unrolled version of the CPIO_RECIEVE routine optimized for speed
;
;example:       JSR CPIO_RECIEVE
;               data is in Accu
;
;Attention: affects X and Y register
;...............................................................................
CPIO_RECIEVE    
                ;wait untill the slave signals that it is ready
                LDA #%00000010          ;the bitmask
CPIO_REC_W4R    BIT $912D               ;get the interrupt flags of 6522(B1)
                BEQ CPIO_REC_W4R        ;keep looping until the flag is set                
                LDA $9121               ;reading port A of the 6522 clears the int flags

                LDA $9120               ;data register of 6522(B1)
                AND #%11110111          ;make clock line low, the slave now prepares the data to be send
                STA $9120               ;
                TAX                     ;save for later use 
                ORA #%00001111          ;calculate state of write line (CLOCK) set to '1' (also set the memory configuration bits to a defined state, we choose to set them to the default state for a C64)
                TAY                     ;save for later use
                NOP                     ; waste time to honor the data setup times...
                NOP                     ;

                LDA #$00                ;must be zero, because every bit goes (because of the ROL instruction) through the carry and the carry must remain cleared
                STA CPIO_DATA           ;
                CLC                     ;clear the carry, which is usefull for the ADC later, we clear it here in order to make the clock=0 time 2 cycles longer (keeps our clock duty cycle closer to 50% (which is allways nice))

                ;bit 7
                STY $9120               ;changing state of write line (CLOCK) to '1', indicating that the data will be sampled
                LDA $911F               ;sample the data
                STX $9120               ;changing state of write line (CLOCK) to '0', this enables the Cassiopei to setup the mext databit
               AND #%01000000      ;test input signal for '0' or '1'
               ADC #%11111111      ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA           ;shift all the bits one position and add the LSB which is located in the carry

                ;bit 6
                STY $9120               ;changing state of write line (CLOCK) to '1', indicating that the data will be sampled
                LDA $911F               ;sample the data
                STX $9120               ;changing state of write line (CLOCK) to '0', this enables the Cassiopei to setup the mext databit
               AND #%01000000      ;test input signal for '0' or '1'
               ADC #%11111111      ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA           ;shift all the bits one position and add the LSB which is located in the carry

                ;bit 5
                STY $9120               ;changing state of write line (CLOCK) to '1', indicating that the data will be sampled
                LDA $911F               ;sample the data
                STX $9120               ;changing state of write line (CLOCK) to '0', this enables the Cassiopei to setup the mext databit
               AND #%01000000      ;test input signal for '0' or '1'
               ADC #%11111111      ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA           ;shift all the bits one position and add the LSB which is located in the carry

                ;bit 4
                STY $9120               ;changing state of write line (CLOCK) to '1', indicating that the data will be sampled
                LDA $911F               ;sample the data
                STX $9120               ;changing state of write line (CLOCK) to '0', this enables the Cassiopei to setup the mext databit
               AND #%01000000      ;test input signal for '0' or '1'
               ADC #%11111111      ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA           ;shift all the bits one position and add the LSB which is located in the carry

                ;bit 3
                STY $9120               ;changing state of write line (CLOCK) to '1', indicating that the data will be sampled
                LDA $911F               ;sample the data
                STX $9120               ;changing state of write line (CLOCK) to '0', this enables the Cassiopei to setup the mext databit
               AND #%01000000      ;test input signal for '0' or '1'
               ADC #%11111111      ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA           ;shift all the bits one position and add the LSB which is located in the carry

                ;bit 2
                STY $9120               ;changing state of write line (CLOCK) to '1', indicating that the data will be sampled
                LDA $911F               ;sample the data
                STX $9120               ;changing state of write line (CLOCK) to '0', this enables the Cassiopei to setup the mext databit
               AND #%01000000      ;test input signal for '0' or '1'
               ADC #%11111111      ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA           ;shift all the bits one position and add the LSB which is located in the carry

                ;bit 1
                STY $9120               ;changing state of write line (CLOCK) to '1', indicating that the data will be sampled
                LDA $911F               ;sample the data
                STX $9120               ;changing state of write line (CLOCK) to '0', this enables the Cassiopei to setup the mext databit
               AND #%01000000      ;test input signal for '0' or '1'
               ADC #%11111111      ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA           ;shift all the bits one position and add the LSB which is located in the carry

                ;bit 0
                STY $9120               ;changing state of write line (CLOCK) to '1', indicating that the data will be sampled
                LDA $911F               ;sample the data
                STX $9120               ;changing state of write line (CLOCK) to '0', this enables the Cassiopei to setup the mext databit
               AND #%01000000      ;test input signal for '0' or '1'
               ADC #%11111111      ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA           ;shift all the bits one position and add the LSB which is located in the carry

                STY $9120               ;changing state of write line (CLOCK) to '1', the idle state of this signal
                
                LDA CPIO_DATA       ;move data to accu
                RTS                 ;end of subroutine
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



;-------------------------------------------------------------------------------
endif   ;this endif belongs to "ifdef COMMODOREVIC20"
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

##{0}F:\Projects\Cassiopei\Versie_2-Wifi\Software\CBM_software\Cassiopei_v2.0-Disk_Wizard\source\\03_3_CPIO_routines.asm

;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ifdef COMMODORE64
;-------------------------------------------------------------------------------
DATA_DIR_6510   = $00           ;the MOS6510 data direction register of the peripheral IO pins (P7-0)
DATA_BIT_6510   = $01           ;the MOS6510 value f the bits of the peripheral IO pins (P7-0)

;###############################################################################

;///////////////////////////////////////////////////////////////////////////////
;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
;
;              C P I O   r o u t i n e s   ( f o r   t h e   C 6 4 )
;
;///////////////////////////////////////////////////////////////////////////////
;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


;*******************************************************************************
; Cassette Port Input Output protocol initialisation
;******************************************************************************* 
CPIO_INIT       LDA DATA_BIT_6510   ;
                ORA #%00101000      ;P5: lower ATTENTION-line (this signal is inverted therefore we need to write a '1' into the reg.) by the power stage that drives the motor-line
                STA DATA_BIT_6510   ;P3: raise CLOCK-line (cassette write-line)               

                LDA DATA_DIR_6510   ;data direction register of the MOS6510
                AND #%11101111      ;set the direction of the DATA-line (cassette button sense-line) to input
                STA DATA_DIR_6510   ;data direction register of the MOS6510

                RTS

;*******************************************************************************
;JSR CPIO_WAIT4RDY   ;wait until the CPIO device (slave) is ready

CPIO_WAIT4RDY   LDA $DC0D           ;read CIA connected to the cassetteport (reading clears the state of the bits)
                AND #%00010000      ;mask out bit 4
                BEQ CPIO_WAIT4RDY   ;loop until the slave lowers the read signal              
                RTS

;*******************************************************************************
;LDA <data>     ;data is the requested operating mode of the slave
;JSR CPIO_START  ;raise attention signal, now communication is set up, we can read or write data from this point
CPIO_START      STA CPIO_DATA       ;store value in A (which holds the mode-byte) to working register

                JSR CPIO_BACKOFF    ;make sure that the attention low signal is long enough low to be detected by the Cassiopei (placing it here ensures that 2 sequential but different data transfers are separated by a long enough low state of the ATN signal)

                SEI                 ;disable interrupts
                LDA $DC0D           ;reading clears all flags, so when we do a Read here we clear the old interrupts so that our routines will trigger on the correct event (instead of an old unhandled event)
               
                LDA DATA_BIT_6510   ;set ATTENTION signal to make slave prepare for communication
                AND #%11011111      ;motor control line is set to 0 (MOTOR is now ON (6 volt))
                STA DATA_BIT_6510   ;

                JMP SEND_DATA       ;send the mode byte to the slave

;*******************************************************************************
;this routine will lower the attention to indicate that the current is the last byte
CPIO_SEND_LAST  STA CPIO_DATA       ;safe the data (stored in the accu) to a working register

                LDA DATA_DIR_6510   ;data direction register of the MOS6510
                ORA #%00010000      ;set the direction of the sense line to output
                STA DATA_DIR_6510   ;data direction register of the MOS6510

                JSR CPIO_WAIT4RDY   ;wait until the CPIO device (slave) is ready
                
                LDA DATA_BIT_6510   ;send a '0'
                ORA #%00100000      ;motor control line is set to 1 (MOTOR is now OFF (0 Volt))
                STA DATA_BIT_6510   ;with the attention signal being low (motor-off) the slave has been notified that communication has come to an end and that the current byte is the last byte within this session

                LDY #$08            ;every byte consists of 8 bits, this will be use in the CPIO_send and CPIO_recieve routine which are calling this routine
                JMP SEND_DATA_LP    ;
;...............................................................................
;this routine will send a byte to the slave
;LDA <data>
;JSR CPIO_SEND

CPIO_SEND       STA CPIO_DATA       ;safe the data (stored in the accu) to a working register
SEND_DATA       LDY #$08            ;every byte consists of 8 bits, this will be use in the CPIO_send and CPIO_recieve routine which are calling this routine

                LDA DATA_DIR_6510   ;data direction register of the MOS6510
                ORA #%00010000      ;set the direction of the sense line to output
                STA DATA_DIR_6510   ;data direction register of the MOS6510

                JSR CPIO_WAIT4RDY   ;wait until the CPIO device (slave) is ready                
SEND_DATA_LP
SEND_CLOCK_0    LDA DATA_BIT_6510   ;lower clock
                AND #%11110111      ;change state of write line to '0'
                STA DATA_BIT_6510   ;    

                BIT CPIO_DATA       ;bit moves bit-7 of CPIO_DATA into the N-flag of the status register
                BPL SEND_ZERO       ;BPL tests the N-flag, when it is 0 the branch to SEND_ZERO is executed (using the BIT instruction instead of conventional masking, we save 2 cycles, and 2 bytes)
SEND_ONE        LDA DATA_BIT_6510   ;
                ORA #%00010000      ;change state of sense line to '1'
                JMP SEND_BIT        ;
SEND_ZERO       LDA DATA_BIT_6510   ;
                AND #%11101111      ;change state of sense line to '0'

SEND_BIT        STA DATA_BIT_6510   ;
SEND_CLOCK_1   ; LDA DATA_BIT_6510  ;raise clock to indicate data is ready for the slave to be read
                ORA #%00001000      ;change state of write line to '1'
                STA DATA_BIT_6510   ;
                ASL CPIO_DATA       ;rotate data in order to send each individual bit, we do it here so that we save time, we have to wait for the clock pulse high-time anyway

                DEY                 ;decrement the Y value
                BNE SEND_DATA_LP    ;exit loop after the eight bit

                LDA DATA_BIT_6510   ;
                AND #%11110111      ;lower the clock line so that the slave has the opportunity to read the data
                STA DATA_BIT_6510   ;
                ORA #%00001000      ;raise clock by changing state of write line to '1' to indicate that the byte has come to an end
                STA DATA_BIT_6510   ;

                LDA DATA_DIR_6510   ;data direction register of the MOS6510
                AND #%11101111      ;set the direction of the sense line to input
                STA DATA_DIR_6510   ;data direction register of the MOS6510
                RTS                 ;end of subroutine


;*******************************************************************************
;this routine will lower the attention to indicate that the current is the last byte
CPIO_REC_LAST   JSR CPIO_WAIT4RDY   ;wait until the CPIO device (slave) is ready

                LDA DATA_BIT_6510   ;send a '0'
                ORA #%00100000      ;motor control line is set to 1 (MOTOR is now OFF (0 Volt))
                STA DATA_BIT_6510   ;with the attention signal being low (motor-off) the slave has been notified that communication has come to an end and that the current byte is the last byte within this session

                LDA #$01            ;the LSB is one,but after eight ROL's it will end up in the carry, which we can detect and use to end our loop
                STA CPIO_DATA       ;by using our working data destination register we do not require a CLC on every bit check and we don't need a DEY after every bit
                CLC                 ;clear the carry as it could be set by a previous routine

                TYA
                PHA
                TXA
                PHA
        
                LDA DATA_BIT_6510       ;lower clock
                AND #%11110111          ;calculate state of write line (CLOCK) cleared to '0'
                STA DATA_BIT_6510       ;APPLY
                TAX                     ;save for later use 
                ORA #%00001000          ;calculate state of write line (CLOCK) set to '1'
                TAY                     ;save for later use
                CLC                     ;clear the carry, which is usefull for the ADC further on, because the  ROL will clear it otherwise.
        
REC_DATA_LP     
REC_CLOCK_1     STY DATA_BIT_6510       ;changing state of write line (CLOCK) to '1', indicating that the data will be sampled
                LDA DATA_BIT_6510       ;sample the data
REC_CLOCK_0     STX DATA_BIT_6510       ;changing state of write line (CLOCK) to '0', this enables the Cassiopei to setup the mext databit
                AND #%00010000          ;test input signal for '0' or '1'
                ADC #%11111111          ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA           ;shift all the bits one position to the right and add the LSB which is located in the carry
                BCC REC_DATA_LP         ;keep loopin untill the Carry becomes set (which will be after 8 ROL's)

                STY DATA_BIT_6510       ;changing state of write line (CLOCK) to '1'

                PLA
                TAX
                PLA
                TAY

                LDA CPIO_DATA           ;move data to accu
                RTS                     ;end of subroutine



;*******************************************************************************
;this is an unrolled version of the CPIO_RECIEVE routine optimized for speed
;-------------------------------------------------------------------------------
;this routine will recieve a byte to the slave
;JSR CPIO_RECIEVE
;data is in Accu
;
;Attention: affects X and Y register
;...............................................................................
CPIO_RECIEVE    
CPIO_REC_01     ;wait until the CPIO device (slave) is ready  
                LDA #%00010000      ;mask out bit 4
CPIO_REC_W4R    BIT $DC0D           ;read CIA connected to the cassetteport (reading clears the state of the bits)
                BEQ CPIO_REC_W4R    ;loop until the slave lowers the read signal              

                LDA DATA_BIT_6510       ;lower clock
                AND #%11110111          ;calculate state of write line (CLOCK) cleared to '0'
                STA DATA_BIT_6510       ;APPLY
                TAX                     ;save for later use 
                ORA #%00001000          ;calculate state of write line (CLOCK) set to '1'
                TAY                     ;save for later use
                LDA #$00                ;must be zero, because every bit goes (because of the ROL instruction) through the carry and the carry must remain cleared
                STA CPIO_DATA           ;
                CLC                     ;clear the carry, which is usefull for the ADC further on, because the  ROL will clear it otherwise.
        
                ;bit 7
                STY DATA_BIT_6510       ;changing state of write line (CLOCK) to '1', indicating that the data will be sampled
                LDA DATA_BIT_6510       ;sample the data
                STX DATA_BIT_6510       ;changing state of write line (CLOCK) to '0', this enables the Cassiopei to setup the mext databit
                AND #%00010000          ;test input signal for '0' or '1'
                ADC #%11111111          ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA           ;shift all the bits one position and add the LSB which is located in the carry

                ;bit 6
                STY DATA_BIT_6510       ;changing state of write line (CLOCK) to '1', indicating that the data will be sampled
                LDA DATA_BIT_6510       ;sample the data
                STX DATA_BIT_6510       ;changing state of write line (CLOCK) to '0', this enables the Cassiopei to setup the mext databit
                AND #%00010000          ;test input signal for '0' or '1'
                ADC #%11111111          ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA           ;shift all the bits one position and add the LSB which is located in the carry

                ;bit 5
                STY DATA_BIT_6510       ;changing state of write line (CLOCK) to '1', indicating that the data will be sampled
                LDA DATA_BIT_6510       ;sample the data
                STX DATA_BIT_6510       ;changing state of write line (CLOCK) to '0', this enables the Cassiopei to setup the mext databit
                AND #%00010000          ;test input signal for '0' or '1'
                ADC #%11111111          ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA           ;shift all the bits one position and add the LSB which is located in the carry

                ;bit 4
                STY DATA_BIT_6510       ;changing state of write line (CLOCK) to '1', indicating that the data will be sampled
                LDA DATA_BIT_6510       ;sample the data
                STX DATA_BIT_6510       ;changing state of write line (CLOCK) to '0', this enables the Cassiopei to setup the mext databit
                AND #%00010000          ;test input signal for '0' or '1'
                ADC #%11111111          ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA           ;shift all the bits one position and add the LSB which is located in the carry

                ;bit 3
                STY DATA_BIT_6510       ;changing state of write line (CLOCK) to '1', indicating that the data will be sampled
                LDA DATA_BIT_6510       ;sample the data
                STX DATA_BIT_6510       ;changing state of write line (CLOCK) to '0', this enables the Cassiopei to setup the mext databit
                AND #%00010000          ;test input signal for '0' or '1'
                ADC #%11111111          ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA           ;shift all the bits one position and add the LSB which is located in the carry

                ;bit 2
                STY DATA_BIT_6510       ;changing state of write line (CLOCK) to '1', indicating that the data will be sampled
                LDA DATA_BIT_6510       ;sample the data
                STX DATA_BIT_6510       ;changing state of write line (CLOCK) to '0', this enables the Cassiopei to setup the mext databit
                AND #%00010000          ;test input signal for '0' or '1'
                ADC #%11111111          ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA           ;shift all the bits one position and add the LSB which is located in the carry

                ;bit 1
                STY DATA_BIT_6510       ;changing state of write line (CLOCK) to '1', indicating that the data will be sampled
                LDA DATA_BIT_6510       ;sample the data
                STX DATA_BIT_6510       ;changing state of write line (CLOCK) to '0', this enables the Cassiopei to setup the mext databit
                AND #%00010000          ;test input signal for '0' or '1'
                ADC #%11111111          ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA           ;shift all the bits one position and add the LSB which is located in the carry

                ;bit 0
                STY DATA_BIT_6510       ;changing state of write line (CLOCK) to '1', indicating that the data will be sampled
                LDA DATA_BIT_6510       ;sample the data
                STX DATA_BIT_6510       ;changing state of write line (CLOCK) to '0', this enables the Cassiopei to setup the mext databit
                AND #%00010000          ;test input signal for '0' or '1'
                ADC #%11111111          ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA           ;shift all the bits one position and add the LSB which is located in the carry

                STY DATA_BIT_6510       ;changing state of write line (CLOCK) to '1'

                LDA CPIO_DATA           ;move data to accu
                RTS                     ;end of subroutine

;-------------------------------------------------------------------------------
endif   ;this endif belongs to "ifdef COMMODORE64"
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

##{0}F:\Projects\Cassiopei\Versie_2-Wifi\Software\CBM_software\Cassiopei_v2.0-Disk_Wizard\source\\03_4_CPIO_routines.asm

;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ifdef COMMODORE128
;-------------------------------------------------------------------------------

DATA_DIR_6510   = $00           ;the MOS6510 data direction register of the peripheral IO pins (P7-0)
DATA_BIT_6510   = $01           ;the MOS6510 value f the bits of the peripheral IO pins (P7-0)

;###############################################################################

;///////////////////////////////////////////////////////////////////////////////
;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
;
;                      C128 C P I O   r o u t i n e s
;
;///////////////////////////////////////////////////////////////////////////////
;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

;this routine solves a problem caused by the kernal routines, that may switch memory config.
;kernal routines may switch bank when handling variables and the problem is that these
;routines do NOT switch back to the bank they came from!!! So we need to correct this every
;time we want to acces IO, just to be sure it'll work.

SELECT_CORRECT_BANK     LDA #$00     ;00  Storing this value in FF00
                        STA $FF00    ;causes the C128 to take up its "normal" BANK 15 configuration (if we don't then the IO isn't always visible)
                        RTS          ;

;*******************************************************************************
; Cassette Port Input Output protocol initialisation
;******************************************************************************* 
CPIO_INIT       LDA DATA_BIT_6510   ;
                ORA #%00101000      ;P5: lower ATTENTION-line (this signal is inverted therefore we need to write a '1' into the reg.) by the power stage that drives the motor-line
                STA DATA_BIT_6510   ;P3: raise CLOCK-line (cassette write-line)               

                LDA DATA_DIR_6510   ;data direction register of the MOS6510
                AND #%11101111      ;set the direction of the DATA-line (cassette button sense-line) to input
                STA DATA_DIR_6510   ;data direction register of the MOS6510

                RTS

;*******************************************************************************
;JSR CPIO_WAIT4RDY   ;wait until the CPIO device (slave) is ready

CPIO_WAIT4RDY   JSR SELECT_CORRECT_BANK ;the current memory configuration may be the wrong one, correct this!
CPIO_WAIT4R_LP  LDA $DC0D               ;read CIA connected to the cassetteport (reading clears the state of the bits)
                AND #%00010000          ;mask out bit 4
                BEQ CPIO_WAIT4R_LP      ;loop until the slave lowers the read signal              
        
                RTS

;*******************************************************************************
;LDA <data>     ;data is the requested operating mode of the slave
;JSR CPIO_START  ;raise attention signal, now communication is set up, we can read or write data from this point
CPIO_START      STA CPIO_DATA           ;store value in A (which holds the mode-byte) to working register

                SEI                     ;disable interrupts
                JSR SELECT_CORRECT_BANK ;the current memory configuration may be the wrong one, correct this!
                LDA $DC0D               ;reading clears all flags, so when we do a Read here we clear the old interrupts so that our routines will trigger on the correct event (instead of an old unhandled event)
               
                LDA DATA_BIT_6510       ;set ATTENTION signal to make slave prepare for communication
                AND #%11011111          ;motor control line is set to 0 (MOTOR is now ON (6 volt))
                STA DATA_BIT_6510       ;

                JMP SEND_DATA           ;send the mode byte to the slave


;*******************************************************************************
;this routine will lower the attention to indicate that the current is the last byte
CPIO_SEND_LAST  STA CPIO_DATA       ;safe the data (stored in the accu) to a working register

                LDA DATA_DIR_6510   ;data direction register of the MOS6510
                ORA #%00010000      ;set the direction of the sense line to output
                STA DATA_DIR_6510   ;data direction register of the MOS6510

                JSR CPIO_WAIT4RDY   ;wait until the CPIO device (slave) is ready
                
                LDA DATA_BIT_6510   ;send a '0'
                ORA #%00100000      ;motor control line is set to 1 (MOTOR is now OFF (0 Volt))
                STA DATA_BIT_6510   ;with the attention signal being low (motor-off) the slave has been notified that communication has come to an end and that the current byte is the last byte within this session

                LDY #$08            ;every byte consists of 8 bits, this will be use in the CPIO_send and CPIO_recieve routine which are calling this routine
                JMP SEND_DATA_LP    ;
;...............................................................................
;this routine will send a byte to the slave
;LDA <data>
;JSR CPIO_SEND

CPIO_SEND       STA CPIO_DATA       ;safe the data (stored in the accu) to a working register
SEND_DATA       LDY #$08            ;every byte consists of 8 bits, this will be use in the CPIO_send and CPIO_recieve routine which are calling this routine

                LDA DATA_DIR_6510   ;data direction register of the MOS6510
                ORA #%00010000      ;set the direction of the sense line to output
                STA DATA_DIR_6510   ;data direction register of the MOS6510

                JSR CPIO_WAIT4RDY   ;wait until the CPIO device (slave) is ready                
SEND_DATA_LP
SEND_CLOCK_0    LDA DATA_BIT_6510   ;lower clock
                AND #%11110111      ;change state of write line to '0'
                STA DATA_BIT_6510   ;    

                BIT CPIO_DATA       ;bit moves bit-7 of CPIO_DATA into the N-flag of the status register
                BPL SEND_ZERO       ;BPL tests the N-flag, when it is 0 the branch to SEND_ZERO is executed (using the BIT instruction instead of conventional masking, we save 2 cycles, and 2 bytes)
SEND_ONE        LDA DATA_BIT_6510   ;
                ORA #%00010000      ;change state of sense line to '1'
                JMP SEND_BIT        ;
SEND_ZERO       LDA DATA_BIT_6510   ;
                AND #%11101111      ;change state of sense line to '0'

SEND_BIT        STA DATA_BIT_6510   ;
SEND_CLOCK_1   ; LDA DATA_BIT_6510  ;raise clock to indicate data is ready for the slave to be read
                ORA #%00001000      ;change state of write line to '1'
                STA DATA_BIT_6510   ;
                ASL CPIO_DATA       ;rotate data in order to send each individual bit, we do it here so that we save time, we have to wait for the clock pulse high-time anyway

                DEY                 ;decrement the Y value
                BNE SEND_DATA_LP    ;exit loop after the eight bit

                LDA DATA_BIT_6510   ;
                AND #%11110111      ;lower the clock line so that the slave has the opportunity to read the data
                STA DATA_BIT_6510   ;
                ORA #%00001000      ;raise clock by changing state of write line to '1' to indicate that the byte has come to an end
                STA DATA_BIT_6510   ;

                LDA DATA_DIR_6510   ;data direction register of the MOS6510
                AND #%11101111      ;set the direction of the sense line to input
                STA DATA_DIR_6510   ;data direction register of the MOS6510
                RTS                 ;end of subroutine

;*******************************************************************************
;this routine will lower the attention to indicate that the current is the last byte
CPIO_REC_LAST   JSR CPIO_WAIT4RDY   ;wait until the CPIO device (slave) is ready

                LDA DATA_BIT_6510   ;send a '0'
                ORA #%00100000      ;motor control line is set to 1 (MOTOR is now OFF (0 Volt))
                STA DATA_BIT_6510   ;with the attention signal being low (motor-off) the slave has been notified that communication has come to an end and that the current byte is the last byte within this session

TESTME          LDA #$01            ;the LSB is one,but after eight ROL's it will end up in the carry, which we can detect and use to end our loop
                STA CPIO_DATA       ;by using our working data destination register we do not require a CLC on every bit check and we don't need a DEY after every bit
                CLC                 ;clear the carry as it could be set by a previous routine

                TYA
                PHA
                TXA
                PHA
        
                LDA DATA_BIT_6510       ;lower clock
                AND #%11110111          ;calculate state of write line (CLOCK) cleared to '0'
                STA DATA_BIT_6510       ;APPLY
                TAX                     ;save for later use 
                ORA #%00001000          ;calculate state of write line (CLOCK) set to '1'
                TAY                     ;save for later use
                CLC                     ;clear the carry, which is usefull for the ADC further on, because the  ROL will clear it otherwise.
        
REC_DATA_LP     
REC_CLOCK_1     STY DATA_BIT_6510       ;changing state of write line (CLOCK) to '1', indicating that the data will be sampled
                LDA DATA_BIT_6510       ;sample the data
REC_CLOCK_0     STX DATA_BIT_6510       ;changing state of write line (CLOCK) to '0', this enables the Cassiopei to setup the mext databit
                AND #%00010000          ;test input signal for '0' or '1'
                ADC #%11111111          ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA           ;shift all the bits one position to the right and add the LSB which is located in the carry
                BCC REC_DATA_LP         ;keep loopin untill the Carry becomes set (which will be after 8 ROL's)

                STY DATA_BIT_6510       ;changing state of write line (CLOCK) to '1'

                PLA
                TAX
                PLA
                TAY

                LDA CPIO_DATA           ;move data to accu
                RTS                     ;end of subroutine

;*******************************************************************************
;this is an unrolled version of the CPIO_RECIEVE routine optimized for speed
;-------------------------------------------------------------------------------
;this routine will recieve a byte to the slave
;JSR CPIO_RECIEVE
;data is in Accu
;
;Attention: affects X and Y register
;...............................................................................
CPIO_RECIEVE    
CPIO_REC_01     ;wait until the CPIO device (slave) is ready  
                LDA #%00010000      ;mask out bit 4
CPIO_REC_W4R    BIT $DC0D           ;read CIA connected to the cassetteport (reading clears the state of the bits)
                BEQ CPIO_REC_W4R    ;loop until the slave lowers the read signal              

                LDA DATA_BIT_6510       ;lower clock
                AND #%11110111      ;change state of write line to '0'
                STA DATA_BIT_6510       ;APPLY
                TAX                     ;save for later use 
                ORA #%00001000          ;calculate state of write line (CLOCK) set to '1'
                TAY                     ;save for later use
                LDA #$00                ;must be zero, because every bit goes (because of the ROL instruction) through the carry and the carry must remain cleared
                STA CPIO_DATA           ;
                CLC                     ;clear the carry, which is usefull for the ADC further on, because the  ROL will clear it otherwise.
        
                ;bit 7
                STY DATA_BIT_6510       ;changing state of write line (CLOCK) to '1', indicating that the data will be sampled
                LDA DATA_BIT_6510       ;sample the data
                STX DATA_BIT_6510       ;changing state of write line (CLOCK) to '0', this enables the Cassiopei to setup the mext databit
                AND #%00010000          ;test input signal for '0' or '1'
                ADC #%11111111          ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA           ;shift all the bits one position and add the LSB which is located in the carry

                ;bit 6
                STY DATA_BIT_6510       ;changing state of write line (CLOCK) to '1', indicating that the data will be sampled
                LDA DATA_BIT_6510       ;sample the data
                STX DATA_BIT_6510       ;changing state of write line (CLOCK) to '0', this enables the Cassiopei to setup the mext databit
                AND #%00010000          ;test input signal for '0' or '1'
                ADC #%11111111          ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA           ;shift all the bits one position and add the LSB which is located in the carry

                ;bit 5
                STY DATA_BIT_6510       ;changing state of write line (CLOCK) to '1', indicating that the data will be sampled
                LDA DATA_BIT_6510       ;sample the data
                STX DATA_BIT_6510       ;changing state of write line (CLOCK) to '0', this enables the Cassiopei to setup the mext databit
                AND #%00010000          ;test input signal for '0' or '1'
                ADC #%11111111          ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA           ;shift all the bits one position and add the LSB which is located in the carry

                ;bit 4
                STY DATA_BIT_6510       ;changing state of write line (CLOCK) to '1', indicating that the data will be sampled
                LDA DATA_BIT_6510       ;sample the data
                STX DATA_BIT_6510       ;changing state of write line (CLOCK) to '0', this enables the Cassiopei to setup the mext databit
                AND #%00010000          ;test input signal for '0' or '1'
                ADC #%11111111          ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA           ;shift all the bits one position and add the LSB which is located in the carry

                ;bit 3
                STY DATA_BIT_6510       ;changing state of write line (CLOCK) to '1', indicating that the data will be sampled
                LDA DATA_BIT_6510       ;sample the data
                STX DATA_BIT_6510       ;changing state of write line (CLOCK) to '0', this enables the Cassiopei to setup the mext databit
                AND #%00010000          ;test input signal for '0' or '1'
                ADC #%11111111          ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA           ;shift all the bits one position and add the LSB which is located in the carry

                ;bit 2
                STY DATA_BIT_6510       ;changing state of write line (CLOCK) to '1', indicating that the data will be sampled
                LDA DATA_BIT_6510       ;sample the data
                STX DATA_BIT_6510       ;changing state of write line (CLOCK) to '0', this enables the Cassiopei to setup the mext databit
                AND #%00010000          ;test input signal for '0' or '1'
                ADC #%11111111          ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA           ;shift all the bits one position and add the LSB which is located in the carry

                ;bit 1
                STY DATA_BIT_6510       ;changing state of write line (CLOCK) to '1', indicating that the data will be sampled
                LDA DATA_BIT_6510       ;sample the data
                STX DATA_BIT_6510       ;changing state of write line (CLOCK) to '0', this enables the Cassiopei to setup the mext databit
                AND #%00010000          ;test input signal for '0' or '1'
                ADC #%11111111          ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA           ;shift all the bits one position and add the LSB which is located in the carry

                ;bit 0
                STY DATA_BIT_6510       ;changing state of write line (CLOCK) to '1', indicating that the data will be sampled
                LDA DATA_BIT_6510       ;sample the data
                STX DATA_BIT_6510       ;changing state of write line (CLOCK) to '0', this enables the Cassiopei to setup the mext databit
                AND #%00010000          ;test input signal for '0' or '1'
                ADC #%11111111          ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA           ;shift all the bits one position and add the LSB which is located in the carry

                STY DATA_BIT_6510       ;changing state of write line (CLOCK) to '1'

                LDA CPIO_DATA           ;move data to accu
                RTS                     ;end of subroutine

TMP_X           BYTE $0
TMP_Y           BYTE $0

;-------------------------------------------------------------------------------
endif   ;this endif belongs to "ifdef COMMODORE128"
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

##{0}F:\Projects\Cassiopei\Versie_2-Wifi\Software\CBM_software\Cassiopei_v2.0-Disk_Wizard\source\\03_5_CPIO_routines.asm

;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ifdef COMMODORE16PLUS4
;-------------------------------------------------------------------------------
DATA_DIR_7501   = $00           ;the 7501/8501 register to controll the IEC serial port and cassette signals
DATA_BIT_7501   = $01           ;the 7501/8501 register to controll the CPU own io lines data direction register
CASS_SENSE      = $FD10         ;the casse sense signal is I/O mapped  to FD10-FD1F and connected to bit 2 of the databus


;###############################################################################

;///////////////////////////////////////////////////////////////////////////////
;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
;
;                    C P I O   r o u t i n  e s   f o r   C 1 6
;
;///////////////////////////////////////////////////////////////////////////////
;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\



;0001h - CPU 7501/8501 On-Chip I/O Port Data (Cassette, Serial, User Port)
;--------------------------------------------------------------------------
;  Bit Dir Expl.
;  7   In  Serial Data In (and PLUS/4: Cas Sense) (0=Low, 1=High)
;  6   In  Serial Clock In                        (0=Low, 1=High)
;  5   -   Not used (no pin-out on 7501/8501)     (N/A)
;  4   In  Cassette Read                          (0=Low, 1=High)
;  3   Out Cassette Motor                         (0=9VDC, 1=Off) (Inverted !!)
;  2   Out Serial ATN Out (and PLUS/4: User Port) (0=High, 1=Low) (Inverted)
;  1   Out Serial Clock Out, Cassette Write       (0=High, 1=Low) (Inverted !!)
;  0   Out Serial Data Out                        (0=High, 1=Low) (Inverted !!)

;Switch Serial Clock/Data Outputs HIGH before reading Clock/Data Inputs.




;FD10h-FD1Fh - Cassette Sense / User Port 8bit Parallel I/O
;--------------------------------------------------------------------------
;  7-0 User Port 6529B, 8bit Parallel I/O   (PLUS/4 Only)
;  2   Cassette Sense In                    (C16 and C116 Only)

;Note: On the PLUS/4, the Cassette Sense signal has moved to Port 0001h/Bit7, exchanging the J8,J9 jumpers switches the Plus/4 to C16 compatible mode.


;as you'be noticed the C16 isn't capable of following the C64/VIC20's pinout for CPIO communication, why? well
;because the C16 has the cassette sense line is only available in 1 direction, so it cannot act as a bi-directional dataline (thanks to a 74LS125)
;however the cassette read signal IS bi-directional, so we can use this line as the data line, since the Cassiopei is mostly software and the IO-pins
;can be redirected in software this will mean that the C16 can be made to work with the CPIO protocol as long as the read and sense lines are controlled
;in the proper way. Only software...

;*******************************************************************************
; Cassette Port Input Output protocol initialisation
;******************************************************************************* 
CPIO_INIT       LDA DATA_BIT_7501   ;
                ORA #%00001010      ;lower ATTENTION-line (3=cass motor:this signal is inverted), raise Clock signal (1=cass write)
                STA DATA_BIT_7501   ;

                LDA DATA_DIR_7501   ;
                AND #%11101111      ;read line is set to input (0=input, 1=output)
                STA DATA_DIR_7501   ;

                RTS

;*******************************************************************************
;LDA <data>     ;data is the requested operating mode of the slave
;JSR CPIO_START  ;raise attention signal, now communication is set up, we can read or write data from this point
CPIO_START      STA CPIO_DATA       ;store value in A (which holds the mode-byte) to working register

                JSR CPIO_BACKOFF    ;make sure that the attention low signal is long enough low to be detected by the Cassiopei (placing it here ensures that 2 sequential but different data transfers are separated by a long enough low state of the ATN signal)

                SEI                 ;disable interrupts
               
                LDA DATA_BIT_7501   ;set ATTENTION signal to make slave prepare for communication
                AND #%11110111      ;cassette motor ON (motor is turning)
                STA DATA_BIT_7501   ;

                JMP SEND_DATA       ;send the mode byte to the slave


;*******************************************************************************
;this routine will lower the attention to indicate that the current is the last byte
CPIO_SEND_LAST  STA CPIO_DATA       ;safe the data (stored in the accu) to a working register
                JSR WAIT_FOR_READY  ;wait until slave acknowledges that it is ready

                LDA DATA_BIT_7501   ;
                ORA #%00001000      ;cassette motor OFF (motor does not move) (attention, this line is inverted: 0=ON, 1=OFF)
                STA DATA_BIT_7501   ;

                LDA DATA_DIR_7501   ;the READ line is used to transfer the DATA so it must be set as an output (because this is the SEND routine)
                ORA #%00010000      ;read line is set to output (0=input, 1=output)
                STA DATA_DIR_7501   ;

                LDY #$08            ;every byte consists of 8 bits, this will be use in the CPIO_send and CPIO_recieve routine which are calling this routine
                JMP SEND_DATA_LP

;...............................................................................
;this routine will send a byte to the slave
;LDA <data>
;JSR CPIO_SEND

CPIO_SEND       STA CPIO_DATA       ;safe the data (stored in the accu) to a working register
SEND_DATA       LDY #$08            ;every byte consists of 8 bits, this will be use in the CPIO_send and CPIO_recieve routine which are calling this routine

                LDA DATA_DIR_7501   ;the READ line is used to transfer the DATA so it must be set as an output (because this is the SEND routine)
                ORA #%00010000      ;read line is set to output (0=input, 1=output)
                STA DATA_DIR_7501   ;

                JSR WAIT_FOR_READY  ;wait until slave acknowledges that it is ready
SEND_DATA_LP
SEND_CLOCK_0    JSR CPIO_CLOCK_LOW  ;

                BIT CPIO_DATA       ;bit moves bit-7 of CPIO_DATA into the N-flag of the status register
                BPL SEND_ZERO       ;BPL tests the N-flag, when it is 0 the branch to SEND_ZERO is executed (using the BIT instruction instead of conventional masking, we save 2 cycles, and 2 bytes)
SEND_ONE        LDA DATA_BIT_7501   ;
                ORA #%00010000      ;cassette read = high (we want to send a '1')
                JMP SEND_BIT        ;
SEND_ZERO       LDA DATA_BIT_7501   ;
                AND #%11101111      ;cassette read = low (we want to send a '0')
SEND_BIT        STA DATA_BIT_7501   ;

SEND_CLOCK_1    JSR CPIO_CLOCK_HIGH ;
                ASL CPIO_DATA       ;rotate data in order to send each individual bit, we do it here so that we save time, we have to wait for the clock pulse high-time anyway
                DEY                 ;decrement the Y value
                BNE SEND_DATA_LP    ;exit loop after the eight bit

                JSR CPIO_CLOCK_LOW  ;
                JSR CPIO_CLOCK_HIGH ;

                LDA DATA_DIR_7501   ;
                AND #%11101111      ;read line is set to input (0=input, 1=output)
                STA DATA_DIR_7501   ;
                RTS                 ;end of subroutine

;*******************************************************************************
;this routine will lower the attention to indicate that the current is the last byte
CPIO_REC_LAST   LDY #$08            ;every byte consists of 8 bits, this will be use in the CPIO_send and CPIO_recieve routine which are calling this routine
                JSR WAIT_FOR_READY  ;wait until slave anknowledges that it is ready

                LDA DATA_BIT_7501   ;
                ORA #%00001000      ;cassette motor OFF (motor does not move) (attention, this line is inverted: 0=ON, 1=OFF)
                STA DATA_BIT_7501   ;with the attention signal being low (motor-off) the slave has been notified that communication has come to an end and that the current byte is the last byte within this session

REC_DATA_LP
REC_CLOCK_0     JSR CPIO_CLOCK_LOW  ;

                CLC                 ;clear the carry, which is usefull for the ADC later, we clear it here in order to make the clock=0 time 2 cycles longer (keeps our clock duty cycle closer to 50% (which is allways nice))
REC_CLOCK_1     JSR CPIO_CLOCK_HIGH ;

                LDA DATA_BIT_7501   ;
                AND #%00010000      ;mask out the READ line (the READ line is our data signal)
                ADC #%11111111      ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA       ;shift all the bits one position to the right and add the LSB which is located in the carry

                DEY                 ;decrement the Y value
                BNE REC_DATA_LP     ;exit loop after the eight bit

                JSR CPIO_CLOCK_LOW  ;
                JSR CPIO_CLOCK_HIGH ;

                LDA CPIO_DATA       ;move data to accu
                RTS                 ;end of subroutine


;*******************************************************************************
;this routine will wait until the CPIO slave signals that is is ready
;the C16 uses the cass sense signal as the ready indicator
;...............................................................................
WAIT_FOR_READY  LDA CASS_SENSE      ;FD10h-FD1Fh - Cassette Sense and other IO
                AND #%00000100      ;Bit 2 = Cassette Sense In (C16 and C116 Only)
                BNE WAIT_FOR_READY  ;loop until the slave lowers the read signal
                RTS                 ;    

;*******************************************************************************
CPIO_CLOCK_HIGH LDA DATA_BIT_7501   ;lower the clock line so that the slave has the opportunity to read the data
                AND #%11111101      ;cassette write = high (this signal is inverted by a 7406)
                STA DATA_BIT_7501   ;
                RTS

;*******************************************************************************
CPIO_CLOCK_LOW  LDA DATA_BIT_7501   ;raise clock by changing state of write line to '1' to indicate that the byte has come to an end
                ORA #%00000010      ;cassette write = low (this signal is inverted by a 7406)
                STA DATA_BIT_7501   ;
                RTS

;;*******************************************************************************
;;this is an unrolled version of the CPIO_RECIEVE routine optimized for speed
;;-------------------------------------------------------------------------------
;;this routine will recieve a byte to the slave
;;JSR CPIO_RECIEVE
;;data is in Accu
;;
;;Attention: affects X and Y register
;;...............................................................................
CPIO_RECIEVE    JSR WAIT_FOR_READY      ;wait until slave anknowledges that it is ready (unrolling this makes not required because we neec to honor timing, unrolling makes it too fast)
                ;also the unrolling of the CPIO_CLOCK_HIGH and LOW routines reduced reliabillity and was therefore not used!!

                LDA DATA_BIT_7501       ;
                ORA #%00000010          ;cassette write = low (this signal is inverted by a 7406)
                STA DATA_BIT_7501       ;
                TAX                     ;save for later use 
                AND #%11111101          ;cassette write = high (this signal is inverted by a 7406)
                TAY                     ;save for later use
                LDA #$00                ;must be zero, because every bit goes (because of the ROL instruction) through the carry and the carry must remain cleared
                STA CPIO_DATA           ;
                CLC                     ;clear the carry, which is usefull for the ADC further on, because the  ROL will clear it otherwise.
        
                ;bit 7
                JSR CPIO_CLOCK_HIGH     ;
                LDA DATA_BIT_7501       ;sample the data
                JSR CPIO_CLOCK_LOW      ;
                AND #%00010000          ;mask out the READ line (the READ line is our data signal)
                ADC #%11111111          ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA           ;shift all the bits one position to the right and add the LSB which is located in the carry

                ;bit 6
                JSR CPIO_CLOCK_HIGH     ;
                LDA DATA_BIT_7501       ;sample the data
                JSR CPIO_CLOCK_LOW      ;
                AND #%00010000          ;mask out the READ line (the READ line is our data signal)
                ADC #%11111111          ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA           ;shift all the bits one position to the right and add the LSB which is located in the carry

                ;bit 5
                JSR CPIO_CLOCK_HIGH     ;
                LDA DATA_BIT_7501       ;sample the data
                JSR CPIO_CLOCK_LOW      ;
                AND #%00010000          ;mask out the READ line (the READ line is our data signal)
                ADC #%11111111          ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA           ;shift all the bits one position to the right and add the LSB which is located in the carry

                ;bit 4
                JSR CPIO_CLOCK_HIGH     ;
                LDA DATA_BIT_7501       ;sample the data
                JSR CPIO_CLOCK_LOW      ;
                AND #%00010000          ;mask out the READ line (the READ line is our data signal)
                ADC #%11111111          ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA           ;shift all the bits one position to the right and add the LSB which is located in the carry

                ;bit 3
                JSR CPIO_CLOCK_HIGH     ;
                LDA DATA_BIT_7501       ;sample the data
                JSR CPIO_CLOCK_LOW      ;
                AND #%00010000          ;mask out the READ line (the READ line is our data signal)
                ADC #%11111111          ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA           ;shift all the bits one position to the right and add the LSB which is located in the carry

                ;bit 2
                JSR CPIO_CLOCK_HIGH     ;
                LDA DATA_BIT_7501       ;sample the data
                JSR CPIO_CLOCK_LOW      ;
                AND #%00010000          ;mask out the READ line (the READ line is our data signal)
                ADC #%11111111          ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA           ;shift all the bits one position to the right and add the LSB which is located in the carry

                ;bit 1
                JSR CPIO_CLOCK_HIGH     ;
                LDA DATA_BIT_7501       ;sample the data
                JSR CPIO_CLOCK_LOW      ;
                AND #%00010000          ;mask out the READ line (the READ line is our data signal)
                ADC #%11111111          ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA           ;shift all the bits one position to the right and add the LSB which is located in the carry

                ;bit 0
                JSR CPIO_CLOCK_HIGH     ;
                LDA DATA_BIT_7501       ;sample the data
                JSR CPIO_CLOCK_LOW      ;
                AND #%00010000          ;mask out the READ line (the READ line is our data signal)
                ADC #%11111111          ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA           ;shift all the bits one position to the right and add the LSB which is located in the carry

                JSR CPIO_CLOCK_HIGH     ;

                LDA CPIO_DATA           ;move data to accu
                RTS                     ;end of subroutine

;-------------------------------------------------------------------------------
endif   ;this endif belongs to "ifdef COMMODORE16PLUS4"
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

##{0}F:\Projects\Cassiopei\Versie_2-Wifi\Software\CBM_software\Cassiopei_v2.0-Disk_Wizard\source\\05_Screens.asm

;This file contains all the different screens required for all the different
;computer models



;///////////////////////////////////////////////////////////////////////////////
;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
;///////////////////////////////////////////////////////////////////////////////

;===============================================================================
ifdef COMMODOREPET20XX OR COMMODOREPET30XX OR COMMODOREPET40XX
;-------------------------------------------------------------------------------

        BYTE 0 ;end of table marker
;-------------------------------------------------------------------------------
endif
;===============================================================================


;===============================================================================
ifdef COMMODOREPET80XX
;-------------------------------------------------------------------------------
        BYTE 0 ;end of table marker
;-------------------------------------------------------------------------------
endif
;===============================================================================



;===============================================================================
ifdef COMMODOREVIC20
;-------------------------------------------------------------------------------

        BYTE 0 ;end of table marker
;-------------------------------------------------------------------------------
endif
;===============================================================================


;===============================================================================
ifdef COMMODORE64 OR COMMODORE128
;-------------------------------------------------------------------------------

SCREEN_MAKE_DISK      ; Screen 1 - MAKE_REAL_DISC_D64 Screen data
        BYTE    $20,$20,$20,$04,$09,$13,$0B,$20,$09,$0D,$01,$07,$05,$20,$43,$3E,$20,$12,$05,$01,$0C,$20,$04,$09,$13,$0B,$20,$20,$20,$20,$20,$20,$55,$43,$43,$43,$43,$43,$43,$49
        BYTE    $20,$20,$20,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$20,$20,$20,$20,$20,$20,$42,$1F,$3D,$05,$18,$09,$14,$42
        BYTE    $09,$0E,$13,$05,$12,$14,$20,$05,$0D,$10,$14,$19,$20,$04,$09,$13,$0B,$20,$26,$20,$13,$05,$0C,$05,$03,$14,$20,$06,$09,$0C,$05,$20,$4A,$43,$43,$43,$43,$43,$43,$4B
        BYTE    $70,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$6E,$20,$55,$43,$43,$43,$43,$43,$43,$49
        BYTE    $5D,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$5D,$20,$42,$04,$3D,$04,$09,$12,$2E,$42
        BYTE    $5D,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$5D,$20,$4A,$43,$43,$43,$43,$43,$43,$4B
        BYTE    $5D,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$5D,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $5D,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$5D,$20,$20,$20,$20,$4E,$4D,$20,$20,$20
        BYTE    $5D,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$5D,$20,$20,$20,$4E,$20,$20,$4D,$20,$20
        BYTE    $5D,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$5D,$20,$20,$4E,$20,$06,$33,$20,$4D,$20
        BYTE    $5D,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$5D,$20,$20,$50,$20,$20,$20,$20,$4F,$20
        BYTE    $5D,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$5D,$20,$20,$20,$45,$45,$45,$45,$20,$20
        BYTE    $5D,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$5D,$20,$20,$55,$43,$43,$43,$43,$49,$20
        BYTE    $5D,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$5D,$20,$20,$42,$20,$06,$35,$20,$42,$20
        BYTE    $5D,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$5D,$20,$20,$4A,$43,$43,$43,$43,$4B,$20
        BYTE    $5D,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$5D,$20,$20,$20,$6F,$6F,$6F,$6F,$20,$20
        BYTE    $5D,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$5D,$20,$20,$7A,$20,$20,$20,$20,$4C,$20
        BYTE    $5D,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$5D,$20,$20,$4D,$20,$06,$37,$20,$4E,$20
        BYTE    $5D,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$5D,$20,$20,$20,$4D,$20,$20,$4E,$20,$20
        BYTE    $5D,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$5D,$20,$20,$20,$20,$4D,$4E,$20,$20,$20
        BYTE    $6D,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$7D,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20       
        BYTE 0 ;end of table marker


SCREEN_DATA    ; Screen 2 - DATA_SCREEN Screen data
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$14,$12,$01,$0E,$13,$06,$05,$12,$12,$09,$0E,$07,$20,$04,$01,$14,$01,$20,$10,$0C,$05,$01,$13,$05,$20,$17,$01,$09,$14,$2E,$2E,$2E,$20,$20,$20
        BYTE    $20,$20,$20,$20,$55,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$49,$20,$20
        BYTE    $20,$20,$20,$20,$42,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$42,$20,$20
        BYTE    $20,$20,$20,$20,$4A,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$4B,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$28,$08,$0F,$0C,$04,$20,$13,$10,$01,$03,$05,$20,$14,$0F,$20,$01,$02,$0F,$12,$14,$29,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $14,$12,$01,$03,$0B,$20,$3A,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $13,$05,$03,$14,$0F,$12,$3A,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $40,$40,$40,$40,$40,$40,$40,$40,$40,$40,$40,$40,$40,$40,$40,$40,$40,$40,$40,$40,$40,$40,$40,$40,$40,$40,$40,$40,$40,$40,$40,$40,$40,$40,$40,$40,$40,$40,$40,$40
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20      
        BYTE 0 ;end of table marker

SCREEN_MAIN_D64    ; Screen 3 - Start screen_D64 Screen data
        BYTE    $55,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$49
        BYTE    $42,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$66,$66,$66,$20,$20,$20,$20,$20,$66,$20,$20,$20,$20,$20,$20,$66,$20,$42
        BYTE    $42,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$66,$20,$20,$66,$20,$20,$20,$66,$20,$20,$20,$20,$20,$20,$66,$66,$20,$42
        BYTE    $42,$12,$05,$11,$15,$09,$12,$05,$04,$3A,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$66,$20,$20,$20,$66,$20,$66,$20,$20,$20,$20,$20,$20,$66,$20,$66,$20,$42
        BYTE    $42,$45,$45,$45,$45,$45,$45,$45,$45,$45,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$66,$20,$20,$20,$66,$20,$66,$66,$66,$66,$20,$20,$66,$20,$20,$66,$20,$42
        BYTE    $42,$2D,$03,$01,$13,$13,$09,$0F,$10,$05,$09,$20,$16,$32,$2E,$30,$20,$20,$20,$20,$20,$20,$66,$20,$20,$20,$66,$20,$66,$20,$20,$20,$66,$20,$66,$66,$66,$66,$66,$42
        BYTE    $42,$2D,$31,$35,$34,$31,$20,$28,$04,$05,$16,$09,$03,$05,$20,$38,$29,$20,$20,$20,$20,$20,$66,$20,$20,$66,$20,$20,$66,$20,$20,$20,$66,$20,$20,$20,$20,$66,$20,$42
        BYTE    $42,$2D,$33,$35,$14,$20,$04,$09,$13,$0B,$2F,$09,$0D,$01,$07,$05,$20,$20,$20,$20,$66,$20,$66,$66,$66,$20,$20,$20,$20,$66,$66,$66,$20,$20,$20,$20,$20,$66,$20,$42
        BYTE    $4A,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$4B
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $55,$43,$43,$43,$43,$72,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$49
        BYTE    $42,$A0,$86,$B1,$A0,$42,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$70,$43,$43,$43,$6E,$20,$20,$20,$20,$20,$20,$20,$20,$20,$F0,$C3,$C3,$EE,$A0,$42
        BYTE    $6B,$43,$43,$43,$43,$4B,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$42,$70,$43,$43,$43,$6E,$20,$6F,$6F,$6F,$7A,$4D,$20,$20,$ED,$C3,$C3,$FD,$FC,$42
        BYTE    $42,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$42,$42,$20,$20,$20,$42,$20,$4D,$20,$20,$20,$20,$4D,$20,$A0,$A0,$D1,$A0,$A0,$42
        BYTE    $42,$0D,$01,$0B,$05,$20,$01,$20,$12,$05,$01,$0C,$20,$04,$09,$13,$03,$20,$20,$20,$42,$42,$04,$36,$34,$42,$20,$4E,$20,$20,$20,$20,$4E,$20,$A0,$A0,$C2,$A0,$A0,$42
        BYTE    $42,$06,$12,$0F,$0D,$20,$01,$20,$2E,$04,$36,$34,$20,$06,$09,$0C,$05,$20,$20,$20,$6D,$42,$20,$20,$20,$42,$20,$77,$77,$77,$50,$4E,$20,$20,$A0,$A0,$A0,$A0,$A0,$42
        BYTE    $4A,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$4B
        BYTE    $55,$43,$43,$43,$43,$72,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$49
        BYTE    $42,$A0,$86,$B3,$A0,$42,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$F0,$C3,$C3,$EE,$A0,$20,$20,$20,$20,$20,$20,$20,$20,$70,$43,$43,$43,$6E,$20,$42
        BYTE    $6B,$43,$43,$43,$43,$4B,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$ED,$C3,$C3,$FD,$FC,$20,$6F,$6F,$6F,$7A,$4D,$20,$20,$42,$70,$43,$43,$43,$6E,$42
        BYTE    $42,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$A0,$A0,$D1,$A0,$A0,$20,$4D,$20,$20,$20,$20,$4D,$20,$42,$42,$20,$20,$20,$42,$42
        BYTE    $42,$0D,$01,$0B,$05,$20,$01,$20,$2E,$04,$36,$34,$20,$06,$09,$0C,$05,$20,$20,$20,$A0,$A0,$C2,$A0,$A0,$20,$4E,$20,$20,$20,$20,$4E,$20,$42,$42,$04,$36,$34,$42,$42
        BYTE    $42,$06,$12,$0F,$0D,$20,$01,$20,$12,$05,$01,$0C,$20,$04,$09,$13,$03,$20,$20,$20,$A0,$A0,$A0,$A0,$A0,$20,$77,$77,$77,$50,$4E,$20,$20,$6D,$42,$20,$20,$20,$42,$42
        BYTE    $4A,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$4B
        BYTE 0 ;end of table marker

SCREEN_MAKE_IMAGE       ; Screen 4 - make image file Screen data
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$12,$05,$01,$0C,$20,$04,$09,$13,$0B,$20,$43,$3E,$20,$04,$09,$13,$0B,$20,$09,$0D,$01,$07,$05,$20,$55,$43,$43,$43,$43,$43,$43,$49
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$20,$42,$1F,$3D,$05,$18,$09,$14,$42
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$4A,$43,$43,$43,$43,$43,$43,$4B
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$09,$0E,$13,$05,$12,$14,$20,$04,$09,$13,$0B,$20,$09,$0E,$20,$04,$12,$09,$16,$05,$20,$23,$38,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$12,$05,$11,$15,$05,$13,$14,$20,$84,$09,$12,$20,$14,$0F,$20,$16,$09,$05,$17,$20,$04,$09,$13,$0B,$20,$03,$0F,$0E,$14,$05,$0E,$14,$13,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$13,$10,$05,$03,$09,$06,$19,$20,$86,$09,$0C,$05,$0E,$01,$0D,$05,$20,$0F,$06,$20,$14,$08,$05,$20,$09,$0D,$01,$07,$05,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$06,$09,$0C,$05,$20,$19,$0F,$15,$20,$17,$01,$0E,$14,$20,$14,$0F,$20,$03,$12,$05,$01,$14,$05,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$83,$12,$05,$01,$14,$05,$20,$09,$0D,$01,$07,$05,$2C,$20,$14,$0F,$20,$03,$0F,$10,$19,$20,$04,$01,$14,$01,$20,$06,$12,$0F,$0D,$20,$04,$09,$13,$0B,$20,$20
        BYTE    $20,$20,$20,$20,$14,$0F,$20,$01,$0E,$20,$09,$0D,$01,$07,$05,$20,$06,$09,$0C,$05,$20,$0F,$0E,$20,$14,$08,$05,$20,$13,$04,$2D,$03,$01,$12,$04,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $55,$43,$43,$43,$43,$43,$49,$55,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$49,$55,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$49
        BYTE    $42,$04,$3D,$04,$09,$12,$42,$42,$06,$3D,$0E,$01,$0D,$05,$20,$0F,$06,$20,$09,$0D,$01,$07,$05,$42,$42,$03,$3D,$03,$12,$05,$01,$14,$05,$20,$09,$0D,$01,$07,$05,$42
        BYTE    $4A,$43,$43,$43,$43,$43,$4B,$42,$06,$09,$0C,$05,$20,$14,$0F,$20,$02,$05,$20,$0D,$01,$04,$05,$42,$4A,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$4B
        BYTE    $70,$43,$43,$43,$43,$43,$43,$71,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$71,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$6E
        BYTE    $42,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$5D
        BYTE    $6D,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$7D
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE 0 ;end of table marker


SCREEN_MAIN_D81 ; Screen 5 - Start screen D81 Screen data

        BYTE    $55,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$49
        BYTE    $42,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$66,$66,$66,$20,$20,$20,$20,$66,$66,$66,$20,$20,$20,$20,$66,$20,$20,$42
        BYTE    $42,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$66,$20,$20,$66,$20,$20,$66,$20,$20,$20,$66,$20,$20,$66,$66,$20,$20,$42
        BYTE    $42,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$66,$20,$20,$20,$66,$20,$66,$20,$20,$20,$66,$20,$20,$20,$66,$20,$20,$42
        BYTE    $42,$12,$05,$11,$15,$09,$12,$05,$04,$3A,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$66,$20,$20,$20,$66,$20,$20,$66,$66,$66,$20,$20,$20,$20,$66,$20,$20,$42
        BYTE    $42,$45,$45,$45,$45,$45,$45,$45,$45,$45,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$66,$20,$20,$20,$66,$20,$66,$20,$20,$20,$66,$20,$20,$20,$66,$20,$20,$42
        BYTE    $42,$2D,$03,$01,$13,$13,$09,$0F,$10,$05,$09,$20,$16,$32,$2E,$30,$20,$20,$20,$20,$20,$20,$66,$20,$20,$66,$20,$20,$66,$20,$20,$20,$66,$20,$20,$20,$66,$20,$20,$42
        BYTE    $42,$2D,$31,$35,$38,$31,$20,$28,$04,$05,$16,$09,$03,$05,$20,$38,$29,$20,$20,$20,$66,$20,$66,$66,$66,$20,$20,$20,$20,$66,$66,$66,$20,$20,$20,$66,$66,$66,$20,$42
        BYTE    $4A,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$4B
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $55,$43,$43,$43,$43,$72,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$49
        BYTE    $42,$A0,$86,$B1,$A0,$42,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$70,$43,$43,$43,$6E,$20,$20,$20,$20,$20,$20,$20,$20,$20,$C2,$BD,$BD,$BD,$EB,$42
        BYTE    $6B,$43,$43,$43,$43,$4B,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$42,$70,$43,$43,$43,$6E,$20,$6F,$6F,$6F,$7A,$4D,$20,$20,$C2,$BD,$BD,$BD,$C2,$42
        BYTE    $42,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$42,$42,$20,$20,$20,$42,$20,$4D,$20,$20,$20,$20,$4D,$20,$CA,$C3,$C3,$C3,$CB,$42
        BYTE    $42,$0D,$01,$0B,$05,$20,$01,$20,$12,$05,$01,$0C,$20,$04,$09,$13,$03,$20,$20,$20,$42,$42,$04,$38,$31,$42,$20,$4E,$20,$20,$20,$20,$4E,$20,$A0,$6C,$20,$E1,$A0,$42
        BYTE    $42,$06,$12,$0F,$0D,$20,$01,$20,$2E,$04,$38,$31,$20,$06,$09,$0C,$05,$20,$20,$20,$6D,$42,$20,$20,$20,$42,$20,$77,$77,$77,$50,$4E,$20,$20,$5F,$7C,$20,$E1,$A0,$42
        BYTE    $4A,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$4B
        BYTE    $55,$43,$43,$43,$43,$72,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$49
        BYTE    $42,$A0,$86,$B3,$A0,$42,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$C2,$BD,$BD,$BD,$EB,$20,$20,$20,$20,$20,$20,$20,$20,$70,$43,$43,$43,$6E,$20,$42
        BYTE    $6B,$43,$43,$43,$43,$4B,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$C2,$BD,$BD,$BD,$C2,$20,$6F,$6F,$6F,$7A,$4D,$20,$20,$42,$70,$43,$43,$43,$6E,$42
        BYTE    $42,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$CA,$C3,$C3,$C3,$CB,$20,$4D,$20,$20,$20,$20,$4D,$20,$42,$42,$20,$20,$20,$42,$42
        BYTE    $42,$0D,$01,$0B,$05,$20,$01,$20,$2E,$04,$38,$31,$20,$06,$09,$0C,$05,$20,$20,$20,$A0,$6C,$20,$E1,$A0,$20,$4E,$20,$20,$20,$20,$4E,$20,$42,$42,$04,$38,$31,$42,$42
        BYTE    $42,$06,$12,$0F,$0D,$20,$01,$20,$12,$05,$01,$0C,$20,$04,$09,$13,$03,$20,$20,$20,$5F,$7C,$20,$E1,$A0,$20,$77,$77,$77,$50,$4E,$20,$20,$6D,$42,$20,$20,$20,$42,$42
        BYTE    $4A,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$4B
        BYTE 0 ;end of table marker

;-------------------------------------------------------------------------------
endif
;===============================================================================

;===============================================================================
ifdef COMMODORE16PLUS4
;-------------------------------------------------------------------------------

        BYTE 0 ;end of table marker
;-------------------------------------------------------------------------------
endif
;===============================================================================



VERSION_INFO    TEXT 'version:'
                BYTE VERSION_STRING_00+$30
                BYTE VERSION_STRING_01+$30
                BYTE VERSION_STRING_02+$30
                BYTE VERSION_STRING_03+$30
                BYTE VERSION_STRING_04+$30
                BYTE VERSION_STRING_05+$30
                BYTE 0   


;ATTENTION:
;----------
;  In order for the code below to work (only important for the VIC20),
;  make sure that this is the last file to be compiled!!

END_OF_PROGRAM                  ;this label indicates the absolute end of the program
PRGSIZE = END_OF_PROGRAM-INIT   ;required for VIC20 program relocation routine

