##{0}D:\Projects\Cassiopei\Software\CBM_software\C64\example_VQImages\0800_Constants_and_BasicStart.asm

; 10 SYS (2080)

*=$801

        BYTE    $0E, $08, $0A, $00, $9E, $20, $28,  $32, $30, $38, $30, $29, $00, $00, $00


;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
;                           BUILD RELATED SETTINGS
;-------------------------------------------------------------------------------

FALSE = 0
TRUE  = 1

WEDGEAVAILABLE = TRUE

;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

;-------------------------------------------------------------------------------
;                            zeropage RAM regsiters
;-------------------------------------------------------------------------------
;we use only the 0-page locations that are marked as "unused" or "free 0-page space for user programs"


;common variables
;----------------

CPIO_DATA       = $02           ;this zeropage memory location is used to parse the CPIO data
CHRCNT          = $97


CURSOR_X        = $F7   ;buffer used for text printing routine
CURSOR_Y        = $F8   ;buffer used for text printing routine

CHAR_ADDR       = $F9
CHAR_ADDR+1     = $FA

STR_ADDR        = $FB  ;pointer to string
STR_ADDR+1      = $FC  ;           

ADDR            = $61  ;pointer
ADDR+1          = $62  ;      
CNTR            = $63  ;pointer
CNTR+1          = $64  ;      


COL_PRINT       = $6B  ;holds the color of the charaters printed with the PRINT_CHAR routine
COLOR_ADDR      = $6C  ;pointer to color memory
;COLOR_ADDR+1   = $6D


;we use only the 0-page locations that are marked as "unused" or "free 0-page space for user programs"
;variables used by wedge only
;----------------------------
POINTER_BUF     = $FB   ;and $FC
TABLE_ADR       = $FD   ;and $FE



;...............................................................................
;                         KERNAL ROUTINES AND ADDRESSES
;...............................................................................

;KEYCNT          = 158           ;the counter that keeps track of the number of key in the keyboard buffer       PET/CBM (Upgrade and 4.0 BASIC)
;KEYBUF          = 623           ;the first position of the keyboard buffer                                      PET/CBM (Upgrade and 4.0 BASIC)
;KEYMATRIX       = $97           ;key matrix value                                                               PET/CBM (Upgrade and 4.0 BASIC)




BORDER          = $D020         ;bordercolour
BACKGROUND      = $D021         ;background-0
CHARSCREEN      = $0400         ;location of the character screen memory
CHARSCREEN_BUF  = $C400         ;location of the character screen memory
COLORSCREEN     = $D800         ;location of the color screen memory (this value cannot change)

TXTPTR          = $7A   ;this value is noted as 2 digits (no zeros are noted here, to use it as a zero-page address)
CHRGET          = $0073 ;this value is noted as 4 digits, because we want to jump to it and therefore it needs to be a 4 digit address ;get character from basic line (value corresponds to table in Appendix C of prog ref guid (page 379))
CHRGOT          = $0079 ;this value is noted as 4 digits, because we want to jump to it and therefore it needs to be a 4 digit address ;get the last character again
IGONE           = $0308         ;non function BASIC commands 
IEVAL           = $030A         ;functions in BASIC commands
NEWBASIC_DONE   = $A7E4         ;fetch new character from basic line and interpret (jump to this vector after !HELP which is a command that has no prarameters to be processed)
STNDRDBASICCMD  = $A7E7         ;interpret just fetched character from basic line as a command
STNDRDBASICFUNC = $AE8D         ;interpret just fetched character from basic line as a function
SYNTAXERROR     = $AF08         ;syntax error

SCAN_KEYBOARD   = $FF9F         ;scans the keyboard and puts the matrix value in $C5
CHROUT          = $FFD2         ;

CHKCOMANDGETVAL = $E200         ;check if last fetched char was a comma, if so get value (stores 8-bit value in X), if not syntax error
CHKCOM          = $AEFD         ;If it is not, a SYNTAX ERROR results.  If it is, the character is skipped and the next character is read.
FRMNUM          = $AD8A         ;
GETADR          = $B7F7         ;


DATA_DIR_6510   = $00           ;the MOS6510 data direction register of the peripheral IO pins (P7-0)
DATA_BIT_6510   = $01           ;the MOS6510 value f the bits of the peripheral IO pins (P7-0)

;-------------------------------------------------------------------------------
;                                   constants
;-------------------------------------------------------------------------------


DIRWINDOWHEIGTH = 10            ;the max. number of lines that we can display in our directory window
DIRWINDOWWIDTH  = 32            ;the max displayed length of the filename


; CPIO related constants
;------------------------

CPIO_LOAD               = #%00000000    ;read fast from the cassiopei's filesystem
CPIO_DATALOAD           = #%00000001    ;read fast from the cassiopei's filesystem from a data file
;CPIO_SAVEFAST           = #%00000000    ;save fast from the cassiopei's filesystem

CPIO_R_DIRECTORY_FLASH  = #%00000100    ;read diretory info from flash        
CPIO_SIMULATE_BUTTON    = #%00000111    ;simulate press on play
CPIO_R_EEPROM           = #%00001111    ;read from slave, EEPROM
CPIO_W_EEPROM           = #%10001111    ;write to slave, EEPROM

CPIO_ADC                = #%00001001    ;get ADC value
CPIO_EEPROM_RD          = #%00001111    ;read from slave, EEPROM
CPIO_PARAMETER          = #%00001101    ;prepare sample playback (with possible transfer of 4 bit AUDIO sample(s)
CPIO_PLAYSAMPLE         = #%00001110    ;start sample playback
CPIO_SPEECH             = #%10001110    ;start speech generator


CPIO_EEPROM_WR          = #%10001111    ;write to slave, EEPROM
CPIO_SINEWAVE           = #%10001000    ;write to slave, audio: type pure sine
CPIO_DTMF               = #%10001001    ;write to slave, audio: type DTMF


CPIO_KAKU13             = #%10001011    ;write to slave, klik aan klik uit code 13 bits
CPIO_KAKU32             = #%10001100    ;write to slave, klik aan klik uit code 32 bits

CPIO_SERVOINIT          = #%10010001    ;init PCA9685 PWEM controller for servo mode
CPIO_SERVOPOS           = #%10010010    ;send servo postioning command

CPIO_I2C                = #%10010000    ;I2C data
CPIO_I2C_STOP           = #$00          ;write I2C data to slave
CPIO_I2C_ADR_W          = #$01          ;write I2C address to slave and indicate that we are sending data TO the I2C slave
CPIO_I2C_ADR_R          = #$02          ;write I2C address to slave and indicate that we are going to read data FROM the I2C slave
CPIO_I2C_PUT            = #$10          ;write I2C data to slave
CPIO_I2C_GET            = #$20          ;read I2C data from slave and acknowledge
CPIO_I2C_GETLAST        = #$21          ;read I2C data from slave, but do not acknowledge to indicate this is the last byte we want to read

;-------------------------------------------------------------------------------
;C64 keyboard scanning values

KEY_NOTHING     = $40           ;when no key is pressed
KEY_F1          = $04           ;$04 = F1 
KEY_F3          = $05           ;$05 = F3
KEY_F5          = $06           ;$06 = F5 
KEY_F7          = $03           ;$03 = F7
KEY_RETURN      = $01           ;$01 = RETURN
KEY_1           = $38           ;$38 = 1 
KEY_2           = $3B           ;$3B = 2


##{0}D:\Projects\Cassiopei\Software\CBM_software\C64\example_VQImages\0820_Main.asm

*=$0820 ;start address      ;by keeping the start adress close to the basic line, we keep the compiled program small. This because the "gap" between the basic line and the assembly code is filled with padding bytes.
               


INIT            JMP MAIN                ;

;-------------------------------------------------------------------------------
;a small list of variables that do not require storage in the zero-page

ODD_EVEN        BYTE $00        ;to keep track of the odd or even frame (so we know which buffer to use), this variable is basically the Least Significant Bit of the frame counter, but we cannot use that value if we are looping an amination, because then we could have 2 even frames after each other (if the last frame is even, the first frame is 0 and allways even). This variable does not even to be initialised because it does not matter if we start at or or even. As long as we toggle between the charset buffers everything will be fine
NMBR_OF_FRAMES  BYTE $00        ;a variable to store the number of frames (low byte)
                BYTE $00        ;a variable to store the number of frames (high byte)

OFFSET_LSB      BYTE $00        ;variable used to hold the offset inside the file holding the data
OFFSET_XSB      BYTE $00        ;using this 3 byte offset value we can position ourselves through
OFFSET_MSB      BYTE $00        ;a file of 16 Mbytes (max) Since the Cassiopei can only hold 8Mbyte, this is perfect

MODE_BYTE       BYTE $00        ;the mode the encoded image uses
X_SIZE          BYTE $00        ;the width of the screen in chars
Y_SIZE          BYTE $00        ;the height of the screen in charset_init
CODEBOOK_SIZE   BYTE $00        ;the number of tiles as used by the codebook
CODEBOOK_CNT    BYTE $00        ;counter used during loading of codebook
        

;===============================================================================
;                              MAIN PROGRAM
;===============================================================================

MAIN            JSR FLASH_SCREEN        ;create dramatic change of screens
                LDA #$80                ;DISABLE case changes caused by pressing CBM+shift
                STA $0291               ;

        

                JSR CPIO_INIT           ;initialize IO for use of CPIO protocol on the C64's cassetteport
                JSR COUNT_DIR_SIZE      ;check the number of entries for the current filetype (in our case that is DAT)             

MAIN_LP         LDA #$01                ;1=white
                STA COL_PRINT           ;set printing color
                LDX #0                  ;build the screen
                LDY #0                  ;
                JSR SET_CURSOR          ;
                LDA #<MAIN_SCREEN       ;set pointer to the text that defines the main-screen
                LDY #>MAIN_SCREEN       ;
                JSR PRINT_STRING        ;the print routine is called, so the pointed text is now printed to screen         

                JSR INDEX_SHOW          ;update the screen with the related file index information

SCAN_USER_INPUT
SCAN_KEYRELEASE LDA $C5                 ;matrix value of last Key pressed
                CMP #KEY_NOTHING        ;check for key
                BNE SCAN_KEYRELEASE     ;continue loop when no key is detected
SCAN_KEYPRESS   JSR SCAN_KEYBOARD       ;because the interrups are disabled during communication with the Cassiopei, the keyboard might not be updated and therefore the buffer value remains the same, which in real life is not correct, so we execute a manual keyboard scan
                LDA $C5                 ;matrix value of last Key pressed
               ; CMP #KEY_F1             ;
               ; BEQ EXECUTE_VERIFY      ;
                CMP #KEY_F3             ;
                BEQ EXECUTE_PREV        ;
                CMP #KEY_F5             ;
                BEQ EXECUTE_NEXT        ;
               ; CMP #KEY_F7             ;
               ; BEQ EXECUTE_DIR         ;
                CMP #KEY_RETURN         ;
                BEQ EXECUTE_PLAY        ;

                JMP SCAN_KEYPRESS       ;when the pressed key has no function then continue the key scanning

        ;..................................................

EXECUTE_PREV    JSR INDEX_PREV          ;select file, and then return to the beginning of the main menu loop
                JMP SCAN_KEYPRESS       ;do not wait for key release, we want key-repeat functionality

EXECUTE_NEXT    JSR INDEX_NEXT          ;select file, and then return to the beginning of the main menu loop
                JMP SCAN_KEYPRESS       ;do not wait for key release, we want key-repeat functionality

EXECUTE_PLAY    JSR FLASH_SCREEN        ;create dramatic change of screens
                JSR LOAD_HEADER         ;open file and load the header containing the details of the file
                BCS PLAY_END            ;carry set, then file not found and we exit the program
                JSR PLAY_VQ_ANIM        ;     
PLAY_END        JMP MAIN_LP             ;


;===============================================================================
;                             - = SUBROUTINES = -
;===============================================================================

INDEX_SHOW      LDA #5                  ;the line number(Y coordinate on the screen) where we want our first line of the directory printed
                STA LINE                ;
                LDA #DIRWINDOWHEIGTH    ;the max number of lines we can fit in to the directory window
                STA LINE_CNT            ;this is the counter that counts down until the screen has been filled with directory entries

                LDA INDEX               ;
                SEC                     ;set carry
                SBC #DIRWINDOWHEIGTH-1  ;calculate if the index we want to show is outside the visible area of our file selection window
                BCS INDEX_SHOW_01       ;carry is cleared when INDEX<LINE_CNT
                LDA #$00                ;entry=0 is the first file we will show in the file selection window
INDEX_SHOW_01   STA ENTRY               ;

INDEX_SHOW_LP   LDA INDEX_MAX           ;check if we may display a directory entry, because we cannot display items that do not exist
                CMP ENTRY               ;
                BCC INDEX_SHOW_LP3      ;exit when no more items on flash

                LDA INDEX               ;check if the current entry is also the selected file
                CMP ENTRY               ;if that is the case then use a different color
                BNE INDEX_SHOW_LP0      ;
                LDA #1                  ;1=white (printing color for currently selected file)
                JMP INDEX_SHOW_LP1      ;
INDEX_SHOW_LP0  LDA #12                 ;12=grey (printing color for files that are not selected)
INDEX_SHOW_LP1  STA COL_PRINT           ;set printing color
                LDX #4                  ;x-position of cursor
                LDY LINE                ;
                JSR SET_CURSOR          ;
                LDA ENTRY               ;variable ENTRY holds the index of the file to be shown
                JSR PRINT_DIR_ENTRY     ;show the directory entry
                INC LINE                ;the next entry needs to be printed on the next line, so increment Y-coordinate counter
                INC ENTRY               ;
                DEC LINE_CNT            ;keep looping until we have filled our directory window
                BNE INDEX_SHOW_LP       ;
INDEX_SHOW_LP3  LDA LINE_CNT            ;file the remaing space (if there is any) with empty lines
                BEQ INDEX_SHOW_LP4      ;
                LDA #1                  ;
                STA COL_PRINT           ;set printing color
                LDX #4                  ;x-position of cursor
                LDY LINE                ;
                JSR SET_CURSOR          ;
                LDA #<TXT_EMPTYLINE     ;set pointer to the text to be printed
                LDY #>TXT_EMPTYLINE     ;
                JSR PRINT_STRING        ;the print routine is called, so the pointed text is now printed to screen         
                INC LINE                ;
                DEC LINE_CNT            ;
                JMP INDEX_SHOW_LP3      ;

INDEX_SHOW_LP4  ;LDX #0                 ;this code is usefull for debugging the "filename" related routine(s)
                ;LDY #0                 ;so that we see the variable holding the filename
                ;JSR SET_CURSOR         ;of the currently selected file
                ;LDA #<FILENAME         ;
                ;LDY #>FILENAME         ;
                ;JSR PRINT_STRING       ;the print routine is called, so the pointed text is now printed to screen   

                RTS                     ;

TXT_EMPTYLINE   BYTE  $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,0     ;this is the text we use for clearing the remaining window space, to clear previous emtries if there were any


                ;...............................................................

INDEX_PREV      LDA INDEX               ;
                BEQ INDEX_PREV_END      ;check if index=0, if so then do not decrement and no need to update screen, so back to keyscan loop
                DEC INDEX               ;              
                JSR INDEX_SHOW          ;update screen
INDEX_PREV_END  RTS                     ;

                ;...............................................................
                
INDEX_NEXT      LDA INDEX               ;
                CMP INDEX_MAX           ;compare if index has reach max allowable value
                BEQ INDEX_NEXT_END      ;check if index<max, if so then do not increment and no need to update screen, so back to keyscan loop
                INC INDEX               ;
                JSR INDEX_SHOW          ;update screen
INDEX_NEXT_END  RTS                     ;

                ;...............................................................

;-------------------------------------------------------------------------------
; example       LDA #$05                ;directory entry at index 5 (the sixth file because we start to count from 0)
;               JSR PRINT_DIR_ENTRY     ;print to screen
;-------------------------------------------------------------------------------

PRINT_DIR_ENTRY PHA                     ;save index to the stack
                LDA CPIO_R_DIRECTORY_FLASH      ;send directory read command
                JSR CPIO_START          ;
                PLA                     ;get index from the stack (the index of the file we want to see the info of)
                PHA                     ;save index to the stack
                JSR CPIO_SEND           ;
                JSR SEND_FILETYPE       ;send the filetype we are searching for
                JSR CPIO_RECIEVE        ;the CPIO device first results with the search result TRUE=FILE FOUND, FALSE=FILE NOT FOUND
                BNE PRINT_DIR_LP_1      ;continue to reading file info

PRINT_NOFILE    PLA                     ;there is no file info, write alternative message to notify user
PRINT_NOFILE_2  LDA #DIRWINDOWWIDTH     ;the number of characters we will display
                STA CHRCNT              ;
                LDX #$00                ;counter used for text table
PRINT_NOFILE_3  LDA TXT_NOFILEFOUND,X   ;   
                JSR PRINT_CHAR          ;character is printed to screen, cursor is incremented by one
                INX                     ;increment table pointer
                DEC CHRCNT              ;
                LDA CHRCNT              ;
                BNE PRINT_NOFILE_3      ;keep looping until we have printed the desired number of characters
                JMP PRINT_DIR_END       ;then exit this routine

PRINT_DIR_LP_1  PLA                     ;get index from the stack (the index of the file we want to see the info of)
PRINT_DIR_LP_2  LDA #DIRWINDOWWIDTH     ;the number of characters we will display
                STA CHRCNT              ;
                LDX #$00                ;counter used for text table
PRINT_DIR_LP_3  JSR CPIO_RECIEVE        ;get byte from CPIO's flash containing the file info
                STA CHAR_READ           ;
                JSR CONVERT_TO_SCREENCODES    ;convert ASCII to screencodes otherwise it looks like #@#$@$#
                JSR PRINT_CHAR          ;character is printed to screen, cursor is incremented by one

                ;................................................................................
                LDA INDEX               ;check if the current entry is also the selected file
                CMP ENTRY               ;if that is the case then save the filename to the filename variable
                BNE PRINT_DIR_LP_4      ;this case we know what file to convert to disc, thsi because the DAT file related routines
                LDA CHAR_READ           ;rather have a filename then an index.
                STA FILENAME,X          ;
                INX                     ;
                ;................................................................................

PRINT_DIR_LP_4  DEC CHRCNT              ;
                LDA CHRCNT              ;
                BNE PRINT_DIR_LP_3      ;keep looping until we have read the desired number of characters

PRINT_DIR_END   JSR CPIO_REC_LAST       ;read the last character, which we discard
                CLI                     ;CPIO communication has disabled interrupts, so we must enable interrupts again. Otherwise the keyboard is not scanned etc.
                RTS                     ;


TXT_NOFILEFOUND TEXT '     -no-file-found-      '       ;this is the text that shows when there are no file found and there is nothing else to display, we must show something otherwise the user might think the system isn't working
CHAR_READ       BYTE $0                                 ;temp storage of the caracter read from the cassiopei

;-------------------------------------------------------------------------------
;count the number of directory entries
;

COUNT_DIR_SIZE  LDA #$00                ;
                STA INDEX_MAX           ;save max index value
                JMP COUNT_DIR_02        ;

COUNT_DIR_01    INC INDEX_MAX           ;every time we encounter a valid entry we pass this point of the code and we increment the  "files found counter"
COUNT_DIR_02    LDA CPIO_R_DIRECTORY_FLASH      ;send directory read command
                JSR CPIO_START          ;
                LDA INDEX_MAX           ;
                JSR CPIO_SEND           ;
                JSR SEND_FILETYPE       ;send the filetype we are searching for
                JSR CPIO_REC_LAST       ;the CPIO device first results with the search result TRUE=FILE FOUND, FALSE=FILE NOT FOUND

                BNE COUNT_DIR_01        ;keep looping as long as we detect files
                DEC INDEX_MAX           ;the max found must be one smaller...

                LDA INDEX_MAX           ;when the index max has reached 0xFF it meant that there were no entries at all on the device
                CMP #$FF                ;the decrement at the end confuses the counter, so we must compensate for the decrement by incrementing
                BNE COUNT_DIR_03        ;now the value for index_max=0 the best possible value for the situation were no files are stored
                INC INDEX_MAX           ;

COUNT_DIR_03    CLI                     ;CPIO communication has disabled interrupts, so we must enable interrupts again. Otherwise the keyboard is not scanned etc.
                RTS

;-------------------------------------------------------------------------------
;this routine is used by COUNT_DIR_SIZE and PRINT_DIR_ENTRY

SEND_FILETYPE   
SEND_FILET_11   LDA #$06                ;search for DAT files
SEND_FILET_12   JSR CPIO_SEND           ;
                RTS

;-------------------------------------------------------------------------------

CONVERT_TO_SCREENCODES
        AND #%01111111                          ;only use the lowest 7 bits
        TAY                                     ;copy value in ACCU to Y (we use it as the index in our conversion table)
        LDA ASCII_TO_SCREENDISPLAYCODE_SET1,Y   ;in order to get the smoothest bar
        RTS                                     ;return with the coneverted value

        ;the table below converts an ASCII value to the SCREEN DISPLAY CODE (Prog ref guide page 376)
        ;make sure that you are displaying in set-1 (you can toggle between set by pressing shift+commodore on your C64)
        ;we need this table in order to display the filenames which are in ASCII (otherwise the PC needs to convert to PETSCII, which makes no sense as ASCII is the one and only real standard)
ASCII_TO_SCREENDISPLAYCODE_SET1
        ;this table is most likely not perfect... under construction!!!         (this table uses the INDEX values of the charset)
    BYTE $80,$81,$82,$83,$84,$85,$86,$87,$88,$89,$8a,$8b,$8c,$8d,$8e,$8f
    BYTE $90,$91,$92,$93,$94,$95,$96,$97,$98,$99,$9a,$9b,$9c,$9d,$9e,$9f
    BYTE $20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$2a,$2b,$2c,$2d,$2e,$2f
    BYTE $30,$31,$32,$33,$34,$35,$36,$37,$38,$39,$3a,$3b,$3c,$3d,$3e,$3f
    BYTE $00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0a,$0b,$0c,$0d,$0e,$0f
    BYTE $10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$1a,$1b,$1c,$1d,$1e,$46
    BYTE $00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0a,$0b,$0c,$0d,$0e,$0f
    BYTE $10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$1a,$1b,$1c,$1d,$1e,$1f
    ;BYTE $c0,$c1,$c2,$c3,$c4,$c5,$c6,$c7,$c8,$c9,$ca,$cb,$cc,$cd,$ce,$cf
    ;BYTE $d0,$d1,$d2,$d3,$d4,$d5,$d6,$d7,$d8,$d9,$da,$db,$dc,$dd,$de,$df
    ;BYTE $60,$61,$62,$63,$64,$65,$66,$67,$68,$69,$6a,$6b,$6c,$6d,$6e,$6f
    ;BYTE $70,$71,$72,$73,$74,$75,$76,$77,$78,$79,$7a,$7b,$7c,$7d,$7e,$7f
    ;BYTE $40,$41,$42,$43,$44,$45,$46,$47,$48,$49,$4a,$4b,$4c,$4d,$4e,$4f
    ;BYTE $50,$51,$52,$53,$54,$55,$56,$57,$58,$59,$5a,$5b,$5c,$5d,$5e,$5f
    ;BYTE $60,$61,$62,$63,$64,$65,$66,$67,$68,$69,$6a,$6b,$6c,$6d,$6e,$6f
    ;BYTE $70,$71,$72,$73,$74,$75,$76,$77,$78,$79,$7a,$7b,$7c,$7d,$7e,$5e 

;-------------------------------------------------------------------------------
;this routine will loop until a keypress is stored in the keyboard buffer
;

;WAIT_FOR_KEY
;SCAN_KEYBOARD   LDA #$00                ;clear keyboard buffer
;                STA KEYCNT              ;check number of chars in keyboard buffer
;SCAN_KEY        LDA KEYCNT              ;check number of chars in keyboard buffer
;                BEQ SCAN_KEY
;                RTS


;-------------------------------------------------------------------------------
;flash screen from white to black usefull for creating a more dramatic appearance

FLASH_SCREEN    LDA #147                ;PRINT CHR$(147) TO CLEAR
                JSR CHROUT              ;SCREEN
                LDY #$00                ;cycle the colors of the screen
FLASH_SCREEN_1  LDA FLASH_TABLE,Y       ;get color from table
                CMP #$FF                ;check for end marker
                BEQ FLASH_DONE          ;stop when end-marker has been detected
                STA BORDER              ;
                STA BACKGROUND          ;
                INY                     ;
                LDX FLASH_TABLE,Y       ;get delay from table
                JSR DELAY_X_FRAMES      ;
                INY                     ;
                JMP FLASH_SCREEN_1      ;
FLASH_DONE      RTS                     ;

FLASH_TABLE     BYTE 00,    25      ;black          , wait for .. frames
                BYTE 01,    25      ;white          , wait for .. frames
                BYTE 15,    15      ;light grey     , wait for .. frames
                BYTE 12,    10      ;grey           , wait for .. frames
                BYTE 11,    10      ;dark grey      , wait for .. frames
                BYTE 0,     1       ;black          , wait for .. frames
                BYTE $FF            ;end marker
;-------------------------------------------------------------------------------
;this routine will wait for ... frames (PAL has 50 frames per second, NTSC 60)
;the bennefit of this routine is it small size and accurate timing and it always
;exits on the same positon of the screen which prevents flicker when using this delay
;for changing the backgroud/foreground colors
;call example:  LDX #$..
;               JSR DELAY_X_FRAMES
; also affects A 

DELAY_X_FRAMES  SEI
DEL_RASTER1     LDA $D012               ;
                CMP #$10                ;
                BNE DEL_RASTER1         ;
DEL_RASTER2     LDA $D012               ;
                CMP #$00                ;
                BNE DEL_RASTER2         ;
                DEX                     ;
                BNE DELAY_X_FRAMES      ;
                CLI                     ;
                RTS                     ;

;-------------------------------------------------------------------------------
; this small routine will clear the (40x25 characters) screen
; call example: JSR CLEAR_SCREEN
;...............................................................................
CLEAR_SCREEN    LDY #$00
CLEAR_SCREEN_1  LDA #$20        ;the space is used for clearing the screen
                STA CHARSCREEN,Y
                STA CHARSCREEN+256,Y
                STA CHARSCREEN+512,Y
                STA CHARSCREEN+744,Y

                LDA #$01    
                STA COLORSCREEN,Y
                STA COLORSCREEN+256,Y
                STA COLORSCREEN+512,Y
                STA COLORSCREEN+744,Y

                DEY
                BNE CLEAR_SCREEN_1
                RTS 



;-------------------------------------------------------------------------------
; this small routine will clear the (40x25 characters) screen
; call example: JSR CLEAR_SCREEN
;...............................................................................
;CLEAR_SCREEN    LDA #$20        ;the space is used for clearing the screen
;                LDY #$00
;CLEAR_SCREEN_LP STA CHARSCREEN,Y
;                STA CHARSCREEN+256,Y
;                STA CHARSCREEN+512,Y
;                STA CHARSCREEN+744,Y
;                DEY
;                BNE CLEAR_SCREEN_LP
;                RTS 



;-------------------------------------------------------------------------------
;print accu value in hex to the top left of the screen
;
DEBUG_PRINT_ACC0

        STA A_BUF
        STX X_BUF
        STY Y_BUF

        LDX #$0         ;chars from the top of the defined screen area
        LDY #$0         ;chars from the left of the defined screen area
        JSR SET_CURSOR

        LDA A_BUF       ;A-register must contain value to be printed
        JSR PRINT_HEX   ;the print routine is called

        LDX X_BUF
        LDY Y_BUF
        LDA A_BUF
        RTS

A_BUF   BYTE $00
X_BUF   BYTE $00
Y_BUF   BYTE $00



DEBUG_PRINT_ACC

        STA A_BUF

        LDA A_BUF       ;A-register must contain value to be printed
        JSR PRINT_HEX   ;the print routine is called

        LDA A_BUF
        RTS

;-------------------------------------------------------------------------------
;call this routine as described below:
;
;               LDA #character          ;character is stored in Accumulator
;               JSR PRINT_CHAR          ;character is printed to screen, cursor is incremented by one
; also affects Y
; note: when the character value is 0 there is nothing printed but we do increment the cursor by one
;-------------------------------------------------------------------------------
PRINT_CHAR      BEQ PRINT_NOTHING       ;when the value = 0, we print nothing but we do increment the cursor by one
                LDY #00                 ;
                STA (CHAR_ADDR),Y       ;character read from string (stored in A) is now written to screen memory (see C64 manual appendix E for screen display codes)
                LDA COL_PRINT           ;
                STA (COLOR_ADDR),Y      ;write colorvalue to the corresponding color memory location

                ;increment character pointer
PRINT_NOTHING   CLC                     ;
                LDA #$01                ;add 1
                ADC CHAR_ADDR           ;                        
                STA CHAR_ADDR           ;
                LDA #$00                ;
                ADC CHAR_ADDR+1         ;add carry... and viola, we have a new cursor position (memory location where next character will be printed)
                STA CHAR_ADDR+1         ;

                ;also increment color memory pointer
                CLC                     ;
                LDA #$01                ;add 1
                ADC COLOR_ADDR          ;                        
                STA COLOR_ADDR          ;
                LDA #$00                ;
                ADC COLOR_ADDR+1        ;add carry... and viola, we have a new cursor position (memory location where next character will be printed)
                STA COLOR_ADDR+1        ;

                RTS                     ;      
              
;-------------------------------------------------------------------------------
;call this routine as described below:
;
;       LDA #<label             ;set pointer to the first string in a table of strings
;       LDY #>label             ;set pointer to the first string in a table of strings
;       LDX #string_number      ;select the Xth string from the table of strings
;       JSR PRINT_XTH_STR       ;sets the address pointer to the adress of Xth string after the string as pointed to as indicated
;
;
;the table consists of string that all end with 0
;example:
;  BYTE 'MENU OPTION-A                 ',0      ;
;  BYTE 'MENU OPTION-B                 ',0      ;
;  BYTE 'MENU OPTION-C                 ',0      ;
;-------------------------------------------------------------------------------
PRINT_XTH_STR   STA STR_ADDR            ;
                STY STR_ADDR+1          ;
                TXA                     ;check if X=0
                BEQ SET_PR_STR_END      ;when X=0 then we've allready have the correct pointer value and we're done
SET_PR_STR_01   JSR PRINT_XTH_INCA      ;increment address by one
                LDY #$00                ;
                LDA (STR_ADDR),Y        ;read character from string
                BEQ SET_PR_STR_02       ;when the character was 0, then the end of string marker was detected          
                JMP SET_PR_STR_01       ;repeat until end of string reached
SET_PR_STR_02   DEX                     ;decrement string index counter
                BNE SET_PR_STR_01       ;keep looping until we reached the string we want
                JSR PRINT_XTH_INCA      ;increment address by one (we want to point to the first character of the next table entry, we are now pointing to the end of line marker)
SET_PR_STR_END  JMP PRINT_CUR_STR       ;print the string

PRINT_XTH_INCA  CLC                     ;
                LDA #$01                ;increment the pointer to the string by one in order to get the next char/value
                ADC STR_ADDR            ;add 1
                STA STR_ADDR            ;string address pointer
                LDA #$00                ;add 0 + carry of the previous result
                ADC STR_ADDR+1          ;meaning that if we have an overflow, the must increment the high byte
                STA STR_ADDR+1          ;  
                RTS
;-------------------------------------------------------------------------------
;call this routine as described below:
;
;        LDA #<label                ;set pointer to the text that defines the main-screen
;        LDY #>label                ;
;        JSR PRINT_STRING        ;the print routine is called, so the pointed text is now printed to screen
;
; JSR PRINT_CUR_STR ;print the string as indicated by the current string pointer
;-------------------------------------------------------------------------------
PRINT_STRING    STA STR_ADDR            ;
                STY STR_ADDR+1          ;
PRINT_CUR_STR   LDY #$00                ;
                LDA (STR_ADDR),Y        ;read character from string
                BEQ PR_STR_END          ;when the character was 0, then the end of string marker was detected and we must exit
                JSR PRINT_CHAR          ;print char to screen
                                     
                CLC                     ;
                LDA #$01                ;add 1
                ADC STR_ADDR            ;
                STA STR_ADDR            ;string address pointer
                LDA #$00                ;
                ADC STR_ADDR+1          ;add carry...
                STA STR_ADDR+1          ;                            

                JMP PRINT_CUR_STR       ;repeat...

PR_STR_END      RTS                     ;

;-------------------------------------------------------------------------------
; this routine will print the value in A as a 2 digit hexadecimal value
;        LDA #value                      ;A-register must contain value to be printed
;        JSR PRINT_HEX     ;the print routine is called
;-------------------------------------------------------------------------------
PRINT_HEX       PHA                     ;save A to stack
                AND #$F0                ;mask out low nibble
                LSR A                   ;shift to the right
                LSR A                   ;
                LSR A                   ;
                LSR A                   ;
                TAX                     ;
                LDA HEXTABLE,X          ;convert using table                                 
                JSR PRINT_CHAR          ;print character to screen

                PLA                     ;retrieve A from stack
                AND #$0F                ;mask out high nibble
                TAX                     ;
                LDA HEXTABLE,X          ;convert using table                                 
                JSR PRINT_CHAR          ;print character to screen
 
                RTS                     ;

HEXTABLE        TEXT '0123456789abcdef'                 

;===================================================================
; this routine will print the value in A as a 3 digit decimal value
;        LDA #value        ;Y-register must contain value to be printed
;        JSR PRINT_DEC     ;the print routine is called
;
;Converts .A to 3 ASCII/PETSCII digits: .Y = hundreds, .X = tens, .A = ones
;===================================================================
;PRINT_DEC       LDY #$2f                ;
;                LDX #$3a                ;
;                SEC                     ;
;DEC_01          INY                     ;
;                SBC #100                ;
;                BCS DEC_01              ;

;DEC_02          DEX                     ;
;                ADC #10                 ;
;                BMI DEC_02              ;
;        
;                ADC #$2f                ;
;                PHA                     ;save A to stack

;                TYA                     ;transfer value to A for printing
;                JSR PRINT_CHAR          ;print 100's

;                TXA                     ;transfer value to A for printing
;                JSR PRINT_CHAR          ;print 10's

;                PLA                     ;retrieve saved A from stack for printing
;                JSR PRINT_CHAR          ;print 1's

;                RTS                     ;


;-------------------------------------------------------------------------------
; use this routine before calling a PRINT related routine
;                        LDX CURSOR_Y;.. chars from the top of the defined screen area
;                        LDY CURSOR_X;.. chars from the left of the defined screen area
;   JSR SET_CURSOR
;-------------------------------------------------------------------------------
;CHARSCREEN = $0400 (default char screen loc.) is the first visible char location within this program 
;the first location is defined as coordinate 0,0 (which makes life so much easier)

SET_CURSOR      LDA #<CHARSCREEN        ;
                STA CHAR_ADDR           ;store base address (low byte)
                LDA #>CHARSCREEN        ;
                STA CHAR_ADDR+1         ;store base address (high byte)

                LDA #<COLORSCREEN       ;
                STA COLOR_ADDR          ;store base address (low byte)
                LDA #>COLORSCREEN       ;
                STA COLOR_ADDR+1        ;store base address (high byte)

                ;calculate exact value based on the requested X and Y coordinate
                CLC                     ;
                TXA                     ;add  value in X register (to calculate the new X position of cursor)
                ADC CHAR_ADDR           ;                        
                STA CHAR_ADDR           ;
                LDA #$00                ;
                ADC CHAR_ADDR+1         ;add carry
                STA CHAR_ADDR+1         ;

                CLC                     ;
                TXA                     ;add  value in X register (to calculate the new X position of cursorcolor)
                ADC COLOR_ADDR          ;                        
                STA COLOR_ADDR          ;
                LDA #$00                ;
                ADC COLOR_ADDR+1        ;add carry
                STA COLOR_ADDR+1        ;

                TYA                     ;save Y for next calc
                PHA                     ;
SET_CURS_CHR_LP CPY #00                 ;
                BEQ SET_CURS_COL        ;when Y is zero, calculation is done

                CLC                     ;
                LDA #40                 ;add  40 (which is the number of characters per line) to calculate the new Y position of cursor
                ADC CHAR_ADDR           ;                        
                STA CHAR_ADDR           ;
                LDA #$00                ;
                ADC CHAR_ADDR+1         ;add carry... and viola, we have a new cursor position (memory location where next character will be printed)
                STA CHAR_ADDR+1         ;
                DEY                     ;
                JMP SET_CURS_CHR_LP     ;


SET_CURS_COL    PLA                     ;
                TAY                     ;restore Y for calc
SET_CURS_COL_LP CPY #00                 ;
                BEQ SET_CURS_END        ;when Y is zero calculation is done

                CLC                     ;
                LDA #40                 ;add  40 (which is the number of characters per line) to calculate the new Y position of cursor
                ADC COLOR_ADDR          ;                        
                STA COLOR_ADDR          ;
                LDA #$00                ;
                ADC COLOR_ADDR+1        ;add carry... and viola, we have a new cursor position (memory location where next character will be printed)
                STA COLOR_ADDR+1        ;
                DEY                     ;
                JMP SET_CURS_COL_LP     ;
SET_CURS_END    RTS                     ;
  
  
;===============================================================================
;   TEXT tables
;===============================================================================

MAIN_SCREEN
; Screen 1 - MAIN_SCREEN
      ; Screen 1 - MAIN_SCREEN
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$55,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$49,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$5D,$03,$01,$13,$13,$09,$0F,$10,$05,$09,$3A,$20,$16,$11,$20,$10,$0C,$01,$19,$05,$12,$5D,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$4A,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$4B,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$70,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$6E,$20,$20,$20
        BYTE    $20,$20,$20,$5D,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$5D,$20,$20,$20
        BYTE    $20,$20,$20,$5D,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$5D,$20,$20,$20
        BYTE    $20,$20,$20,$5D,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$5D,$20,$20,$20
        BYTE    $20,$20,$20,$5D,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$5D,$20,$20,$20
        BYTE    $20,$20,$20,$5D,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$5D,$20,$20,$20
        BYTE    $20,$20,$20,$5D,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$5D,$20,$20,$20
        BYTE    $20,$20,$20,$5D,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$5D,$20,$20,$20
        BYTE    $20,$20,$20,$5D,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$5D,$20,$20,$20
        BYTE    $20,$20,$20,$5D,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$5D,$20,$20,$20
        BYTE    $20,$20,$20,$5D,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$5D,$20,$20,$20
        BYTE    $20,$20,$20,$5D,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$5D,$20,$20,$20
        BYTE    $20,$20,$20,$6D,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$7D,$20,$20,$20
        BYTE    $43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$13,$05,$0C,$05,$03,$14,$20,$06,$09,$0C,$05,$20,$14,$0F,$20,$10,$0C,$01,$19,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$06,$33,$3D,$15,$10,$2C,$20,$06,$35,$3D,$04,$0F,$17,$0E,$2C,$20,$12,$05,$14,$15,$12,$0E,$3D,$10,$0C,$01,$19,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
        BYTE    $20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20

        BYTE    0 ;end of table marker
        

LINE            BYTE $0
LINE_CNT        BYTE $0
ENTRY           BYTE $0
INDEX_MAX       BYTE $0
INDEX           BYTE $0                 ;index (0=first file, 1=second file, etc.)




##{0}D:\Projects\Cassiopei\Software\CBM_software\C64\example_VQImages\1000_VQ_player.asm

*=$1000


PLAY_VQ_ANIM    JSR BOOK_PETSCII        ;by default we are referring to the PETSCII codebook

PLAY_NEXT       JSR LOAD_AND_SHOW       ;load image to buffer
                SEC                     ;set carry (required in order to detect an underflow)
                LDA NMBR_OF_FRAMES      ;low byte of remaining frame counter
                SBC #$01                ;decrement by one
                STA NMBR_OF_FRAMES      ;store result
                LDA NMBR_OF_FRAMES+1    ;high  byte of remaining frame counter
                SBC #$00                ;process the carry
                STA NMBR_OF_FRAMES+1    ;store result
                ;check if the number of frames is still not 0
                BNE PLAY_NEXT           ;remaining frames > 0, continue showing frames
                LDA NMBR_OF_FRAMES      ;check the low byte
                BNE PLAY_NEXT           ;remaining frames > 0, continue showing frames
                ;the file we've read contains no frames (or all frames are shown), so we exit!

                JSR BOOK_PETSCII        ;return back to normal charset, otherwise the menu will be unreadable
                RTS

;-------------------------------------------------------------------------------
;This routine will open the file to prepare it to read data in other routines
; When the opening of the file succeeded, the carry is cleared
; When the opening of the file failed, the carry is set
;
;when the file is found, it remains ready for data transfer, the CPIO connection
;is not closed and therefore interrupts remain disabled !
;...............................................................................
OPEN_FILE       LDA CPIO_PARAMETER      ;the mode we want to operate in   
                JSR CPIO_START          ;send this command so the connected device knows we now start working in this mode               

                LDA OFFSET_MSB          ;MSB of offset in the file
                JSR CPIO_SEND           ;
                LDA OFFSET_XSB          ;
                JSR CPIO_SEND           ;
                LDA OFFSET_LSB          ;LSB of offset
                JSR CPIO_SEND           ;               

                LDA #<FILENAME          ;set pointer to the text
                STA STR_ADDR            ;
                LDA #>FILENAME          ;
                STA STR_ADDR+1          ;
                JSR SEND_STRING         ;sends a string to the cassiopei

                LDA CPIO_DATALOAD       ;the mode we want to operate in   
                JSR CPIO_START          ;send this command so the connected device knows we now start working in this mode
                JSR CPIO_RECIEVE        ;the cassiopei responds with a 0=file-not-found, 1=file-found, do not drop attention as we want to continue loading data
                BNE FILE_FOUND          ;0=file-not-found !

FILE_NOT_FOUND  JSR CPIO_INIT           ;CPIO_INIT is used to raise the attention signal, and by doing so we indicate that we no longer require data from (or going to send data to) the cassiopei
                CLI                     ;enable interrupts
                SEC                     ;set the carry to indicate we could not open the requested file
                RTS                     ;return to caller

FILE_FOUND      CLC                     ;clear carry to indicate the file is found and opened
                RTS                     ;return to caller


FILENAME        BYTE 0,1,2,3,4,5,6,7,8,9;the filename must be in upper case (filename does not have to be complete filename, the first 5 chars is normally enough depending on the other files on the Cassiopei's flash
                BYTE 0,1,2,3,4,5,6,7,8,9;
                BYTE 0,1,2,3,4,5,6,7,8,9;
                BYTE 0,1                ;
                BYTE 0                  ;end of table marker

;-------------------------------------------------------------------------------
;load the header of the image file
;When the opening of the file succeeded and the header is OK then the carry is cleared
;When the opening of the file failed or the header is not OK, then carry is set
;...............................................................................
LOAD_HEADER     LDA #$0                 ;reset the offset to the beginning of the file (because the header is at the beginning of the file)
                STA OFFSET_MSB          ;MSB of offset in the file
                STA OFFSET_XSB          ;
                STA OFFSET_LSB          ;LSB of offset

                JSR OPEN_FILE           ;open the data file
                BCS LD_HEADER_ERROR     ;carry set, then file not found and we exit the program
                
                JSR CPIO_RECIEVE        ;get the version of the VQImage file
                CMP #$00                ;we expect version 0, if it is anything else, we exit as failed
                BEQ LD_HEADER_OK        ;
                JSR CPIO_INIT           ;CPIO_INIT is used to raise the attention signal, and by doing so we indicate that we no longer require data from (or going to send data to) the cassiopei
                CLI                     ;enable interrupts
                SEC                     ;set the carry to indicate we could not open the requested file
                JMP LD_HEADER_ERROR     ;


LD_HEADER_OK    JSR CPIO_RECIEVE        ;get the number of images stored in this file high byte
                STA NMBR_OF_FRAMES+1    ;save to RAM
                JSR CPIO_RECIEVE        ;get the number of images stored in this file low byte
                STA NMBR_OF_FRAMES      ;save to RAM

                JSR CPIO_RECIEVE        ;get the number of colors used in this file
                ;ignore value as (most) PETs cannot show colors

                JSR CPIO_RECIEVE        ;get the X-size (in tiles)
                STA X_SIZE              ;

                JSR CPIO_RECIEVE        ;get the Y-size (in tiles)
                STA Y_SIZE              ;

                JSR CPIO_REC_LAST       ;get the codebook size (in tiles)
                ;ignore value
        LDA #$00
                STA CODEBOOK_SIZE       ;

                ;change the offset, so the next time we do a file open we read past the header
                LDA #$07                ;the number of bytes we've just read from the file
                JSR ADD_SMALL_OFFSET    ;add these to the offset, so the next time we read we read past the data we've already read


LD_HEADER_EXIT  CLC                     ;clear carry to indicate everything is OK
LD_HEADER_ERROR RTS                     ;

;-------------------------------------------------------------------------------
;load an image (or frame) from the file, when the file has just been opened we load the first
;when we call this routine again we load the next, etc.
;...............................................................................
LOAD_AND_SHOW   JSR OPEN_FILE           ;open the data file (the last read position is maintained)
                JSR CPIO_RECIEVE        ;get the mode, B7: 0=normal, 1=delta
                STA MODE_BYTE           ;

                LDA #$01                ;
                JSR ADD_SMALL_OFFSET    ;add the number of byte we've read to the file-offset, so the next time when we read we read past this point

                LDA MODE_BYTE           ;
                AND #%10000000          ;mask out bit-7
                BEQ CODEBOOK_CHECK      ;
                JMP DELTA_MODE          ;in delta mode the codebook does not change, so we skip the codebook loading part

CODEBOOK_CHECK  LDA MODE_BYTE           ;check if this frame/image contains codebook data
                AND #%01000000          ;mask out bit-6
                BEQ CODEBOOK_DONE       ;the frame/image contains no codebook data

CODEBOOK_LOAD   LDA #$00                ;
                STA CODEBOOK_CNT        ;

                INC ODD_EVEN            ;increment variable to keep track of the buffer we must use
                LDA ODD_EVEN            ;determine which memory area to use
                AND #%00000001          ;because we toggle each frame otherwise the screen
                BEQ CODEBOOK_EVEN       ;will screw up during loading of the codebook
               ;JMP CODEBOOK_ODD        ;

CODEBOOK_ODD    LDA #$28                ;high-byte of charset address
                STA CHAR_ADDR+1         ;
                JMP CODEBOOK_LOOP       ;

CODEBOOK_EVEN   LDA #$20                ;high-byte of charset address
                STA CHAR_ADDR+1         ;
               ;JMP CODEBOOK_LOOP       ;

CODEBOOK_LOOP   LDA #$00                ;low-byte of charset address
                STA CHAR_ADDR           ;
                LDY #$00                ;
CODEBOOK_LP01   LDX #$08                ;
CODEBOOK_LP02   JSR CPIO_RECIEVE        ;get the codebook data
                STA (CHAR_ADDR),Y       ;tile data read from file will now be stored to the correct memory location
                CLC                     ;increment character pointer
                LDA #$01                ;add 1
                ADC CHAR_ADDR           ;                        
                STA CHAR_ADDR           ;
                LDA #$00                ;
                ADC CHAR_ADDR+1         ;add carry... and viola, we have a new cursor position (memory location where char (tile) byte will be saved)
                STA CHAR_ADDR+1         ;      
                DEX                     ;
                BNE CODEBOOK_LP02       ;

                INC CODEBOOK_CNT        ;
                LDA CODEBOOK_CNT        ;
                CMP CODEBOOK_SIZE       ;
                BNE CODEBOOK_LP01       ;keep loading until done

CODEBOOK_LOADED LDA #$00                ;we just loaded a complete codebook, size 2048 bytes (=$0800)
                STA CNTR                ;calculate
                LDA #$08                ;
                STA CNTR+1              ;save
                JSR ADD_BIG_OFFSET      ;add the number of byte we are going to read to the file-offset, so the next time we read we read past this point
CODEBOOK_DONE

;------------                           
NORMAL_MODE     LDA #>CHARSCREEN_BUF    ;the destination of the data
                STA ADDR+1              ;high byte of destination address
                LDA #<CHARSCREEN_BUF    ;
                STA ADDR                ;low byte of destination address

                LDA #$00                ;
                STA CNTR+1              ;
                                        ;calculate the number of tiles to read
                LDY Y_SIZE              ;based on the information extracted from the 
                LDX X_SIZE              ;header of the image file. There is stored the
CALC_IMAGE_SIZE TXA                     ;
                CLC                     ;clear carry
                ADC CNTR                ;calculate
                STA CNTR                ;save
                LDA #$00                ;
                ADC CNTR+1              ;add carry (if there was one)
                STA CNTR+1              ;save
                DEY                     ;
                BNE CALC_IMAGE_SIZE     ;

                JSR ADD_BIG_OFFSET      ;add the number of byte we are going to read to the file-offset, so the next time we read we read past this point

                LDY #$00                ;we only need to load Y-reg once, because there is nothing else affecting it so it remains 0 for the duration of the loop
CMD_LOAD_LP_01  JSR CPIO_RECIEVE        ;
                STA (ADDR),Y            ;store byte read from file to the requested memory location

                INC ADDR                ;increment address pointer
                BNE CMD_LOAD_LP_02      ;
                INC ADDR+1              ;

CMD_LOAD_LP_02  SEC                     ;decrement counter
                LDA CNTR                ;
                SBC #$01                ;subtract 1
                STA CNTR                ;
                BCS CMD_LOAD_LP_03      ;check overflow
                DEC CNTR+1              ;decrement high-byte

CMD_LOAD_LP_03  LDA CNTR                ;
                BNE CMD_LOAD_LP_01      ;check if low-byte 0
                LDA CNTR+1              ;
                BNE CMD_LOAD_LP_01      ;check if high-byte 0

                LDA MODE_BYTE           ;check if this frame/image contains codebook data
                AND #%01000000          ;mask out bit-6
                BEQ CMD_LOAD_LP_04      ;the frame/image contains no codebook data, so skip using the new codebook (because there isn't any)

                JSR USE_NEW_CODEBOOK    ;all data loaded, now use it
CMD_LOAD_LP_04  JSR USE_NEW_IMAGE_DATA  ;all data loaded now use it
                JMP LOAD_IMAGE_EXIT     ;high- and low-byte are 0, we must exit the loop

;------------
DELTA_MODE      LDA #>CHARSCREEN_BUF    ;the destination of the data
                STA ADDR+1              ;high byte of destination address
                LDA #<CHARSCREEN_BUF    ;
                STA ADDR                ;low byte of destination address

                JSR CPIO_RECIEVE        ;get the number of changed tiles (high byte)
                STA CNTR+1              ;
                JSR CPIO_RECIEVE        ;get the number of changed tiles (low byte)
                STA CNTR                ;
                JSR ADD_BIG_OFFSET      ;add the number of byte we are going to read to the file-offset, so the next time we read we read past this point
                JSR ADD_BIG_OFFSET      ;add it again, because we are reading each tile is defined by 2 bytes

                LDA #$02                ;
                JSR ADD_SMALL_OFFSET    ;add the number of bytes we've read to the file-offset, so the next time when we read we read past this point


                LDA CNTR                ;check if there is any new data in this frame
                BNE CMD_LOAD_LP_11      ;because it could be possible that there are no changes
                LDA CNTR+1              ;so we must be able to handle that situation
                BNE CMD_LOAD_LP_11      ;
                JMP LOAD_IMAGE_EXIT     ;

CMD_LOAD_LP_11  JSR CPIO_RECIEVE        ;get relative position of the changed tile
                CLC                     ;clear carry
                ADC ADDR                ;add the position to the current address
                STA ADDR                ;save result
                LDA #$00                ;
                ADC ADDR+1              ;
                STA ADDR+1              ;

;        ;<<< DEBUG >>>
;        LDA ADDR+1      ;prevent loading to an area which outside video RAM
;        CMP #$08        ;which is a problem for CBM8032, the screen might go black !!
;        BCC OK
;        
;        LDA ADDR+1
;        JSR DEBUG_PRINT_ACC0
;        LDA ADDR
;        JSR DEBUG_PRINT_ACC
;
;PROBLEM JMP LOAD_IMAGE_EXIT 
;OK
;        ;<<< END-OF-DEBUG >>>

                LDY #$00                ;
                JSR CPIO_RECIEVE        ;get the tile value
                STA (ADDR),Y            ;store byte read from file to the requested memory location

CMD_LOAD_LP_12  SEC                     ;decrement counter
                LDA CNTR                ;
                SBC #$01                ;subtract 1
                STA CNTR                ;
                BCS CMD_LOAD_LP_13      ;check overflow
                DEC CNTR+1              ;decrement high-byte

CMD_LOAD_LP_13  LDA CNTR                ;
                BNE CMD_LOAD_LP_11      ;check if low-byte 0
                LDA CNTR+1              ;
                BNE CMD_LOAD_LP_11      ;check if high-byte 0

                JSR USE_NEW_IMAGE_DATA  ;all data loaded, now use it

;--------------                         ;high- and low-byte are 0, we must exit the loop
LOAD_IMAGE_EXIT JSR CPIO_REC_LAST       ;the last load is just a dummy, we're done loading data
                CLI                     ;enable interrupts
                RTS                     ;return to caller



;-------------------------------------------------------------------------------
;When a frame is loaded it is not directly visible, it requires to be copied to
;the video memory from which it can be shown.
;But also the codebook may need to be changed. If a completely new codebook is loaded
;then we need switch to the new codebook (which is nothing more then selecting the
;newly loaded charset by adjusting the VIC pointers to the charset to be used)
;...............................................................................

USE_NEW_CODEBOOK
                LDA ODD_EVEN            ;first we must determine if the frame is odd or even
                AND #%00000001          ;if we know that then we know which codebook buffer to use
                BNE BOOK_ODD            ;
                
BOOK_EVEN       ;select the memory bank for the VIC to use
                LDA $D018               ;get current charset location settings
                AND #%11110001          ;mask out unrelated bits
                ORA #%00001000          ;set charset related bits to the preferred state, location ($2000-$27FF)
                JMP USE_CBOOK_EXIT      ;

BOOK_ODD        ;select the memory bank for the VIC to use
                LDA $D018               ;get current charset location settings
                AND #%11110001          ;mask out unrelated bits
                ORA #%00001010          ;set charset related bits to the preferred state, location ($28000-$2FFF)
                JMP USE_CBOOK_EXIT      ;

BOOK_PETSCII    LDA #$15                ;default charset pointer value

USE_CBOOK_EXIT  STA $D018               ;
                RTS                     ;

;...............................................................................

USE_NEW_IMAGE_DATA 
                ;this routine will copy the data from the buffer to the video memory so it will become visible
COPY_FROM_BUF   LDY #$00
COPY_FROM_B01   LDA CHARSCREEN_BUF,Y
                STA CHARSCREEN,Y
                LDA CHARSCREEN_BUF+256,Y
                STA CHARSCREEN+256,Y
                LDA CHARSCREEN_BUF+512,Y
                STA CHARSCREEN+512,Y
                LDA CHARSCREEN_BUF+744,Y
                STA CHARSCREEN+744,Y

                DEY
                BNE COPY_FROM_B01
                RTS

;-------------------------------------------------------------------------------
;...............................................................................
;increment offset by the value in the 2 byte register CNTR
ADD_BIG_OFFSET  CLC                     ;
                LDA CNTR                ;
                ADC OFFSET_LSB          ;
                STA OFFSET_LSB          ;

                LDA CNTR+1              ; 
                ADC OFFSET_XSB          ;
                STA OFFSET_XSB          ;
                BCC INC_OFFSET_1        ;
                INC OFFSET_MSB          ;

INC_OFFSET_1    RTS                     ;

;...............................................................................
;increment offset by value in A
;       LDA #$07                ;add 7
;       JSR ADD_SMALL_OFFSET    ;

ADD_SMALL_OFFSET
                CLC                     ;
                ADC OFFSET_LSB          ;
                STA OFFSET_LSB          ;
                LDA #$00                ;
                ADC OFFSET_XSB          ;
                STA OFFSET_XSB          ;
                LDA #$00                ;
                ADC OFFSET_MSB          ;
                STA OFFSET_MSB          ;
                RTS                     ;

;=================================================================================
; This routine will send a string to the Cassiopei
; call example:
; -------------
;
;   LDA #<FILENAME_1        ;set pointer to the text that defines the main-screen
;   STA STR_ADDR            ;
;   LDA #>FILENAME_1        ;
;   STA STR_ADDR+1          ;
;   JSR SEND_STRING         ;sends a string to the cassiopei
;
; Table example:
; --------------
;
;   BYTE "THE A TEAM"       ;the filename must be in upper case
;   BYTE 0                  ;end of table marker
;
;---------------------------------------------------------------------------------
                
SEND_STRING     LDY #$00                ;
                LDA (STR_ADDR),Y        ;read character from string
                BEQ SEND_STR_END        ;when the character was 0, then the end of string marker was detected and we must exit

                JSR CPIO_SEND           ;send char to Cassiopei
                                     
                CLC                     ;
                LDA #$01                ;add 1
                ADC STR_ADDR            ;
                STA STR_ADDR            ;string address pointer
                LDA #$00                ;
                ADC STR_ADDR+1          ;add carry...
                STA STR_ADDR+1          ;                            

                JMP SEND_STRING         ;repeat...

SEND_STR_END    JSR CPIO_SEND_LAST      ;send last (end-of_string) char to Cassiopei
                RTS                     ;

##{0}D:\Projects\Cassiopei\Software\CBM_software\C64\example_VQImages\0000_Info.asm

;This program was written by Jan Derogee
;do not alter use or spread this program without his permission


;---------------------------------------------------------------------------------------------------------
;ATTENTION: This code has been developed to be used with the CBM Program Studio compiler
;---------------------------------------------------------------------------------------------------------

;When using CBM prog studio to compile this program, make sure that you
;compile the entire project (Build -> Project -> And Run (CTRL+F5) )

;All files in this program have a ORG address (indicated by *=$xxxx)
;When this program is to be compiled with another program then CBM prog studio
;simply append all files in ascending order and all will be fine



;regarding the CBM program studio assembler mind the following settings:
;disable the option : optimize absolute modes to zero page

##{0}D:\Projects\Cassiopei\Software\CBM_software\C64\example_VQImages\1F00_CPIO_routines.asm


*=$1F00        ; START ADDRESS 7936


;///////////////////////////////////////////////////////////////////////////////
;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
;
;                          C P I O   r o u t i n e s
;
;///////////////////////////////////////////////////////////////////////////////
;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


;*******************************************************************************
; Cassette Port Input Output protocol initialisation
;******************************************************************************* 
CPIO_INIT       LDA DATA_BIT_6510   ;
                ORA #%00101000      ;P5: lower ATTENTION-line (this signal is inverted therefore we need to write a '1' into the reg.) by the power stage that drives the motor-line
                STA DATA_BIT_6510   ;P3: raise CLOCK-line (cassette write-line)               

                LDA DATA_DIR_6510   ;data direction register of the MOS6510
                AND #%11101111      ;set the direction of the DATA-line (cassette button sense-line) to input
                STA DATA_DIR_6510   ;data direction register of the MOS6510

                RTS

;*******************************************************************************
;JSR CPIO_WAIT4RDY   ;wait until the CPIO device (slave) is ready

CPIO_WAIT4RDY   LDA $DC0D           ;read CIA connected to the cassetteport (reading clears the state of the bits)
                AND #%00010000      ;mask out bit 4
                BEQ CPIO_WAIT4RDY   ;loop until the slave lowers the read signal              
                RTS

;*******************************************************************************
;LDA <data>     ;data is the requested operating mode of the slave
;JSR CPIO_START  ;raise attention signal, now communication is set up, we can read or write data from this point
CPIO_START      STA CPIO_DATA       ;store value in A (which holds the mode-byte) to working register

                SEI                 ;disable interrupts
                LDA $DC0D           ;reading clears all flags, so when we do a Read here we clear the old interrupts so that our routines will trigger on the correct event (instead of an old unhandled event)
               
                LDA DATA_BIT_6510   ;set ATTENTION signal to make slave prepare for communication
                AND #%11011111      ;motor control line is set to 0 (MOTOR is now ON (6 volt))
                STA DATA_BIT_6510   ;

                JMP SEND_DATA       ;send the mode byte to the slave


;*******************************************************************************
;this routine will lower the attention to indicate that the current is the last byte
CPIO_SEND_LAST  STA CPIO_DATA       ;safe the data (stored in the accu) to a working register

                LDA DATA_DIR_6510   ;data direction register of the MOS6510
                ORA #%00010000      ;set the direction of the sense line to output
                STA DATA_DIR_6510   ;data direction register of the MOS6510

                JSR CPIO_WAIT4RDY   ;wait until the CPIO device (slave) is ready
                
                LDA DATA_BIT_6510   ;send a '0'
                ORA #%00100000      ;motor control line is set to 1 (MOTOR is now OFF (0 Volt))
                STA DATA_BIT_6510   ;with the attention signal being low (motor-off) the slave has been notified that communication has come to an end and that the current byte is the last byte within this session

                LDY #$08            ;every byte consists of 8 bits, this will be use in the CPIO_send and CPIO_recieve routine which are calling this routine
                JMP SEND_DATA_LP    ;
;...............................................................................
;this routine will send a byte to the slave
;LDA <data>
;JSR CPIO_SEND

CPIO_SEND       STA CPIO_DATA       ;safe the data (stored in the accu) to a working register
SEND_DATA       LDY #$08            ;every byte consists of 8 bits, this will be use in the CPIO_send and CPIO_recieve routine which are calling this routine

                LDA DATA_DIR_6510   ;data direction register of the MOS6510
                ORA #%00010000      ;set the direction of the sense line to output
                STA DATA_DIR_6510   ;data direction register of the MOS6510

                JSR CPIO_WAIT4RDY   ;wait until the CPIO device (slave) is ready                
SEND_DATA_LP
SEND_CLOCK_0    LDA DATA_BIT_6510   ;lower clock
                AND #%11110111      ;change state of write line to '0'
                STA DATA_BIT_6510   ;    

                BIT CPIO_DATA       ;bit moves bit-7 of CPIO_DATA into the N-flag of the status register
                BPL SEND_ZERO       ;BPL tests the N-flag, when it is 0 the branch to SEND_ZERO is executed (using the BIT instruction instead of conventional masking, we save 2 cycles, and 2 bytes)
SEND_ONE        LDA DATA_BIT_6510   ;
                ORA #%00010000      ;change state of sense line to '1'
                JMP SEND_BIT        ;
SEND_ZERO       LDA DATA_BIT_6510   ;
                AND #%11101111      ;change state of sense line to '0'

SEND_BIT        STA DATA_BIT_6510   ;
SEND_CLOCK_1   ; LDA DATA_BIT_6510  ;raise clock to indicate data is ready for the slave to be read
                ORA #%00001000      ;change state of write line to '1'
                STA DATA_BIT_6510   ;
                ASL CPIO_DATA       ;rotate data in order to send each individual bit, we do it here so that we save time, we have to wait for the clock pulse high-time anyway

                DEY                 ;decrement the Y value
                BNE SEND_DATA_LP    ;exit loop after the eight bit

                LDA DATA_BIT_6510   ;
                AND #%11110111      ;lower the clock line so that the slave has the opportunity to read the data
                STA DATA_BIT_6510   ;
                ORA #%00001000      ;raise clock by changing state of write line to '1' to indicate that the byte has come to an end
                STA DATA_BIT_6510   ;

                LDA DATA_DIR_6510   ;data direction register of the MOS6510
                AND #%11101111      ;set the direction of the sense line to input
                STA DATA_DIR_6510   ;data direction register of the MOS6510
                RTS                 ;end of subroutine

;*******************************************************************************
;this routine will lower the attention to indicate that the current is the last byte
CPIO_REC_LAST   JSR CPIO_WAIT4RDY   ;wait until the CPIO device (slave) is ready

                LDA DATA_BIT_6510   ;send a '0'
                ORA #%00100000      ;motor control line is set to 1 (MOTOR is now OFF (0 Volt))
                STA DATA_BIT_6510   ;with the attention signal being low (motor-off) the slave has been notified that communication has come to an end and that the current byte is the last byte within this session

                LDA #$01            ;the LSB is one,but after eight ROL's it will end up in the carry, which we can detect and use to end our loop
                STA CPIO_DATA       ;by using our working data destination register we do not require a CLC on every bit check and we don't need a DEY after every bit
                CLC                 ;clear the carry as it could be set by a previous routine
                JMP CPIO_RECIEVE_L  ;

;...............................................................................
;this routine will recieve a byte to the slave
;JSR CPIO_RECIEVE
;data is in Accu
;
;does not affect X and Y registers


CPIO_RECIEVE    LDA #$01                ;every byte consists of 8 bits, this will be use in the CPIO_send and CPIO_recieve routine which are calling this routine
                STA CPIO_DATA           ;after 8 ROL's this will be in the carry register

CPIO_REC_01     JSR CPIO_WAIT4RDY       ;wait until the CPIO device (slave) is ready  

CPIO_RECIEVE_L  TYA
                PHA
                TXA
                PHA
        
                LDA DATA_BIT_6510       ;lower clock
                AND #%11110111          ;calculate state of write line (CLOCK) cleared to '0'
                STA DATA_BIT_6510       ;APPLY
                TAX                     ;save for later use 
                ORA #%00001000          ;calculate state of write line (CLOCK) set to '1'
                TAY                     ;save for later use
                CLC                     ;clear the carry, which is usefull for the ADC further on, because the  ROL will clear it otherwise.
        
REC_DATA_LP     
REC_CLOCK_1     STY DATA_BIT_6510       ;changing state of write line (CLOCK) to '1', indicating that the data will be sampled
                LDA DATA_BIT_6510       ;sample the data
REC_CLOCK_0     STX DATA_BIT_6510       ;changing state of write line (CLOCK) to '0', this enables the Cassiopei to setup the mext databit
                AND #%00010000          ;test input signal for '0' or '1'
                ADC #%11111111          ;when our input is a '1' it will cause the carry bit to be set
                ROL CPIO_DATA           ;shift all the bits one position to the right and add the LSB which is located in the carry
                BCC REC_DATA_LP         ;keep loopin untill the Carry becomes set (which will be after 8 ROL's)

                STY DATA_BIT_6510       ;changing state of write line (CLOCK) to '1'

                PLA
                TAX
                PLA
                TAY

                LDA CPIO_DATA           ;move data to accu
                RTS                     ;end of subroutine


;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

